<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://jscs.info"

    >jscs (v3.0.7)</a>
</h1>
<h4>JavaScript Code Style</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs">module jscs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.jscs">
            function <span class="apidocSignatureSpan"></span>jscs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration">
            function <span class="apidocSignatureSpan">jscs.</span>configuration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_anonymous_functions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_anonymous_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_array_destructuring_return">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_array_destructuring_return
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_arrow_functions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_arrow_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_capitalized_comments">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_capitalized_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_comma_before_line_break">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_comma_before_line_break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_curly_braces">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_curly_braces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_dangling_underscores">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_dangling_underscores
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_empty_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_empty_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_function_declarations">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_function_declarations
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identical_destructuring_names">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_identical_destructuring_names
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identifier_names">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_identifier_names
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_implicit_type_conversion">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_implicit_type_conversion
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_in_comments">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_in_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_on_new_line">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_on_new_line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_mixed_spaces_and_tabs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multi_line_ternary">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multi_line_ternary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_breaks">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_breaks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_strings">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_strings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_spaces">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_spaces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_var_decl">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_var_decl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_named_unassigned_functions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_named_unassigned_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_nested_ternaries">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_nested_ternaries
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_newline_before_block_statements">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_newline_before_block_statements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_node_types">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_node_types
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_not_operators_in_conditionals">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_not_operators_in_conditionals
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_object_keys_on_new_line">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_object_keys_on_new_line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_operator_before_line_break">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_operator_before_line_break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_use_strict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_export">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_export
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_line_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_objects">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_objects
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_parentheses_around_arrow_param
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_quoted_keys_in_objects">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_quoted_keys_in_objects
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_semicolons">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_semicolons
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_shorthand_arrow_functions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_shorthand_arrow_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_binary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_binary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_comma">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_line_comment">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_line_comment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_object_keys">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_object_keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_prefix_unary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_binary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_binary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_block_statements">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_block_statements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_comma">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_object_values">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_object_values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_postfix_unary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_semicolon">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_semicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_between_arguments">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_between_arguments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_anonymous_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_call_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_call_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_conditional_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_for_statement">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_for_statement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_declaration">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_declaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_generator">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_generator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_named_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_array_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_imported_object_braces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_object_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parentheses">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parentheses
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parenthesized_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_template_string_placeholders
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_tabs">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_tabs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_comma">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_whitespace">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_whitespace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_params">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_unused_params
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_variables">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_unused_variables
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_var">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_var
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_yoda_conditions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_yoda_conditions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors">
            function <span class="apidocSignatureSpan">jscs.</span>errors
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator">
            function <span class="apidocSignatureSpan">jscs.</span>generator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file">
            function <span class="apidocSignatureSpan">jscs.</span>js_file
            <span class="apidocSignatureSpan">(params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.jsdoc">
            function <span class="apidocSignatureSpan">jscs.</span>jsdoc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_line_length">
            function <span class="apidocSignatureSpan">jscs.</span>maximum_line_length
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_number_of_lines">
            function <span class="apidocSignatureSpan">jscs.</span>maximum_number_of_lines
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration">
            function <span class="apidocSignatureSpan">jscs.</span>node_configuration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_multiline_params">
            function <span class="apidocSignatureSpan">jscs.</span>require_aligned_multiline_params
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_object_values">
            function <span class="apidocSignatureSpan">jscs.</span>require_aligned_object_values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_anonymous_functions">
            function <span class="apidocSignatureSpan">jscs.</span>require_anonymous_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_array_destructuring">
            function <span class="apidocSignatureSpan">jscs.</span>require_array_destructuring
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_arrow_functions">
            function <span class="apidocSignatureSpan">jscs.</span>require_arrow_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_blocks_on_newline">
            function <span class="apidocSignatureSpan">jscs.</span>require_blocks_on_newline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers">
            function <span class="apidocSignatureSpan">jscs.</span>require_camelcase_or_uppercase_identifiers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments">
            function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors">
            function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors_new">
            function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors_new
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_comma_before_line_break">
            function <span class="apidocSignatureSpan">jscs.</span>require_comma_before_line_break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_curly_braces">
            function <span class="apidocSignatureSpan">jscs.</span>require_curly_braces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dollar_before_jquery_assignment">
            function <span class="apidocSignatureSpan">jscs.</span>require_dollar_before_jquery_assignment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dot_notation">
            function <span class="apidocSignatureSpan">jscs.</span>require_dot_notation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_early_return">
            function <span class="apidocSignatureSpan">jscs.</span>require_early_return
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_enhanced_object_literals">
            function <span class="apidocSignatureSpan">jscs.</span>require_enhanced_object_literals
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_function_declarations">
            function <span class="apidocSignatureSpan">jscs.</span>require_function_declarations
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_imports_alphabetized">
            function <span class="apidocSignatureSpan">jscs.</span>require_imports_alphabetized
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_keywords_on_new_line">
            function <span class="apidocSignatureSpan">jscs.</span>require_keywords_on_new_line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_break_after_variable_assignment">
            function <span class="apidocSignatureSpan">jscs.</span>require_line_break_after_variable_assignment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_feed_at_file_end">
            function <span class="apidocSignatureSpan">jscs.</span>require_line_feed_at_file_end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_matching_function_name">
            function <span class="apidocSignatureSpan">jscs.</span>require_matching_function_name
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multi_line_ternary">
            function <span class="apidocSignatureSpan">jscs.</span>require_multi_line_ternary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multiple_var_decl">
            function <span class="apidocSignatureSpan">jscs.</span>require_multiple_var_decl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_named_unassigned_functions">
            function <span class="apidocSignatureSpan">jscs.</span>require_named_unassigned_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_block_statements">
            function <span class="apidocSignatureSpan">jscs.</span>require_newline_before_block_statements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_single_statements_in_if">
            function <span class="apidocSignatureSpan">jscs.</span>require_newline_before_single_statements_in_if
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_numeric_literals">
            function <span class="apidocSignatureSpan">jscs.</span>require_numeric_literals
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_destructuring">
            function <span class="apidocSignatureSpan">jscs.</span>require_object_destructuring
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_keys_on_new_line">
            function <span class="apidocSignatureSpan">jscs.</span>require_object_keys_on_new_line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_operator_before_line_break">
            function <span class="apidocSignatureSpan">jscs.</span>require_operator_before_line_break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newline_after_variable_declaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_use_strict">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_use_strict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_export">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_export
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_line_comments">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_line_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_objects">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_objects
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_arrow_param">
            function <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_arrow_param
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_iife">
            function <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_iife
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_quoted_keys_in_objects">
            function <span class="apidocSignatureSpan">jscs.</span>require_quoted_keys_in_objects
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_semicolons">
            function <span class="apidocSignatureSpan">jscs.</span>require_semicolons
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_shorthand_arrow_functions">
            function <span class="apidocSignatureSpan">jscs.</span>require_shorthand_arrow_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_binary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_binary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_comma">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_line_comment">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_line_comment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_object_keys">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_object_keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_prefix_unary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_prefix_unary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_binary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_binary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_block_statements">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_block_statements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_comma">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_destructured_values">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_destructured_values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_object_values">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_object_values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_postfix_unary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_postfix_unary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_between_arguments">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_between_arguments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_anonymous_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_call_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_call_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_conditional_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_conditional_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_for_statement">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_for_statement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_declaration">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_declaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_generator">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_generator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_named_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_named_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_array_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_array_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_imported_object_braces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_object_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_object_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parentheses">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parentheses
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parenthesized_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spread">
            function <span class="apidocSignatureSpan">jscs.</span>require_spread
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_template_strings">
            function <span class="apidocSignatureSpan">jscs.</span>require_template_strings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_trailing_comma">
            function <span class="apidocSignatureSpan">jscs.</span>require_trailing_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_use_strict">
            function <span class="apidocSignatureSpan">jscs.</span>require_use_strict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_var_decl_first">
            function <span class="apidocSignatureSpan">jscs.</span>require_var_decl_first
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_yoda_conditions">
            function <span class="apidocSignatureSpan">jscs.</span>require_yoda_conditions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.safe_context_keyword">
            function <span class="apidocSignatureSpan">jscs.</span>safe_context_keyword
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_">
            function <span class="apidocSignatureSpan">jscs.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert">
            function <span class="apidocSignatureSpan">jscs.</span>token_assert
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_index">
            function <span class="apidocSignatureSpan">jscs.</span>token_index
            <span class="apidocSignatureSpan">(firstToken)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_aligned_function_parameters">
            function <span class="apidocSignatureSpan">jscs.</span>validate_aligned_function_parameters
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_comment_position">
            function <span class="apidocSignatureSpan">jscs.</span>validate_comment_position
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation">
            function <span class="apidocSignatureSpan">jscs.</span>validate_indentation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_line_breaks">
            function <span class="apidocSignatureSpan">jscs.</span>validate_line_breaks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_newline_after_array_elements">
            function <span class="apidocSignatureSpan">jscs.</span>validate_newline_after_array_elements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_order_in_object_keys">
            function <span class="apidocSignatureSpan">jscs.</span>validate_order_in_object_keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_parameter_separator">
            function <span class="apidocSignatureSpan">jscs.</span>validate_parameter_separator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_quote_marks">
            function <span class="apidocSignatureSpan">jscs.</span>validate_quote_marks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>cli_config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>configuration.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_anonymous_functions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_array_destructuring_return.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_arrow_functions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_capitalized_comments.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_comma_before_line_break.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_curly_braces.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_dangling_underscores.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_empty_blocks.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_function_declarations.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_identical_destructuring_names.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_identifier_names.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_implicit_type_conversion.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_keywords.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_in_comments.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_on_new_line.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_mixed_spaces_and_tabs.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_multi_line_ternary.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_breaks.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_strings.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_spaces.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_var_decl.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_named_unassigned_functions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_nested_ternaries.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_newline_before_block_statements.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_node_types.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_not_operators_in_conditionals.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_object_keys_on_new_line.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_operator_before_line_break.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_blocks.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_use_strict.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_export.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_keywords.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_line_comments.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_blocks.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_objects.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_parentheses_around_arrow_param.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_quoted_keys_in_objects.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_semicolons.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_shorthand_arrow_functions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_binary_operators.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_comma.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_keywords.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_line_comment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_object_keys.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_prefix_unary_operators.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_binary_operators.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_block_statements.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_comma.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_keywords.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_object_values.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_postfix_unary_operators.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_semicolon.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_between_arguments.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_anonymous_function_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_call_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_conditional_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_for_statement.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_declaration.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_generator.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_named_function_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_array_brackets.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_brackets.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_imported_object_braces.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_object_brackets.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parentheses.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parenthesized_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_template_string_placeholders.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_tabs.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_comma.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_whitespace.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_unused_params.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_unused_variables.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_var.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_yoda_conditions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>errors.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>generator.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>js_file.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>jsdoc.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>maximum_line_length.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>maximum_number_of_lines.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>node_configuration.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_aligned_multiline_params.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_aligned_object_values.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_anonymous_functions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_array_destructuring.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_arrow_functions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_blocks_on_newline.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_camelcase_or_uppercase_identifiers.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_capitalized_comments.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors_new.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_comma_before_line_break.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_curly_braces.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_dollar_before_jquery_assignment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_dot_notation.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_early_return.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_enhanced_object_literals.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_function_declarations.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_imports_alphabetized.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_keywords_on_new_line.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_line_break_after_variable_assignment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_line_feed_at_file_end.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_matching_function_name.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_multi_line_ternary.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_multiple_var_decl.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_named_unassigned_functions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_newline_before_block_statements.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_newline_before_single_statements_in_if.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_numeric_literals.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_object_destructuring.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_object_keys_on_new_line.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_operator_before_line_break.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_padding_newline_after_variable_declaration.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_blocks.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_use_strict.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_export.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_keywords.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_line_comments.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_blocks.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_objects.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_arrow_param.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_iife.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_quoted_keys_in_objects.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_semicolons.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_shorthand_arrow_functions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_after_binary_operators.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_after_comma.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_after_keywords.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_after_line_comment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_after_object_keys.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_after_prefix_unary_operators.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_before_binary_operators.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_before_block_statements.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_before_comma.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_before_destructured_values.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_before_keywords.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_before_object_values.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_before_postfix_unary_operators.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_between_arguments.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_anonymous_function_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_call_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_conditional_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_for_statement.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_declaration.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_generator.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_named_function_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_array_brackets.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_brackets.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_imported_object_braces.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_object_brackets.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parentheses.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parenthesized_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spread.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_template_strings.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_trailing_comma.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_use_strict.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_var_decl_first.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_yoda_conditions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>safe_context_keyword.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>token_assert.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>token_categorizer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>token_index.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>tree_iterator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>validate_aligned_function_parameters.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>validate_comment_position.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>validate_indentation.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>validate_line_breaks.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>validate_newline_after_array_elements.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>validate_order_in_object_keys.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>validate_parameter_separator.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>validate_quote_marks.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.cli_config">module jscs.cli_config</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.cli_config.getContent">
            function <span class="apidocSignatureSpan">jscs.cli_config.</span>getContent
            <span class="apidocSignatureSpan">(config, directory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.cli_config.getReporter">
            function <span class="apidocSignatureSpan">jscs.cli_config.</span>getReporter
            <span class="apidocSignatureSpan">(reporter, colors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.cli_config.load">
            function <span class="apidocSignatureSpan">jscs.cli_config.</span>load
            <span class="apidocSignatureSpan">(config, cwd)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.configuration">module jscs.configuration</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.configuration">
            function <span class="apidocSignatureSpan">jscs.</span>configuration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.configuration.prototype">module jscs.configuration.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._errorOnRemovedOptions">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_errorOnRemovedOptions
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._getOptionsFromConfig">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_getOptionsFromConfig
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._isDefined">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_isDefined
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadAdditionalRule">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadAdditionalRule
            <span class="apidocSignatureSpan">(additionalRule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadDefaults">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadDefaults
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadES3">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadES3
            <span class="apidocSignatureSpan">(es3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadErrorFilter">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadErrorFilter
            <span class="apidocSignatureSpan">(errorFilter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadExcludedFiles">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadExcludedFiles
            <span class="apidocSignatureSpan">(masks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadExtract">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadExtract
            <span class="apidocSignatureSpan">(masks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadFileExtensions">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadFileExtensions
            <span class="apidocSignatureSpan">(extensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadFix">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadFix
            <span class="apidocSignatureSpan">(fix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadMaxError">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadMaxError
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadPlugin">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadPlugin
            <span class="apidocSignatureSpan">(plugin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadPreset">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadPreset
            <span class="apidocSignatureSpan">(preset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadRules">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadRules
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._processConfig">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_processConfig
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._useRules">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_useRules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getBasePath">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getBasePath
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getConfiguredRule">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getConfiguredRule
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getConfiguredRules">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getConfiguredRules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getErrorFilter">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getErrorFilter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getExcludedFileMasks">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getExcludedFileMasks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getExtractFileMasks">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getExtractFileMasks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getFileExtensions">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getFileExtensions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getFix">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getFix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getMaxErrors">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getMaxErrors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getPresetName">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getPresetName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getProcessedConfig">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getProcessedConfig
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getRegisteredPresets">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getRegisteredPresets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getRegisteredRules">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getRegisteredRules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getUnsupportedRuleNames">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getUnsupportedRuleNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.hasCorrectExtension">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>hasCorrectExtension
            <span class="apidocSignatureSpan">(testPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.hasPreset">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>hasPreset
            <span class="apidocSignatureSpan">(presetName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.isES3Enabled">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>isES3Enabled
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.isFileExcluded">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>isFileExcluded
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.load">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>load
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.override">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>override
            <span class="apidocSignatureSpan">(overrides)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.registerDefaultPresets">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>registerDefaultPresets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.registerDefaultRules">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>registerDefaultRules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.registerPreset">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>registerPreset
            <span class="apidocSignatureSpan">(presetName, presetConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.registerRule">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>registerRule
            <span class="apidocSignatureSpan">(rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.shouldExtractFile">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>shouldExtractFile
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.usePlugin">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>usePlugin
            <span class="apidocSignatureSpan">(plugin)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_anonymous_functions">module jscs.disallow_anonymous_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_anonymous_functions.disallow_anonymous_functions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_anonymous_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_anonymous_functions.prototype">module jscs.disallow_anonymous_functions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_anonymous_functions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_anonymous_functions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_anonymous_functions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_anonymous_functions.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_anonymous_functions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_anonymous_functions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_array_destructuring_return">module jscs.disallow_array_destructuring_return</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_array_destructuring_return.disallow_array_destructuring_return">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_array_destructuring_return
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_array_destructuring_return.prototype">module jscs.disallow_array_destructuring_return.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_array_destructuring_return.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_array_destructuring_return.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_array_destructuring_return.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_array_destructuring_return.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_array_destructuring_return.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_array_destructuring_return.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_arrow_functions">module jscs.disallow_arrow_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_arrow_functions.disallow_arrow_functions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_arrow_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_arrow_functions.prototype">module jscs.disallow_arrow_functions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_arrow_functions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_arrow_functions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_arrow_functions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_arrow_functions.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_arrow_functions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_arrow_functions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_capitalized_comments">module jscs.disallow_capitalized_comments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_capitalized_comments.disallow_capitalized_comments">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_capitalized_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_capitalized_comments.prototype">module jscs.disallow_capitalized_comments.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_capitalized_comments.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_capitalized_comments.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_capitalized_comments.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_capitalized_comments.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_capitalized_comments.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_capitalized_comments.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_comma_before_line_break">module jscs.disallow_comma_before_line_break</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_comma_before_line_break.disallow_comma_before_line_break">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_comma_before_line_break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_comma_before_line_break.prototype">module jscs.disallow_comma_before_line_break.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_comma_before_line_break.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_comma_before_line_break.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_comma_before_line_break.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_comma_before_line_break.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_comma_before_line_break.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_comma_before_line_break.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_curly_braces">module jscs.disallow_curly_braces</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_curly_braces.disallow_curly_braces">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_curly_braces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_curly_braces.prototype">module jscs.disallow_curly_braces.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_curly_braces.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_curly_braces.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_curly_braces.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_curly_braces.prototype.</span>configure
            <span class="apidocSignatureSpan">(statementTypes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_curly_braces.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_curly_braces.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_dangling_underscores">module jscs.disallow_dangling_underscores</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_dangling_underscores.disallow_dangling_underscores">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_dangling_underscores
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_dangling_underscores.prototype">module jscs.disallow_dangling_underscores.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_dangling_underscores.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_dangling_underscores.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_dangling_underscores.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_dangling_underscores.prototype.</span>configure
            <span class="apidocSignatureSpan">(identifiers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_dangling_underscores.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_dangling_underscores.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_empty_blocks">module jscs.disallow_empty_blocks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_empty_blocks.disallow_empty_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_empty_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_empty_blocks.prototype">module jscs.disallow_empty_blocks.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_empty_blocks.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_empty_blocks.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_empty_blocks.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_empty_blocks.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_empty_blocks.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_empty_blocks.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_function_declarations">module jscs.disallow_function_declarations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_function_declarations.disallow_function_declarations">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_function_declarations
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_function_declarations.prototype">module jscs.disallow_function_declarations.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_function_declarations.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_function_declarations.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_function_declarations.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_function_declarations.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_function_declarations.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_function_declarations.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_identical_destructuring_names">module jscs.disallow_identical_destructuring_names</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identical_destructuring_names.disallow_identical_destructuring_names">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_identical_destructuring_names
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_identical_destructuring_names.prototype">module jscs.disallow_identical_destructuring_names.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identical_destructuring_names.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_identical_destructuring_names.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identical_destructuring_names.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_identical_destructuring_names.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identical_destructuring_names.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_identical_destructuring_names.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_identifier_names">module jscs.disallow_identifier_names</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identifier_names.disallow_identifier_names">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_identifier_names
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_identifier_names.prototype">module jscs.disallow_identifier_names.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identifier_names.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_identifier_names.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identifier_names.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_identifier_names.prototype.</span>configure
            <span class="apidocSignatureSpan">(identifiers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identifier_names.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_identifier_names.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_implicit_type_conversion">module jscs.disallow_implicit_type_conversion</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_implicit_type_conversion.disallow_implicit_type_conversion">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_implicit_type_conversion
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_implicit_type_conversion.prototype">module jscs.disallow_implicit_type_conversion.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_implicit_type_conversion.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_implicit_type_conversion.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_implicit_type_conversion.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_implicit_type_conversion.prototype.</span>configure
            <span class="apidocSignatureSpan">(types)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_implicit_type_conversion.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_implicit_type_conversion.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_keywords">module jscs.disallow_keywords</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords.disallow_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_keywords.prototype">module jscs.disallow_keywords.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_keywords_in_comments">module jscs.disallow_keywords_in_comments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_in_comments.disallow_keywords_in_comments">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_in_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_keywords_in_comments.prototype">module jscs.disallow_keywords_in_comments.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_in_comments.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords_in_comments.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_in_comments.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords_in_comments.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_in_comments.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords_in_comments.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_keywords_on_new_line">module jscs.disallow_keywords_on_new_line</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_on_new_line.disallow_keywords_on_new_line">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_on_new_line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_keywords_on_new_line.prototype">module jscs.disallow_keywords_on_new_line.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_on_new_line.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords_on_new_line.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_on_new_line.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords_on_new_line.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_on_new_line.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords_on_new_line.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_mixed_spaces_and_tabs">module jscs.disallow_mixed_spaces_and_tabs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs.disallow_mixed_spaces_and_tabs">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_mixed_spaces_and_tabs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_mixed_spaces_and_tabs.prototype">module jscs.disallow_mixed_spaces_and_tabs.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_mixed_spaces_and_tabs.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_mixed_spaces_and_tabs.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_mixed_spaces_and_tabs.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multi_line_ternary">module jscs.disallow_multi_line_ternary</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multi_line_ternary.disallow_multi_line_ternary">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multi_line_ternary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multi_line_ternary.prototype">module jscs.disallow_multi_line_ternary.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multi_line_ternary.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_multi_line_ternary.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multi_line_ternary.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_multi_line_ternary.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multi_line_ternary.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_multi_line_ternary.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multiple_line_breaks">module jscs.disallow_multiple_line_breaks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_breaks.disallow_multiple_line_breaks">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_breaks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multiple_line_breaks.prototype">module jscs.disallow_multiple_line_breaks.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_breaks.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_breaks.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_breaks.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_breaks.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_breaks.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_breaks.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multiple_line_strings">module jscs.disallow_multiple_line_strings</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_strings.disallow_multiple_line_strings">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_strings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multiple_line_strings.prototype">module jscs.disallow_multiple_line_strings.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_strings.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_strings.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_strings.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_strings.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_strings.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_strings.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multiple_spaces">module jscs.disallow_multiple_spaces</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_spaces.disallow_multiple_spaces">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_spaces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multiple_spaces.prototype">module jscs.disallow_multiple_spaces.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_spaces.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_spaces.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_spaces.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_spaces.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_spaces.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_spaces.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multiple_var_decl">module jscs.disallow_multiple_var_decl</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_var_decl.disallow_multiple_var_decl">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_var_decl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multiple_var_decl.prototype">module jscs.disallow_multiple_var_decl.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_var_decl.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_var_decl.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_var_decl.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_var_decl.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_var_decl.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_var_decl.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_named_unassigned_functions">module jscs.disallow_named_unassigned_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_named_unassigned_functions.disallow_named_unassigned_functions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_named_unassigned_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_named_unassigned_functions.prototype">module jscs.disallow_named_unassigned_functions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_named_unassigned_functions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_named_unassigned_functions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_named_unassigned_functions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_named_unassigned_functions.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_named_unassigned_functions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_named_unassigned_functions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_nested_ternaries">module jscs.disallow_nested_ternaries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_nested_ternaries.disallow_nested_ternaries">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_nested_ternaries
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_nested_ternaries.prototype">module jscs.disallow_nested_ternaries.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_nested_ternaries.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_nested_ternaries.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_nested_ternaries.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_nested_ternaries.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_nested_ternaries.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_nested_ternaries.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_newline_before_block_statements">module jscs.disallow_newline_before_block_statements</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_newline_before_block_statements.disallow_newline_before_block_statements">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_newline_before_block_statements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_newline_before_block_statements.prototype">module jscs.disallow_newline_before_block_statements.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_newline_before_block_statements.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_newline_before_block_statements.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_newline_before_block_statements.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_newline_before_block_statements.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_newline_before_block_statements.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_newline_before_block_statements.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_node_types">module jscs.disallow_node_types</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_node_types.disallow_node_types">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_node_types
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_node_types.prototype">module jscs.disallow_node_types.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_node_types.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_node_types.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_node_types.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_node_types.prototype.</span>configure
            <span class="apidocSignatureSpan">(nodeTypes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_node_types.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_node_types.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_not_operators_in_conditionals">module jscs.disallow_not_operators_in_conditionals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_not_operators_in_conditionals.disallow_not_operators_in_conditionals">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_not_operators_in_conditionals
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_not_operators_in_conditionals.prototype">module jscs.disallow_not_operators_in_conditionals.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_not_operators_in_conditionals.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_not_operators_in_conditionals.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_not_operators_in_conditionals.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_object_keys_on_new_line">module jscs.disallow_object_keys_on_new_line</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_object_keys_on_new_line.disallow_object_keys_on_new_line">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_object_keys_on_new_line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_object_keys_on_new_line.prototype">module jscs.disallow_object_keys_on_new_line.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_object_keys_on_new_line.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_object_keys_on_new_line.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_object_keys_on_new_line.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_operator_before_line_break">module jscs.disallow_operator_before_line_break</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_operator_before_line_break.disallow_operator_before_line_break">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_operator_before_line_break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_operator_before_line_break.prototype">module jscs.disallow_operator_before_line_break.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_operator_before_line_break.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_operator_before_line_break.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_operator_before_line_break.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_operator_before_line_break.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_operator_before_line_break.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_operator_before_line_break.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_after_blocks">module jscs.disallow_padding_newlines_after_blocks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks.disallow_padding_newlines_after_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_after_blocks.prototype">module jscs.disallow_padding_newlines_after_blocks.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_blocks.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_blocks.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_blocks.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_after_use_strict">module jscs.disallow_padding_newlines_after_use_strict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict.disallow_padding_newlines_after_use_strict">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_use_strict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_after_use_strict.prototype">module jscs.disallow_padding_newlines_after_use_strict.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_use_strict.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_use_strict.prototype.</span>configure
            <span class="apidocSignatureSpan">(disallowPaddingNewLinesAfterUseStrict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_use_strict.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_before_export">module jscs.disallow_padding_newlines_before_export</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_export.disallow_padding_newlines_before_export">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_export
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_before_export.prototype">module jscs.disallow_padding_newlines_before_export.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_export.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_export.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_export.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_before_keywords">module jscs.disallow_padding_newlines_before_keywords</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords.disallow_padding_newlines_before_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_before_keywords.prototype">module jscs.disallow_padding_newlines_before_keywords.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_keywords.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_keywords.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_keywords.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_before_line_comments">module jscs.disallow_padding_newlines_before_line_comments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments.disallow_padding_newlines_before_line_comments">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_line_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_before_line_comments.prototype">module jscs.disallow_padding_newlines_before_line_comments.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_line_comments.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_line_comments.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_line_comments.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_in_blocks">module jscs.disallow_padding_newlines_in_blocks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks.disallow_padding_newlines_in_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_in_blocks.prototype">module jscs.disallow_padding_newlines_in_blocks.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_blocks.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_blocks.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_blocks.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_in_objects">module jscs.disallow_padding_newlines_in_objects</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_objects.disallow_padding_newlines_in_objects">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_objects
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_in_objects.prototype">module jscs.disallow_padding_newlines_in_objects.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_objects.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_objects.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_objects.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_parentheses_around_arrow_param">module jscs.disallow_parentheses_around_arrow_param</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param.disallow_parentheses_around_arrow_param">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_parentheses_around_arrow_param
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_parentheses_around_arrow_param.prototype">module jscs.disallow_parentheses_around_arrow_param.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_parentheses_around_arrow_param.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_parentheses_around_arrow_param.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_parentheses_around_arrow_param.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_quoted_keys_in_objects">module jscs.disallow_quoted_keys_in_objects</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.disallow_quoted_keys_in_objects">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_quoted_keys_in_objects
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_quoted_keys_in_objects.prototype">module jscs.disallow_quoted_keys_in_objects.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.disallow_quoted_keys_in_objects.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_quoted_keys_in_objects.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_quoted_keys_in_objects.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_quoted_keys_in_objects.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_semicolons">module jscs.disallow_semicolons</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_semicolons.disallow_semicolons">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_semicolons
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_semicolons.prototype">module jscs.disallow_semicolons.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_semicolons.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.disallow_semicolons.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_semicolons.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_semicolons.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_semicolons.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_semicolons.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_semicolons.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_semicolons.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_shorthand_arrow_functions">module jscs.disallow_shorthand_arrow_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_shorthand_arrow_functions.disallow_shorthand_arrow_functions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_shorthand_arrow_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_shorthand_arrow_functions.prototype">module jscs.disallow_shorthand_arrow_functions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_shorthand_arrow_functions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_shorthand_arrow_functions.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_shorthand_arrow_functions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_binary_operators">module jscs.disallow_space_after_binary_operators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_binary_operators.disallow_space_after_binary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_binary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_binary_operators.prototype">module jscs.disallow_space_after_binary_operators.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_binary_operators.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_binary_operators.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_binary_operators.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_binary_operators.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_binary_operators.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_binary_operators.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_comma">module jscs.disallow_space_after_comma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_comma.disallow_space_after_comma">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_comma.prototype">module jscs.disallow_space_after_comma.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_comma.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_comma.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_comma.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_comma.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_comma.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_comma.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_keywords">module jscs.disallow_space_after_keywords</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_keywords.disallow_space_after_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_keywords.prototype">module jscs.disallow_space_after_keywords.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_keywords.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_keywords.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_keywords.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_keywords.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_keywords.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_keywords.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_line_comment">module jscs.disallow_space_after_line_comment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_line_comment.disallow_space_after_line_comment">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_line_comment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_line_comment.prototype">module jscs.disallow_space_after_line_comment.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_line_comment.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_line_comment.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_line_comment.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_line_comment.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_line_comment.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_line_comment.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_object_keys">module jscs.disallow_space_after_object_keys</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_object_keys.disallow_space_after_object_keys">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_object_keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_object_keys.prototype">module jscs.disallow_space_after_object_keys.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_object_keys.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_object_keys.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_object_keys.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_object_keys.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_object_keys.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_object_keys.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_prefix_unary_operators">module jscs.disallow_space_after_prefix_unary_operators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators.disallow_space_after_prefix_unary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_prefix_unary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_prefix_unary_operators.prototype">module jscs.disallow_space_after_prefix_unary_operators.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_prefix_unary_operators.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_prefix_unary_operators.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_prefix_unary_operators.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_binary_operators">module jscs.disallow_space_before_binary_operators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_binary_operators.disallow_space_before_binary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_binary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_binary_operators.prototype">module jscs.disallow_space_before_binary_operators.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_binary_operators.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_binary_operators.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_binary_operators.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_binary_operators.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_binary_operators.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_binary_operators.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_block_statements">module jscs.disallow_space_before_block_statements</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_block_statements.disallow_space_before_block_statements">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_block_statements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_block_statements.prototype">module jscs.disallow_space_before_block_statements.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_block_statements.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_block_statements.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_block_statements.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_block_statements.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_block_statements.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_block_statements.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_comma">module jscs.disallow_space_before_comma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_comma.disallow_space_before_comma">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_comma.prototype">module jscs.disallow_space_before_comma.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_comma.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_comma.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_comma.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_comma.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_comma.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_comma.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_keywords">module jscs.disallow_space_before_keywords</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_keywords.disallow_space_before_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_keywords.prototype">module jscs.disallow_space_before_keywords.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_keywords.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_keywords.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_keywords.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_keywords.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_keywords.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_keywords.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_object_values">module jscs.disallow_space_before_object_values</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_object_values.disallow_space_before_object_values">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_object_values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_object_values.prototype">module jscs.disallow_space_before_object_values.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_object_values.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_object_values.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_object_values.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_object_values.prototype.</span>configure
            <span class="apidocSignatureSpan">(disallow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_object_values.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_object_values.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_postfix_unary_operators">module jscs.disallow_space_before_postfix_unary_operators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators.disallow_space_before_postfix_unary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_postfix_unary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_postfix_unary_operators.prototype">module jscs.disallow_space_before_postfix_unary_operators.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_postfix_unary_operators.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_postfix_unary_operators.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_postfix_unary_operators.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_semicolon">module jscs.disallow_space_before_semicolon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_semicolon.disallow_space_before_semicolon">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_semicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_semicolon.prototype">module jscs.disallow_space_before_semicolon.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_semicolon.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_semicolon.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_semicolon.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_semicolon.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_semicolon.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_semicolon.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_between_arguments">module jscs.disallow_space_between_arguments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_between_arguments.disallow_space_between_arguments">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_between_arguments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_between_arguments.prototype">module jscs.disallow_space_between_arguments.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_between_arguments.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_between_arguments.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_between_arguments.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_between_arguments.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_between_arguments.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_between_arguments.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_anonymous_function_expression">module jscs.disallow_spaces_in_anonymous_function_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.disallow_spaces_in_anonymous_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_anonymous_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_anonymous_function_expression.prototype">module jscs.disallow_spaces_in_anonymous_function_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_anonymous_function_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_anonymous_function_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_anonymous_function_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_call_expression">module jscs.disallow_spaces_in_call_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_call_expression.disallow_spaces_in_call_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_call_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_call_expression.prototype">module jscs.disallow_spaces_in_call_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_call_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_call_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_call_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_conditional_expression">module jscs.disallow_spaces_in_conditional_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression.disallow_spaces_in_conditional_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_conditional_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_conditional_expression.prototype">module jscs.disallow_spaces_in_conditional_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_conditional_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_conditional_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_conditional_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_for_statement">module jscs.disallow_spaces_in_for_statement</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_for_statement.disallow_spaces_in_for_statement">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_for_statement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_for_statement.prototype">module jscs.disallow_spaces_in_for_statement.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_for_statement.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_for_statement.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_for_statement.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_function">module jscs.disallow_spaces_in_function</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function.disallow_spaces_in_function">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_function.prototype">module jscs.disallow_spaces_in_function.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_function_declaration">module jscs.disallow_spaces_in_function_declaration</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_declaration.disallow_spaces_in_function_declaration">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_declaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_function_declaration.prototype">module jscs.disallow_spaces_in_function_declaration.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_declaration.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_declaration.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_declaration.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_function_expression">module jscs.disallow_spaces_in_function_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_expression.disallow_spaces_in_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_function_expression.prototype">module jscs.disallow_spaces_in_function_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_generator">module jscs.disallow_spaces_in_generator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_generator.disallow_spaces_in_generator">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_generator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_generator.prototype">module jscs.disallow_spaces_in_generator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_generator.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_generator.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_generator.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_generator.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_generator.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_generator.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_named_function_expression">module jscs.disallow_spaces_in_named_function_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression.disallow_spaces_in_named_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_named_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_named_function_expression.prototype">module jscs.disallow_spaces_in_named_function_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_named_function_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_named_function_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_named_function_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_array_brackets">module jscs.disallow_spaces_inside_array_brackets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets.disallow_spaces_inside_array_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_array_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_array_brackets.prototype">module jscs.disallow_spaces_inside_array_brackets.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_array_brackets.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_array_brackets.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_array_brackets.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_brackets">module jscs.disallow_spaces_inside_brackets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_brackets.disallow_spaces_inside_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_brackets.prototype">module jscs.disallow_spaces_inside_brackets.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_brackets.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_brackets.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_brackets.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_imported_object_braces">module jscs.disallow_spaces_inside_imported_object_braces</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.disallow_spaces_inside_imported_object_braces">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_imported_object_braces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_imported_object_braces.prototype">module jscs.disallow_spaces_inside_imported_object_braces.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_imported_object_braces.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_imported_object_braces.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_imported_object_braces.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_object_brackets">module jscs.disallow_spaces_inside_object_brackets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets.disallow_spaces_inside_object_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_object_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_object_brackets.prototype">module jscs.disallow_spaces_inside_object_brackets.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_object_brackets.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_object_brackets.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_object_brackets.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_parentheses">module jscs.disallow_spaces_inside_parentheses</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parentheses.disallow_spaces_inside_parentheses">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parentheses
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_parentheses.prototype">module jscs.disallow_spaces_inside_parentheses.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parentheses.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parentheses.prototype.</span>configure
            <span class="apidocSignatureSpan">(option)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parentheses.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_parenthesized_expression">module jscs.disallow_spaces_inside_parenthesized_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.disallow_spaces_inside_parenthesized_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parenthesized_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_parenthesized_expression.prototype">module jscs.disallow_spaces_inside_parenthesized_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parenthesized_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parenthesized_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parenthesized_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_template_string_placeholders">module jscs.disallow_spaces_inside_template_string_placeholders</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.disallow_spaces_inside_template_string_placeholders">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_template_string_placeholders
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_template_string_placeholders.prototype">module jscs.disallow_spaces_inside_template_string_placeholders.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_template_string_placeholders.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_template_string_placeholders.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_template_string_placeholders.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_tabs">module jscs.disallow_tabs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_tabs.disallow_tabs">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_tabs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_tabs.prototype">module jscs.disallow_tabs.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_tabs.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_tabs.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_tabs.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_tabs.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_tabs.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_tabs.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_trailing_comma">module jscs.disallow_trailing_comma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_comma.disallow_trailing_comma">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_trailing_comma.prototype">module jscs.disallow_trailing_comma.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_comma.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.disallow_trailing_comma.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_comma.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_trailing_comma.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_comma.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_trailing_comma.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_comma.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_trailing_comma.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_trailing_whitespace">module jscs.disallow_trailing_whitespace</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_whitespace.disallow_trailing_whitespace">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_whitespace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_trailing_whitespace.prototype">module jscs.disallow_trailing_whitespace.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_whitespace.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.disallow_trailing_whitespace.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_whitespace.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_trailing_whitespace.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_whitespace.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_trailing_whitespace.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_whitespace.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_trailing_whitespace.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_unused_params">module jscs.disallow_unused_params</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_params.disallow_unused_params">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_unused_params
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_unused_params.prototype">module jscs.disallow_unused_params.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_params.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.disallow_unused_params.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_params.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_unused_params.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_params.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_unused_params.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_params.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_unused_params.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_unused_variables">module jscs.disallow_unused_variables</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_variables.disallow_unused_variables">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_unused_variables
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_unused_variables.prototype">module jscs.disallow_unused_variables.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_variables.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.disallow_unused_variables.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_variables.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_unused_variables.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_variables.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_unused_variables.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_variables.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_unused_variables.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_var">module jscs.disallow_var</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_var.disallow_var">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_var
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_var.prototype">module jscs.disallow_var.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_var.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_var.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_var.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_var.prototype.</span>configure
            <span class="apidocSignatureSpan">(option)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_var.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_var.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_yoda_conditions">module jscs.disallow_yoda_conditions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_yoda_conditions.disallow_yoda_conditions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_yoda_conditions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_yoda_conditions.prototype">module jscs.disallow_yoda_conditions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_yoda_conditions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_yoda_conditions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_yoda_conditions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_yoda_conditions.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_yoda_conditions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_yoda_conditions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.errors">module jscs.errors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.errors">
            function <span class="apidocSignatureSpan">jscs.</span>errors
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.getPosition">
            function <span class="apidocSignatureSpan">jscs.errors.</span>getPosition
            <span class="apidocSignatureSpan">(error, tokenIndex)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.errors.prototype">module jscs.errors.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype._addError">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>_addError
            <span class="apidocSignatureSpan">(errorInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype._addParseError">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>_addParseError
            <span class="apidocSignatureSpan">(errorInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype._prepareMessage">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>_prepareMessage
            <span class="apidocSignatureSpan">(errorInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.add">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>add
            <span class="apidocSignatureSpan">(message, element, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.calculateErrorLocations">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>calculateErrorLocations
            <span class="apidocSignatureSpan">(tokenIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.cast">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>cast
            <span class="apidocSignatureSpan">(errorInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.explainError">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>explainError
            <span class="apidocSignatureSpan">(error, colorize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.filter">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>filter
            <span class="apidocSignatureSpan">(filter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.getErrorCount">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>getErrorCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.getErrorList">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>getErrorList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.getFilename">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>getFilename
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.getValidationErrorCount">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>getValidationErrorCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.isEmpty">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.setCurrentRule">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>setCurrentRule
            <span class="apidocSignatureSpan">(rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.stripErrorList">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>stripErrorList
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.generator">module jscs.generator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.generator">
            function <span class="apidocSignatureSpan">jscs.</span>generator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.generator.prototype">module jscs.generator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.prototype._checkAgainstPreset">
            function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_checkAgainstPreset
            <span class="apidocSignatureSpan">(path, presetName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.prototype._generateStatsForPresets">
            function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_generateStatsForPresets
            <span class="apidocSignatureSpan">(resultsPerPreset, presetNames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.prototype._getUserPresetChoice">
            function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_getUserPresetChoice
            <span class="apidocSignatureSpan">(prompt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.prototype._getUserViolationChoices">
            function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_getUserViolationChoices
            <span class="apidocSignatureSpan">(errorPrompts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.prototype._handleViolatedRules">
            function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_handleViolatedRules
            <span class="apidocSignatureSpan">(errorPrompts, choices)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.prototype._showErrorCounts">
            function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_showErrorCounts
            <span class="apidocSignatureSpan">(statsForPresets)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.prototype._showPrompt">
            function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_showPrompt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.prototype.generate">
            function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>generate
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.js_file">module jscs.js_file</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.js_file">
            function <span class="apidocSignatureSpan">jscs.</span>js_file
            <span class="apidocSignatureSpan">(params)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.js_file.prototype">module jscs.js_file.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype._setTokenBefore">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>_setTokenBefore
            <span class="apidocSignatureSpan">(token, fragment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.findNextOperatorToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>findNextOperatorToken
            <span class="apidocSignatureSpan">(token, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.findNextToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>findNextToken
            <span class="apidocSignatureSpan">(token, type, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.findPrevOperatorToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>findPrevOperatorToken
            <span class="apidocSignatureSpan">(token, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.findPrevToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>findPrevToken
            <span class="apidocSignatureSpan">(token, type, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getComments">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getComments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getDialect">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getDialect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getDistanceBetween">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getDistanceBetween
            <span class="apidocSignatureSpan">(tokenBefore, tokenAfter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getFilename">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getFilename
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getFirstNodeToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getFirstNodeToken
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getFirstToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getFirstToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getFirstTokenOnLineWith">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getFirstTokenOnLineWith
            <span class="apidocSignatureSpan">(element, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getLastNodeToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLastNodeToken
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getLastToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLastToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getLastTokenOnLine">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLastTokenOnLine
            <span class="apidocSignatureSpan">(lineNumber, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getLineBreakStyle">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLineBreakStyle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getLineBreaks">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLineBreaks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getLineCountBetween">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLineCountBetween
            <span class="apidocSignatureSpan">(tokenBefore, tokenAfter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getLines">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLines
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getLinesWithCommentsRemoved">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLinesWithCommentsRemoved
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getNextToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getNextToken
            <span class="apidocSignatureSpan">(token, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getNodesByType">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getNodesByType
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getParseErrors">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getParseErrors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getPrevToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getPrevToken
            <span class="apidocSignatureSpan">(token, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getProgram">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getProgram
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getScopes">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getScopes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getSource">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getTree">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getTree
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getWhitespaceBefore">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getWhitespaceBefore
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.isOnTheSameLine">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>isOnTheSameLine
            <span class="apidocSignatureSpan">(tokenBefore, tokenAfter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.iterate">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>iterate
            <span class="apidocSignatureSpan">(cb, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.iterateNodesByType">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>iterateNodesByType
            <span class="apidocSignatureSpan">(type, cb, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.iterateTokensByType">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>iterateTokensByType
            <span class="apidocSignatureSpan">(type, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.iterateTokensByTypeAndValue">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>iterateTokensByTypeAndValue
            <span class="apidocSignatureSpan">(type, value, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.render">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>render
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.setWhitespaceBefore">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>setWhitespaceBefore
            <span class="apidocSignatureSpan">(token, whitespace)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.jsdoc">module jscs.jsdoc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.jsdoc.jsdoc">
            function <span class="apidocSignatureSpan">jscs.</span>jsdoc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.jsdoc.prototype">module jscs.jsdoc.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.jsdoc.prototype._getReturnStatementsForNode">
            function <span class="apidocSignatureSpan">jscs.jsdoc.prototype.</span>_getReturnStatementsForNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.jsdoc.prototype.check">
            function <span class="apidocSignatureSpan">jscs.jsdoc.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.jsdoc.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.jsdoc.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.jsdoc.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.jsdoc.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.maximum_line_length">module jscs.maximum_line_length</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_line_length.maximum_line_length">
            function <span class="apidocSignatureSpan">jscs.</span>maximum_line_length
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.maximum_line_length.prototype">module jscs.maximum_line_length.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_line_length.prototype.check">
            function <span class="apidocSignatureSpan">jscs.maximum_line_length.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_line_length.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.maximum_line_length.prototype.</span>configure
            <span class="apidocSignatureSpan">(maximumLineLength)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_line_length.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.maximum_line_length.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.maximum_number_of_lines">module jscs.maximum_number_of_lines</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_number_of_lines.maximum_number_of_lines">
            function <span class="apidocSignatureSpan">jscs.</span>maximum_number_of_lines
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.maximum_number_of_lines.prototype">module jscs.maximum_number_of_lines.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_number_of_lines.prototype.check">
            function <span class="apidocSignatureSpan">jscs.maximum_number_of_lines.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_number_of_lines.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.maximum_number_of_lines.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_number_of_lines.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.maximum_number_of_lines.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.node_configuration">module jscs.node_configuration</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration.node_configuration">
            function <span class="apidocSignatureSpan">jscs.</span>node_configuration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration.super_">
            function <span class="apidocSignatureSpan">jscs.node_configuration.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.node_configuration.prototype">module jscs.node_configuration.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration.prototype._loadAdditionalRule">
            function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>_loadAdditionalRule
            <span class="apidocSignatureSpan">(additionalRule, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration.prototype._loadErrorFilter">
            function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>_loadErrorFilter
            <span class="apidocSignatureSpan">(filter, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration.prototype._loadPlugin">
            function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>_loadPlugin
            <span class="apidocSignatureSpan">(plugin, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration.prototype._loadPreset">
            function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>_loadPreset
            <span class="apidocSignatureSpan">(preset, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration.prototype.loadExternal">
            function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>loadExternal
            <span class="apidocSignatureSpan">(external, type, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration.prototype.overrideFromCLI">
            function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>overrideFromCLI
            <span class="apidocSignatureSpan">(program)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_aligned_multiline_params">module jscs.require_aligned_multiline_params</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_multiline_params.require_aligned_multiline_params">
            function <span class="apidocSignatureSpan">jscs.</span>require_aligned_multiline_params
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_aligned_multiline_params.prototype">module jscs.require_aligned_multiline_params.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_multiline_params.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_aligned_multiline_params.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_multiline_params.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_aligned_multiline_params.prototype.</span>configure
            <span class="apidocSignatureSpan">(option)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_multiline_params.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_aligned_multiline_params.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_aligned_object_values">module jscs.require_aligned_object_values</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_object_values.require_aligned_object_values">
            function <span class="apidocSignatureSpan">jscs.</span>require_aligned_object_values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_aligned_object_values.prototype">module jscs.require_aligned_object_values.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_object_values.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_aligned_object_values.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_object_values.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_aligned_object_values.prototype.</span>configure
            <span class="apidocSignatureSpan">(mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_object_values.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_aligned_object_values.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_anonymous_functions">module jscs.require_anonymous_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_anonymous_functions.require_anonymous_functions">
            function <span class="apidocSignatureSpan">jscs.</span>require_anonymous_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_anonymous_functions.prototype">module jscs.require_anonymous_functions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_anonymous_functions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_anonymous_functions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_anonymous_functions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_anonymous_functions.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_anonymous_functions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_anonymous_functions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_array_destructuring">module jscs.require_array_destructuring</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_array_destructuring.require_array_destructuring">
            function <span class="apidocSignatureSpan">jscs.</span>require_array_destructuring
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_array_destructuring.prototype">module jscs.require_array_destructuring.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_array_destructuring.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_array_destructuring.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_array_destructuring.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_array_destructuring.prototype.</span>configure
            <span class="apidocSignatureSpan">(option)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_array_destructuring.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_array_destructuring.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_arrow_functions">module jscs.require_arrow_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_arrow_functions.require_arrow_functions">
            function <span class="apidocSignatureSpan">jscs.</span>require_arrow_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_arrow_functions.prototype">module jscs.require_arrow_functions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_arrow_functions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_arrow_functions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_arrow_functions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_arrow_functions.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_arrow_functions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_arrow_functions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_blocks_on_newline">module jscs.require_blocks_on_newline</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_blocks_on_newline.require_blocks_on_newline">
            function <span class="apidocSignatureSpan">jscs.</span>require_blocks_on_newline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_blocks_on_newline.prototype">module jscs.require_blocks_on_newline.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_blocks_on_newline.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_blocks_on_newline.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_blocks_on_newline.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_blocks_on_newline.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_blocks_on_newline.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_blocks_on_newline.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_camelcase_or_uppercase_identifiers">module jscs.require_camelcase_or_uppercase_identifiers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.require_camelcase_or_uppercase_identifiers">
            function <span class="apidocSignatureSpan">jscs.</span>require_camelcase_or_uppercase_identifiers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_camelcase_or_uppercase_identifiers.prototype">module jscs.require_camelcase_or_uppercase_identifiers.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_camelcase_or_uppercase_identifiers.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_camelcase_or_uppercase_identifiers.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_camelcase_or_uppercase_identifiers.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_capitalized_comments">module jscs.require_capitalized_comments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.require_capitalized_comments">
            function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_capitalized_comments.prototype">module jscs.require_capitalized_comments.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype._getFirstChar">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_getFirstChar
            <span class="apidocSignatureSpan">(comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype._isException">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isException
            <span class="apidocSignatureSpan">(comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype._isLetter">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isLetter
            <span class="apidocSignatureSpan">(comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype._isTextBlock">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isTextBlock
            <span class="apidocSignatureSpan">(file, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype._isUrl">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isUrl
            <span class="apidocSignatureSpan">(comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype._isValid">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isValid
            <span class="apidocSignatureSpan">(comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype._shouldIgnoreIfInTheMiddle">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_shouldIgnoreIfInTheMiddle
            <span class="apidocSignatureSpan">(file, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_capitalized_constructors">module jscs.require_capitalized_constructors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors.require_capitalized_constructors">
            function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_capitalized_constructors.prototype">module jscs.require_capitalized_constructors.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_capitalized_constructors_new">module jscs.require_capitalized_constructors_new</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors_new.require_capitalized_constructors_new">
            function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors_new
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_capitalized_constructors_new.prototype">module jscs.require_capitalized_constructors_new.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors_new.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors_new.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors_new.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors_new.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors_new.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors_new.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_comma_before_line_break">module jscs.require_comma_before_line_break</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_comma_before_line_break.require_comma_before_line_break">
            function <span class="apidocSignatureSpan">jscs.</span>require_comma_before_line_break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_comma_before_line_break.prototype">module jscs.require_comma_before_line_break.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_comma_before_line_break.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_comma_before_line_break.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_comma_before_line_break.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_comma_before_line_break.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_comma_before_line_break.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_comma_before_line_break.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_curly_braces">module jscs.require_curly_braces</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_curly_braces.require_curly_braces">
            function <span class="apidocSignatureSpan">jscs.</span>require_curly_braces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_curly_braces.prototype">module jscs.require_curly_braces.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_curly_braces.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_curly_braces.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_curly_braces.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_curly_braces.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_curly_braces.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_curly_braces.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_dollar_before_jquery_assignment">module jscs.require_dollar_before_jquery_assignment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dollar_before_jquery_assignment.require_dollar_before_jquery_assignment">
            function <span class="apidocSignatureSpan">jscs.</span>require_dollar_before_jquery_assignment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_dollar_before_jquery_assignment.prototype">module jscs.require_dollar_before_jquery_assignment.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">jscs.require_dollar_before_jquery_assignment.prototype.</span>_ignoreProperties</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_dollar_before_jquery_assignment.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_dollar_before_jquery_assignment.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_dollar_before_jquery_assignment.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_dot_notation">module jscs.require_dot_notation</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dot_notation.require_dot_notation">
            function <span class="apidocSignatureSpan">jscs.</span>require_dot_notation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_dot_notation.prototype">module jscs.require_dot_notation.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dot_notation.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_dot_notation.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dot_notation.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_dot_notation.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dot_notation.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_dot_notation.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_early_return">module jscs.require_early_return</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_early_return.require_early_return">
            function <span class="apidocSignatureSpan">jscs.</span>require_early_return
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_early_return.prototype">module jscs.require_early_return.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_early_return.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_early_return.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_early_return.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_early_return.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_early_return.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_early_return.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_enhanced_object_literals">module jscs.require_enhanced_object_literals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_enhanced_object_literals.require_enhanced_object_literals">
            function <span class="apidocSignatureSpan">jscs.</span>require_enhanced_object_literals
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_enhanced_object_literals.prototype">module jscs.require_enhanced_object_literals.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_enhanced_object_literals.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.require_enhanced_object_literals.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_enhanced_object_literals.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_enhanced_object_literals.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_enhanced_object_literals.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_enhanced_object_literals.prototype.</span>configure
            <span class="apidocSignatureSpan">(option)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_enhanced_object_literals.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_enhanced_object_literals.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_function_declarations">module jscs.require_function_declarations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_function_declarations.require_function_declarations">
            function <span class="apidocSignatureSpan">jscs.</span>require_function_declarations
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_function_declarations.prototype">module jscs.require_function_declarations.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_function_declarations.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_function_declarations.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_function_declarations.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_function_declarations.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_function_declarations.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_function_declarations.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_imports_alphabetized">module jscs.require_imports_alphabetized</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_imports_alphabetized.require_imports_alphabetized">
            function <span class="apidocSignatureSpan">jscs.</span>require_imports_alphabetized
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_imports_alphabetized.prototype">module jscs.require_imports_alphabetized.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_imports_alphabetized.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_imports_alphabetized.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_imports_alphabetized.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_imports_alphabetized.prototype.</span>configure
            <span class="apidocSignatureSpan">(option)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_imports_alphabetized.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_imports_alphabetized.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_keywords_on_new_line">module jscs.require_keywords_on_new_line</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_keywords_on_new_line.require_keywords_on_new_line">
            function <span class="apidocSignatureSpan">jscs.</span>require_keywords_on_new_line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_keywords_on_new_line.prototype">module jscs.require_keywords_on_new_line.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_keywords_on_new_line.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_keywords_on_new_line.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_keywords_on_new_line.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_keywords_on_new_line.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_keywords_on_new_line.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_keywords_on_new_line.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_line_break_after_variable_assignment">module jscs.require_line_break_after_variable_assignment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_break_after_variable_assignment.require_line_break_after_variable_assignment">
            function <span class="apidocSignatureSpan">jscs.</span>require_line_break_after_variable_assignment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_line_break_after_variable_assignment.prototype">module jscs.require_line_break_after_variable_assignment.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_line_break_after_variable_assignment.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_line_break_after_variable_assignment.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_line_break_after_variable_assignment.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_line_feed_at_file_end">module jscs.require_line_feed_at_file_end</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_feed_at_file_end.require_line_feed_at_file_end">
            function <span class="apidocSignatureSpan">jscs.</span>require_line_feed_at_file_end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_line_feed_at_file_end.prototype">module jscs.require_line_feed_at_file_end.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_feed_at_file_end.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_line_feed_at_file_end.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_feed_at_file_end.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_line_feed_at_file_end.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_feed_at_file_end.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_line_feed_at_file_end.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_matching_function_name">module jscs.require_matching_function_name</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_matching_function_name.require_matching_function_name">
            function <span class="apidocSignatureSpan">jscs.</span>require_matching_function_name
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_matching_function_name.prototype">module jscs.require_matching_function_name.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_matching_function_name.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_matching_function_name.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_matching_function_name.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_matching_function_name.prototype.</span>configure
            <span class="apidocSignatureSpan">(requireMatchingFunctionName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_matching_function_name.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_matching_function_name.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_multi_line_ternary">module jscs.require_multi_line_ternary</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multi_line_ternary.require_multi_line_ternary">
            function <span class="apidocSignatureSpan">jscs.</span>require_multi_line_ternary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_multi_line_ternary.prototype">module jscs.require_multi_line_ternary.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multi_line_ternary.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_multi_line_ternary.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multi_line_ternary.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_multi_line_ternary.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multi_line_ternary.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_multi_line_ternary.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_multiple_var_decl">module jscs.require_multiple_var_decl</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multiple_var_decl.require_multiple_var_decl">
            function <span class="apidocSignatureSpan">jscs.</span>require_multiple_var_decl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_multiple_var_decl.prototype">module jscs.require_multiple_var_decl.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multiple_var_decl.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_multiple_var_decl.prototype.</span>check
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multiple_var_decl.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_multiple_var_decl.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multiple_var_decl.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_multiple_var_decl.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_named_unassigned_functions">module jscs.require_named_unassigned_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_named_unassigned_functions.require_named_unassigned_functions">
            function <span class="apidocSignatureSpan">jscs.</span>require_named_unassigned_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_named_unassigned_functions.prototype">module jscs.require_named_unassigned_functions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_named_unassigned_functions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_named_unassigned_functions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_named_unassigned_functions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_named_unassigned_functions.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_named_unassigned_functions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_named_unassigned_functions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_newline_before_block_statements">module jscs.require_newline_before_block_statements</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_block_statements.require_newline_before_block_statements">
            function <span class="apidocSignatureSpan">jscs.</span>require_newline_before_block_statements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_newline_before_block_statements.prototype">module jscs.require_newline_before_block_statements.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_block_statements.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_newline_before_block_statements.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_block_statements.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_newline_before_block_statements.prototype.</span>configure
            <span class="apidocSignatureSpan">(settingValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_block_statements.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_newline_before_block_statements.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_newline_before_single_statements_in_if">module jscs.require_newline_before_single_statements_in_if</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_single_statements_in_if.require_newline_before_single_statements_in_if">
            function <span class="apidocSignatureSpan">jscs.</span>require_newline_before_single_statements_in_if
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_newline_before_single_statements_in_if.prototype">module jscs.require_newline_before_single_statements_in_if.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_newline_before_single_statements_in_if.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_newline_before_single_statements_in_if.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_newline_before_single_statements_in_if.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_numeric_literals">module jscs.require_numeric_literals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_numeric_literals.require_numeric_literals">
            function <span class="apidocSignatureSpan">jscs.</span>require_numeric_literals
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_numeric_literals.prototype">module jscs.require_numeric_literals.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_numeric_literals.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_numeric_literals.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_numeric_literals.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_numeric_literals.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_numeric_literals.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_numeric_literals.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_object_destructuring">module jscs.require_object_destructuring</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_destructuring.require_object_destructuring">
            function <span class="apidocSignatureSpan">jscs.</span>require_object_destructuring
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_object_destructuring.prototype">module jscs.require_object_destructuring.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_destructuring.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_object_destructuring.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_destructuring.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_object_destructuring.prototype.</span>configure
            <span class="apidocSignatureSpan">(option)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_destructuring.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_object_destructuring.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_object_keys_on_new_line">module jscs.require_object_keys_on_new_line</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_keys_on_new_line.require_object_keys_on_new_line">
            function <span class="apidocSignatureSpan">jscs.</span>require_object_keys_on_new_line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_object_keys_on_new_line.prototype">module jscs.require_object_keys_on_new_line.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_keys_on_new_line.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_object_keys_on_new_line.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_keys_on_new_line.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_object_keys_on_new_line.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_keys_on_new_line.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_object_keys_on_new_line.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_operator_before_line_break">module jscs.require_operator_before_line_break</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_operator_before_line_break.require_operator_before_line_break">
            function <span class="apidocSignatureSpan">jscs.</span>require_operator_before_line_break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_operator_before_line_break.prototype">module jscs.require_operator_before_line_break.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_operator_before_line_break.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_operator_before_line_break.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_operator_before_line_break.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_operator_before_line_break.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_operator_before_line_break.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_operator_before_line_break.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newline_after_variable_declaration">module jscs.require_padding_newline_after_variable_declaration</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration.require_padding_newline_after_variable_declaration">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newline_after_variable_declaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newline_after_variable_declaration.prototype">module jscs.require_padding_newline_after_variable_declaration.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_padding_newline_after_variable_declaration.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_padding_newline_after_variable_declaration.prototype.</span>configure
            <span class="apidocSignatureSpan">(requirePaddingNewLineAfterVariableDeclaration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_padding_newline_after_variable_declaration.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_after_blocks">module jscs.require_padding_newlines_after_blocks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_blocks.require_padding_newlines_after_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_after_blocks.prototype">module jscs.require_padding_newlines_after_blocks.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_blocks.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_blocks.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_blocks.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_after_use_strict">module jscs.require_padding_newlines_after_use_strict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_use_strict.require_padding_newlines_after_use_strict">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_use_strict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_after_use_strict.prototype">module jscs.require_padding_newlines_after_use_strict.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_use_strict.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_use_strict.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_use_strict.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_before_export">module jscs.require_padding_newlines_before_export</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_export.require_padding_newlines_before_export">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_export
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_before_export.prototype">module jscs.require_padding_newlines_before_export.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_export.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_export.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_export.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_export.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_export.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_export.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_before_keywords">module jscs.require_padding_newlines_before_keywords</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_keywords.require_padding_newlines_before_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_before_keywords.prototype">module jscs.require_padding_newlines_before_keywords.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_keywords.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_keywords.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_keywords.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_before_line_comments">module jscs.require_padding_newlines_before_line_comments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_line_comments.require_padding_newlines_before_line_comments">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_line_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_before_line_comments.prototype">module jscs.require_padding_newlines_before_line_comments.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_line_comments.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_line_comments.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_line_comments.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_in_blocks">module jscs.require_padding_newlines_in_blocks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_blocks.require_padding_newlines_in_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_in_blocks.prototype">module jscs.require_padding_newlines_in_blocks.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_blocks.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_blocks.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_blocks.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_in_objects">module jscs.require_padding_newlines_in_objects</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_objects.require_padding_newlines_in_objects">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_objects
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_in_objects.prototype">module jscs.require_padding_newlines_in_objects.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_objects.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_objects.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_objects.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_objects.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_objects.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_objects.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_parentheses_around_arrow_param">module jscs.require_parentheses_around_arrow_param</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_arrow_param.require_parentheses_around_arrow_param">
            function <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_arrow_param
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_parentheses_around_arrow_param.prototype">module jscs.require_parentheses_around_arrow_param.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_parentheses_around_arrow_param.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_parentheses_around_arrow_param.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_parentheses_around_arrow_param.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_parentheses_around_iife">module jscs.require_parentheses_around_iife</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_iife.require_parentheses_around_iife">
            function <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_iife
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_parentheses_around_iife.prototype">module jscs.require_parentheses_around_iife.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_iife.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_parentheses_around_iife.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_iife.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_parentheses_around_iife.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_iife.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_parentheses_around_iife.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_quoted_keys_in_objects">module jscs.require_quoted_keys_in_objects</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_quoted_keys_in_objects.require_quoted_keys_in_objects">
            function <span class="apidocSignatureSpan">jscs.</span>require_quoted_keys_in_objects
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_quoted_keys_in_objects.prototype">module jscs.require_quoted_keys_in_objects.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_quoted_keys_in_objects.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.require_quoted_keys_in_objects.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_quoted_keys_in_objects.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_quoted_keys_in_objects.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_quoted_keys_in_objects.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_quoted_keys_in_objects.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_quoted_keys_in_objects.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_quoted_keys_in_objects.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_semicolons">module jscs.require_semicolons</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_semicolons.require_semicolons">
            function <span class="apidocSignatureSpan">jscs.</span>require_semicolons
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_semicolons.prototype">module jscs.require_semicolons.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_semicolons.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.require_semicolons.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_semicolons.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_semicolons.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_semicolons.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_semicolons.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_semicolons.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_semicolons.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_shorthand_arrow_functions">module jscs.require_shorthand_arrow_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_shorthand_arrow_functions.require_shorthand_arrow_functions">
            function <span class="apidocSignatureSpan">jscs.</span>require_shorthand_arrow_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_shorthand_arrow_functions.prototype">module jscs.require_shorthand_arrow_functions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_shorthand_arrow_functions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_shorthand_arrow_functions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_shorthand_arrow_functions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_shorthand_arrow_functions.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_shorthand_arrow_functions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_shorthand_arrow_functions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_binary_operators">module jscs.require_space_after_binary_operators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_binary_operators.require_space_after_binary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_binary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_binary_operators.prototype">module jscs.require_space_after_binary_operators.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_binary_operators.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_after_binary_operators.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_binary_operators.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_after_binary_operators.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_binary_operators.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_after_binary_operators.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_comma">module jscs.require_space_after_comma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_comma.require_space_after_comma">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_comma.prototype">module jscs.require_space_after_comma.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_comma.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_after_comma.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_comma.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_after_comma.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_comma.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_after_comma.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_keywords">module jscs.require_space_after_keywords</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_keywords.require_space_after_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_keywords.prototype">module jscs.require_space_after_keywords.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_keywords.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_after_keywords.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_keywords.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_after_keywords.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_keywords.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_after_keywords.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_line_comment">module jscs.require_space_after_line_comment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_line_comment.require_space_after_line_comment">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_line_comment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_line_comment.prototype">module jscs.require_space_after_line_comment.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_line_comment.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_after_line_comment.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_line_comment.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_after_line_comment.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_line_comment.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_after_line_comment.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_object_keys">module jscs.require_space_after_object_keys</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_object_keys.require_space_after_object_keys">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_object_keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_object_keys.prototype">module jscs.require_space_after_object_keys.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_object_keys.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_after_object_keys.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_object_keys.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_after_object_keys.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_object_keys.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_after_object_keys.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_prefix_unary_operators">module jscs.require_space_after_prefix_unary_operators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_prefix_unary_operators.require_space_after_prefix_unary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_prefix_unary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_prefix_unary_operators.prototype">module jscs.require_space_after_prefix_unary_operators.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_after_prefix_unary_operators.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_after_prefix_unary_operators.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_after_prefix_unary_operators.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_binary_operators">module jscs.require_space_before_binary_operators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_binary_operators.require_space_before_binary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_binary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_binary_operators.prototype">module jscs.require_space_before_binary_operators.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_binary_operators.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_before_binary_operators.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_binary_operators.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_before_binary_operators.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_binary_operators.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_before_binary_operators.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_block_statements">module jscs.require_space_before_block_statements</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_block_statements.require_space_before_block_statements">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_block_statements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_block_statements.prototype">module jscs.require_space_before_block_statements.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_block_statements.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_before_block_statements.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_block_statements.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_before_block_statements.prototype.</span>configure
            <span class="apidocSignatureSpan">(requireSpaceBeforeBlockStatements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_block_statements.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_before_block_statements.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_comma">module jscs.require_space_before_comma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_comma.require_space_before_comma">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_comma.prototype">module jscs.require_space_before_comma.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_comma.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_before_comma.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_comma.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_before_comma.prototype.</span>configure
            <span class="apidocSignatureSpan">(option)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_comma.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_before_comma.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_destructured_values">module jscs.require_space_before_destructured_values</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_destructured_values.require_space_before_destructured_values">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_destructured_values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_destructured_values.prototype">module jscs.require_space_before_destructured_values.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_destructured_values.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_before_destructured_values.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_destructured_values.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_before_destructured_values.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_destructured_values.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_before_destructured_values.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_keywords">module jscs.require_space_before_keywords</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_keywords.require_space_before_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_keywords.prototype">module jscs.require_space_before_keywords.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_keywords.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_before_keywords.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_keywords.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_before_keywords.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_keywords.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_before_keywords.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_object_values">module jscs.require_space_before_object_values</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_object_values.require_space_before_object_values">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_object_values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_object_values.prototype">module jscs.require_space_before_object_values.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_object_values.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_before_object_values.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_object_values.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_before_object_values.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_object_values.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_before_object_values.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_postfix_unary_operators">module jscs.require_space_before_postfix_unary_operators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_postfix_unary_operators.require_space_before_postfix_unary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_postfix_unary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_postfix_unary_operators.prototype">module jscs.require_space_before_postfix_unary_operators.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_before_postfix_unary_operators.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_before_postfix_unary_operators.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_before_postfix_unary_operators.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_between_arguments">module jscs.require_space_between_arguments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_between_arguments.require_space_between_arguments">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_between_arguments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_between_arguments.prototype">module jscs.require_space_between_arguments.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_between_arguments.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_between_arguments.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_between_arguments.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_between_arguments.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_between_arguments.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_between_arguments.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_anonymous_function_expression">module jscs.require_spaces_in_anonymous_function_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression.require_spaces_in_anonymous_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_anonymous_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_anonymous_function_expression.prototype">module jscs.require_spaces_in_anonymous_function_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_anonymous_function_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_anonymous_function_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_anonymous_function_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_call_expression">module jscs.require_spaces_in_call_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_call_expression.require_spaces_in_call_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_call_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_call_expression.prototype">module jscs.require_spaces_in_call_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_call_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_call_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_call_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_call_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_call_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_call_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_conditional_expression">module jscs.require_spaces_in_conditional_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_conditional_expression.require_spaces_in_conditional_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_conditional_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_conditional_expression.prototype">module jscs.require_spaces_in_conditional_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_conditional_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_conditional_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_conditional_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_for_statement">module jscs.require_spaces_in_for_statement</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_for_statement.require_spaces_in_for_statement">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_for_statement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_for_statement.prototype">module jscs.require_spaces_in_for_statement.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_for_statement.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_for_statement.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_for_statement.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_for_statement.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_for_statement.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_for_statement.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_function">module jscs.require_spaces_in_function</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function.require_spaces_in_function">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_function.prototype">module jscs.require_spaces_in_function.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_function_declaration">module jscs.require_spaces_in_function_declaration</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_declaration.require_spaces_in_function_declaration">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_declaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_function_declaration.prototype">module jscs.require_spaces_in_function_declaration.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_declaration.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_declaration.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_declaration.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_declaration.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_declaration.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_declaration.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_function_expression">module jscs.require_spaces_in_function_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_expression.require_spaces_in_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_function_expression.prototype">module jscs.require_spaces_in_function_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_generator">module jscs.require_spaces_in_generator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_generator.require_spaces_in_generator">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_generator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_generator.prototype">module jscs.require_spaces_in_generator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_generator.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_generator.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_generator.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_generator.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_generator.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_generator.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_named_function_expression">module jscs.require_spaces_in_named_function_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_named_function_expression.require_spaces_in_named_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_named_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_named_function_expression.prototype">module jscs.require_spaces_in_named_function_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_named_function_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_named_function_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_named_function_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_array_brackets">module jscs.require_spaces_inside_array_brackets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_array_brackets.require_spaces_inside_array_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_array_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_array_brackets.prototype">module jscs.require_spaces_inside_array_brackets.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_array_brackets.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_array_brackets.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_array_brackets.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_brackets">module jscs.require_spaces_inside_brackets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_brackets.require_spaces_inside_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_brackets.prototype">module jscs.require_spaces_inside_brackets.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_brackets.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_brackets.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_brackets.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_brackets.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_brackets.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_brackets.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_imported_object_braces">module jscs.require_spaces_inside_imported_object_braces</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces.require_spaces_inside_imported_object_braces">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_imported_object_braces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_imported_object_braces.prototype">module jscs.require_spaces_inside_imported_object_braces.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_imported_object_braces.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_imported_object_braces.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_imported_object_braces.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_object_brackets">module jscs.require_spaces_inside_object_brackets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_object_brackets.require_spaces_inside_object_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_object_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_object_brackets.prototype">module jscs.require_spaces_inside_object_brackets.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_object_brackets.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_object_brackets.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_object_brackets.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_parentheses">module jscs.require_spaces_inside_parentheses</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parentheses.require_spaces_inside_parentheses">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parentheses
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_parentheses.prototype">module jscs.require_spaces_inside_parentheses.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parentheses.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parentheses.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parentheses.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parentheses.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parentheses.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parentheses.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_parenthesized_expression">module jscs.require_spaces_inside_parenthesized_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression.require_spaces_inside_parenthesized_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parenthesized_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_parenthesized_expression.prototype">module jscs.require_spaces_inside_parenthesized_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parenthesized_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parenthesized_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parenthesized_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spread">module jscs.require_spread</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spread.require_spread">
            function <span class="apidocSignatureSpan">jscs.</span>require_spread
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spread.prototype">module jscs.require_spread.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spread.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spread.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spread.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spread.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spread.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spread.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_template_strings">module jscs.require_template_strings</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_template_strings.require_template_strings">
            function <span class="apidocSignatureSpan">jscs.</span>require_template_strings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_template_strings.prototype">module jscs.require_template_strings.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_template_strings.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_template_strings.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_template_strings.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_template_strings.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_template_strings.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_template_strings.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_trailing_comma">module jscs.require_trailing_comma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_trailing_comma.require_trailing_comma">
            function <span class="apidocSignatureSpan">jscs.</span>require_trailing_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_trailing_comma.prototype">module jscs.require_trailing_comma.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_trailing_comma.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.require_trailing_comma.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_trailing_comma.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_trailing_comma.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_trailing_comma.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_trailing_comma.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_trailing_comma.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_trailing_comma.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_use_strict">module jscs.require_use_strict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_use_strict.require_use_strict">
            function <span class="apidocSignatureSpan">jscs.</span>require_use_strict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_use_strict.prototype">module jscs.require_use_strict.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_use_strict.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_use_strict.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_use_strict.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_use_strict.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_use_strict.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_use_strict.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_var_decl_first">module jscs.require_var_decl_first</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_var_decl_first.require_var_decl_first">
            function <span class="apidocSignatureSpan">jscs.</span>require_var_decl_first
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_var_decl_first.prototype">module jscs.require_var_decl_first.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_var_decl_first.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_var_decl_first.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_var_decl_first.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_var_decl_first.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_var_decl_first.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_var_decl_first.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_yoda_conditions">module jscs.require_yoda_conditions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_yoda_conditions.require_yoda_conditions">
            function <span class="apidocSignatureSpan">jscs.</span>require_yoda_conditions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_yoda_conditions.prototype">module jscs.require_yoda_conditions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_yoda_conditions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_yoda_conditions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_yoda_conditions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_yoda_conditions.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_yoda_conditions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_yoda_conditions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.safe_context_keyword">module jscs.safe_context_keyword</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.safe_context_keyword.safe_context_keyword">
            function <span class="apidocSignatureSpan">jscs.</span>safe_context_keyword
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.safe_context_keyword.prototype">module jscs.safe_context_keyword.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.safe_context_keyword.prototype.check">
            function <span class="apidocSignatureSpan">jscs.safe_context_keyword.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.safe_context_keyword.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.safe_context_keyword.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.safe_context_keyword.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.safe_context_keyword.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.super_">module jscs.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.super_">
            function <span class="apidocSignatureSpan">jscs.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.super_.prototype">module jscs.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype._addParseError">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_addParseError
            <span class="apidocSignatureSpan">(errors, parseError, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype._checkJsFile">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_checkJsFile
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype._createConfiguration">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_createConfiguration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype._createJsFileInstance">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_createJsFileInstance
            <span class="apidocSignatureSpan">(filename, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype._fixCommonError">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_fixCommonError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype._fixJsFile">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_fixJsFile
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype._fixSpecificError">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_fixSpecificError
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.checkString">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>checkString
            <span class="apidocSignatureSpan">(source, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>configure
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.fixString">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>fixString
            <span class="apidocSignatureSpan">(source, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.getConfiguration">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>getConfiguration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.getProcessedConfig">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>getProcessedConfig
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.maxErrorsEnabled">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>maxErrorsEnabled
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.maxErrorsExceeded">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>maxErrorsExceeded
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.registerDefaultRules">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>registerDefaultRules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.registerRule">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>registerRule
            <span class="apidocSignatureSpan">(rule)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.token_assert">module jscs.token_assert</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.token_assert">
            function <span class="apidocSignatureSpan">jscs.</span>token_assert
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.super_">
            function <span class="apidocSignatureSpan">jscs.token_assert.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.token_assert.prototype">module jscs.token_assert.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype._augmentLineCount">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>_augmentLineCount
            <span class="apidocSignatureSpan">(options, lineCount)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype._updateCommentWhitespace">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>_updateCommentWhitespace
            <span class="apidocSignatureSpan">(token, indentChar, actual, expected)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype._updateWhitespaceByLine">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>_updateWhitespaceByLine
            <span class="apidocSignatureSpan">(token, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype._validateOptions">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>_validateOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype.differentLine">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>differentLine
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype.indentation">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>indentation
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype.linesBetween">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>linesBetween
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype.noWhitespaceBetween">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>noWhitespaceBetween
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype.sameLine">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>sameLine
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype.spacesBetween">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>spacesBetween
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype.whitespaceBetween">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>whitespaceBetween
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.token_categorizer">module jscs.token_categorizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_categorizer.categorizeCloseParen">
            function <span class="apidocSignatureSpan">jscs.token_categorizer.</span>categorizeCloseParen
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_categorizer.categorizeOpenParen">
            function <span class="apidocSignatureSpan">jscs.token_categorizer.</span>categorizeOpenParen
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.token_index">module jscs.token_index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_index.token_index">
            function <span class="apidocSignatureSpan">jscs.</span>token_index
            <span class="apidocSignatureSpan">(firstToken)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.token_index.prototype">module jscs.token_index.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_index.prototype._buildIndex">
            function <span class="apidocSignatureSpan">jscs.token_index.prototype.</span>_buildIndex
            <span class="apidocSignatureSpan">(firstToken)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_index.prototype.getElementLoc">
            function <span class="apidocSignatureSpan">jscs.token_index.prototype.</span>getElementLoc
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_index.prototype.isRuleEnabled">
            function <span class="apidocSignatureSpan">jscs.token_index.prototype.</span>isRuleEnabled
            <span class="apidocSignatureSpan">(ruleName, element)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.tree_iterator">module jscs.tree_iterator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.tree_iterator.iterate">
            function <span class="apidocSignatureSpan">jscs.tree_iterator.</span>iterate
            <span class="apidocSignatureSpan">(node, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.utils">module jscs.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.utils.getFunctionNodeFromIIFE">
            function <span class="apidocSignatureSpan">jscs.utils.</span>getFunctionNodeFromIIFE
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.utils.isPragma">
            function <span class="apidocSignatureSpan">jscs.utils.</span>isPragma
            <span class="apidocSignatureSpan">(additionalExceptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.utils.isRelativePath">
            function <span class="apidocSignatureSpan">jscs.utils.</span>isRelativePath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.utils.isSnakeCased">
            function <span class="apidocSignatureSpan">jscs.utils.</span>isSnakeCased
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.utils.isValidIdentifierName">
            function <span class="apidocSignatureSpan">jscs.utils.</span>isValidIdentifierName
            <span class="apidocSignatureSpan">(name, dialect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.utils.normalizePath">
            function <span class="apidocSignatureSpan">jscs.utils.</span>normalizePath
            <span class="apidocSignatureSpan">(filepath, basePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.utils.promisify">
            function <span class="apidocSignatureSpan">jscs.utils.</span>promisify
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.utils.trimUnderscores">
            function <span class="apidocSignatureSpan">jscs.utils.</span>trimUnderscores
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.utils.</span>binaryOperators</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.utils.</span>curlyBracedKeywords</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.utils.</span>incrementAndDecrementOperators</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.utils.</span>operators</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.utils.</span>spacedKeywords</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.utils.</span>unaryOperators</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_aligned_function_parameters">module jscs.validate_aligned_function_parameters</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_aligned_function_parameters.validate_aligned_function_parameters">
            function <span class="apidocSignatureSpan">jscs.</span>validate_aligned_function_parameters
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_aligned_function_parameters.prototype">module jscs.validate_aligned_function_parameters.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_aligned_function_parameters.prototype.check">
            function <span class="apidocSignatureSpan">jscs.validate_aligned_function_parameters.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_aligned_function_parameters.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.validate_aligned_function_parameters.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_aligned_function_parameters.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.validate_aligned_function_parameters.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_comment_position">module jscs.validate_comment_position</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_comment_position.validate_comment_position">
            function <span class="apidocSignatureSpan">jscs.</span>validate_comment_position
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_comment_position.prototype">module jscs.validate_comment_position.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_comment_position.prototype.check">
            function <span class="apidocSignatureSpan">jscs.validate_comment_position.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_comment_position.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.validate_comment_position.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_comment_position.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.validate_comment_position.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_indentation">module jscs.validate_indentation</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.validate_indentation">
            function <span class="apidocSignatureSpan">jscs.</span>validate_indentation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_indentation.prototype">module jscs.validate_indentation.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.prototype._checkNode">
            function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_checkNode
            <span class="apidocSignatureSpan">(parentElement, errors, initialIndent, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.prototype._getElementDirectIndent">
            function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_getElementDirectIndent
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.prototype._getFunctionIndent">
            function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_getFunctionIndent
            <span class="apidocSignatureSpan">(functionExpression, indent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.prototype._getObjectExpressionIndent">
            function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_getObjectExpressionIndent
            <span class="apidocSignatureSpan">(objectExpression, indent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.prototype.check">
            function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_line_breaks">module jscs.validate_line_breaks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_line_breaks.validate_line_breaks">
            function <span class="apidocSignatureSpan">jscs.</span>validate_line_breaks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_line_breaks.prototype">module jscs.validate_line_breaks.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_line_breaks.prototype.check">
            function <span class="apidocSignatureSpan">jscs.validate_line_breaks.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_line_breaks.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.validate_line_breaks.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_line_breaks.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.validate_line_breaks.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_newline_after_array_elements">module jscs.validate_newline_after_array_elements</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_newline_after_array_elements.validate_newline_after_array_elements">
            function <span class="apidocSignatureSpan">jscs.</span>validate_newline_after_array_elements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_newline_after_array_elements.prototype">module jscs.validate_newline_after_array_elements.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_newline_after_array_elements.prototype.check">
            function <span class="apidocSignatureSpan">jscs.validate_newline_after_array_elements.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_newline_after_array_elements.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.validate_newline_after_array_elements.prototype.</span>configure
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_newline_after_array_elements.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.validate_newline_after_array_elements.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_order_in_object_keys">module jscs.validate_order_in_object_keys</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_order_in_object_keys.validate_order_in_object_keys">
            function <span class="apidocSignatureSpan">jscs.</span>validate_order_in_object_keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_order_in_object_keys.prototype">module jscs.validate_order_in_object_keys.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_order_in_object_keys.prototype.check">
            function <span class="apidocSignatureSpan">jscs.validate_order_in_object_keys.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_order_in_object_keys.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.validate_order_in_object_keys.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_order_in_object_keys.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.validate_order_in_object_keys.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_parameter_separator">module jscs.validate_parameter_separator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_parameter_separator.validate_parameter_separator">
            function <span class="apidocSignatureSpan">jscs.</span>validate_parameter_separator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_parameter_separator.prototype">module jscs.validate_parameter_separator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_parameter_separator.prototype.check">
            function <span class="apidocSignatureSpan">jscs.validate_parameter_separator.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_parameter_separator.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.validate_parameter_separator.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_parameter_separator.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.validate_parameter_separator.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_quote_marks">module jscs.validate_quote_marks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_quote_marks.validate_quote_marks">
            function <span class="apidocSignatureSpan">jscs.</span>validate_quote_marks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_quote_marks.prototype">module jscs.validate_quote_marks.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_quote_marks.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.validate_quote_marks.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_quote_marks.prototype.check">
            function <span class="apidocSignatureSpan">jscs.validate_quote_marks.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_quote_marks.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.validate_quote_marks.prototype.</span>configure
            <span class="apidocSignatureSpan">(quoteMark)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_quote_marks.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.validate_quote_marks.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs" id="apidoc.module.jscs">module jscs</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.jscs" id="apidoc.element.jscs.jscs">
        function <span class="apidocSignatureSpan"></span>jscs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jscs = function () {
    StringChecker.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration" id="apidoc.element.jscs.configuration">
        function <span class="apidocSignatureSpan">jscs.</span>configuration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Configuration() {
<span class="apidocCodeCommentSpan">    /**
     * List of the registered (not used) presets.
     *
     * @protected
     * @type {Object}
     */
</span>    this._presets = {};

    /**
     * Name of the preset (if used).
     *
     * @protected
     * @type {String|null}
     */
    this._presetName = null;

    /**
     * List of loaded presets.
     *
     * @protected
     * @type {String|null}
     */
    this._loadedPresets = [];

    /**
     * List of rules instances.
     *
     * @protected
     * @type {Object}
     */
    this._rules = {};

    /**
     * List of configurated rule instances.
     *
     * @protected
     * @type {Object}
     */
    this._ruleSettings = {};

    /**
     * List of configured rules.
     *
     * @protected
     * @type {Array}
     */
    this._configuredRules = [];

    /**
     * List of unsupported rules.
     *
     * @protected
     * @type {Array}
     */
    this._unsupportedRuleNames = [];

    /**
     * File extensions that would be checked.
     *
     * @protected
     * @type {Array}
     */
    this._fileExtensions = [];

    /**
     * List of defined options (not complete).
     *
     * @protected
     * @type {Array}
     */
    this._definedOptions = [];

    /**
     * Default file extensions that would be checked.
     *
     * @protected
     * @type {Array}
     */
    this._defaultFileExtensions = [&#x27;.js&#x27;];

    /**
     * Exclusion masks.
     *
     * @protected
     * @type {Array}
     */
    this._excludedFileMasks = [];

    /**
     * Default exclusion masks, will be rewritten if user has their own masks.
     *
     * @protected
     * @type {Array}
     */
    this._defaultExcludedFileMasks = [&#x27;.git/**&#x27;, &#x27;node_modules/**&#x27;];

    /**
     * List of existing files that falls under exclusion masks.
     *
     * @protected
     * @type {Array}
     */
    this._excludedFileMatchers = [];

    /**
     * Extraction masks.
     *
     * @protected
     * @type {Array}
     */
    this._extractFileMasks = [];

    /**
     * Default extractions masks.
     *
     * @protected
     * @type {Array}
     */
    this._defaultExtractFileMasks = [&#x27;**/*.+(htm|html|xhtml)&#x27;];

    /**
     * List of file matchers from which to extract JavaScript.
     *
     * @protected
     * @type {Array}
     */
    this._extractFileMatchers = [];

    /**
     * Maxixum amount of error that would be reportered.
     *
     * @protected
     * @type {Number}
     */
    this._maxErrors = defaults.maxErrors;

    /**
     * JSCS CWD.
     *
     * @protected
     * @type {String}
     */
    this._basePath = defaults.cwd;

    /**
     * List of overrided options (usually from CLI).
     *
     * @protected
     * @type {Object}
     */
    this._overrides = {};

    /**
     * Is &#x22;ES3&#x22; mode enabled?.
     *
     * @protected
     * @type {Boolean}
     */
    this._es3Enabled = false;

    /**
     * A filter function that determines whether or not to report an error.
     *
     * @protected
     * @type {Function|null}
     */
    this._errorFilter = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_anonymous_functions" id="apidoc.element.jscs.disallow_anonymous_functions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_anonymous_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_anonymous_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_array_destructuring_return" id="apidoc.element.jscs.disallow_array_destructuring_return">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_array_destructuring_return
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_array_destructuring_return = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_arrow_functions" id="apidoc.element.jscs.disallow_arrow_functions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_arrow_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_arrow_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_capitalized_comments" id="apidoc.element.jscs.disallow_capitalized_comments">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_capitalized_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_capitalized_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_comma_before_line_break" id="apidoc.element.jscs.disallow_comma_before_line_break">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_comma_before_line_break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_comma_before_line_break = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_curly_braces" id="apidoc.element.jscs.disallow_curly_braces">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_curly_braces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_curly_braces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_dangling_underscores" id="apidoc.element.jscs.disallow_dangling_underscores">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_dangling_underscores
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_dangling_underscores = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_empty_blocks" id="apidoc.element.jscs.disallow_empty_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_empty_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_empty_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_function_declarations" id="apidoc.element.jscs.disallow_function_declarations">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_function_declarations
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_function_declarations = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_identical_destructuring_names" id="apidoc.element.jscs.disallow_identical_destructuring_names">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_identical_destructuring_names
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_identical_destructuring_names = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_identifier_names" id="apidoc.element.jscs.disallow_identifier_names">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_identifier_names
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_identifier_names = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_implicit_type_conversion" id="apidoc.element.jscs.disallow_implicit_type_conversion">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_implicit_type_conversion
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_implicit_type_conversion = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords" id="apidoc.element.jscs.disallow_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_in_comments" id="apidoc.element.jscs.disallow_keywords_in_comments">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_in_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_keywords_in_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_on_new_line" id="apidoc.element.jscs.disallow_keywords_on_new_line">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_on_new_line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_keywords_on_new_line = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs" id="apidoc.element.jscs.disallow_mixed_spaces_and_tabs">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_mixed_spaces_and_tabs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_mixed_spaces_and_tabs = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multi_line_ternary" id="apidoc.element.jscs.disallow_multi_line_ternary">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multi_line_ternary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multi_line_ternary = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_breaks" id="apidoc.element.jscs.disallow_multiple_line_breaks">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_breaks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multiple_line_breaks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_strings" id="apidoc.element.jscs.disallow_multiple_line_strings">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_strings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multiple_line_strings = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_spaces" id="apidoc.element.jscs.disallow_multiple_spaces">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_spaces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multiple_spaces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_var_decl" id="apidoc.element.jscs.disallow_multiple_var_decl">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_var_decl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multiple_var_decl = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_named_unassigned_functions" id="apidoc.element.jscs.disallow_named_unassigned_functions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_named_unassigned_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_named_unassigned_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_nested_ternaries" id="apidoc.element.jscs.disallow_nested_ternaries">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_nested_ternaries
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_nested_ternaries = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_newline_before_block_statements" id="apidoc.element.jscs.disallow_newline_before_block_statements">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_newline_before_block_statements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_newline_before_block_statements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_node_types" id="apidoc.element.jscs.disallow_node_types">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_node_types
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_node_types = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_not_operators_in_conditionals" id="apidoc.element.jscs.disallow_not_operators_in_conditionals">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_not_operators_in_conditionals
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_not_operators_in_conditionals = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_object_keys_on_new_line" id="apidoc.element.jscs.disallow_object_keys_on_new_line">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_object_keys_on_new_line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_object_keys_on_new_line = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_operator_before_line_break" id="apidoc.element.jscs.disallow_operator_before_line_break">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_operator_before_line_break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_operator_before_line_break = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks" id="apidoc.element.jscs.disallow_padding_newlines_after_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_after_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict" id="apidoc.element.jscs.disallow_padding_newlines_after_use_strict">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_use_strict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_after_use_strict = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_export" id="apidoc.element.jscs.disallow_padding_newlines_before_export">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_export
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_before_export = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords" id="apidoc.element.jscs.disallow_padding_newlines_before_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_before_keywords = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments" id="apidoc.element.jscs.disallow_padding_newlines_before_line_comments">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_line_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_before_line_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks" id="apidoc.element.jscs.disallow_padding_newlines_in_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_in_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_objects" id="apidoc.element.jscs.disallow_padding_newlines_in_objects">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_objects
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_in_objects = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param" id="apidoc.element.jscs.disallow_parentheses_around_arrow_param">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_parentheses_around_arrow_param
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_parentheses_around_arrow_param = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_quoted_keys_in_objects" id="apidoc.element.jscs.disallow_quoted_keys_in_objects">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_quoted_keys_in_objects
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_quoted_keys_in_objects = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_semicolons" id="apidoc.element.jscs.disallow_semicolons">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_semicolons
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_semicolons = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_shorthand_arrow_functions" id="apidoc.element.jscs.disallow_shorthand_arrow_functions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_shorthand_arrow_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_shorthand_arrow_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_binary_operators" id="apidoc.element.jscs.disallow_space_after_binary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_binary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_binary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_comma" id="apidoc.element.jscs.disallow_space_after_comma">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_comma = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_keywords" id="apidoc.element.jscs.disallow_space_after_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_line_comment" id="apidoc.element.jscs.disallow_space_after_line_comment">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_line_comment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_line_comment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_object_keys" id="apidoc.element.jscs.disallow_space_after_object_keys">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_object_keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_object_keys = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators" id="apidoc.element.jscs.disallow_space_after_prefix_unary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_prefix_unary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_prefix_unary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_binary_operators" id="apidoc.element.jscs.disallow_space_before_binary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_binary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_binary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_block_statements" id="apidoc.element.jscs.disallow_space_before_block_statements">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_block_statements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_block_statements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_comma" id="apidoc.element.jscs.disallow_space_before_comma">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_comma = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_keywords" id="apidoc.element.jscs.disallow_space_before_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_object_values" id="apidoc.element.jscs.disallow_space_before_object_values">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_object_values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_object_values = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators" id="apidoc.element.jscs.disallow_space_before_postfix_unary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_postfix_unary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_postfix_unary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_semicolon" id="apidoc.element.jscs.disallow_space_before_semicolon">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_semicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_semicolon = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_between_arguments" id="apidoc.element.jscs.disallow_space_between_arguments">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_between_arguments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_between_arguments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression" id="apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_anonymous_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_anonymous_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_call_expression" id="apidoc.element.jscs.disallow_spaces_in_call_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_call_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_call_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression" id="apidoc.element.jscs.disallow_spaces_in_conditional_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_conditional_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_conditional_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_for_statement" id="apidoc.element.jscs.disallow_spaces_in_for_statement">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_for_statement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_for_statement = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function" id="apidoc.element.jscs.disallow_spaces_in_function">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_function = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_declaration" id="apidoc.element.jscs.disallow_spaces_in_function_declaration">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_declaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_function_declaration = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_expression" id="apidoc.element.jscs.disallow_spaces_in_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_generator" id="apidoc.element.jscs.disallow_spaces_in_generator">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_generator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_generator = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression" id="apidoc.element.jscs.disallow_spaces_in_named_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_named_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_named_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets" id="apidoc.element.jscs.disallow_spaces_inside_array_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_array_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_array_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_brackets" id="apidoc.element.jscs.disallow_spaces_inside_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces" id="apidoc.element.jscs.disallow_spaces_inside_imported_object_braces">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_imported_object_braces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_imported_object_braces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets" id="apidoc.element.jscs.disallow_spaces_inside_object_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_object_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_object_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parentheses" id="apidoc.element.jscs.disallow_spaces_inside_parentheses">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parentheses
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_parentheses = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression" id="apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parenthesized_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_parenthesized_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders" id="apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_template_string_placeholders
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_template_string_placeholders = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_tabs" id="apidoc.element.jscs.disallow_tabs">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_tabs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_tabs = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_comma" id="apidoc.element.jscs.disallow_trailing_comma">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_trailing_comma = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_whitespace" id="apidoc.element.jscs.disallow_trailing_whitespace">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_whitespace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_trailing_whitespace = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_params" id="apidoc.element.jscs.disallow_unused_params">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_unused_params
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_unused_params = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_variables" id="apidoc.element.jscs.disallow_unused_variables">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_unused_variables
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_unused_variables = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_var" id="apidoc.element.jscs.disallow_var">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_var
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_var = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_yoda_conditions" id="apidoc.element.jscs.disallow_yoda_conditions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_yoda_conditions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_yoda_conditions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors" id="apidoc.element.jscs.errors">
        function <span class="apidocSignatureSpan">jscs.</span>errors
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errors = function (file) {
    this._errorList = [];
    this._file = file;
    this._currentRule = &#x27;&#x27;;

<span class="apidocCodeCommentSpan">    /**
     * @type {TokenAssert}
     * @public
     */
</span>    this.assert = new TokenAssert(file);
    this.assert.on(&#x27;error&#x27;, this._addError.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.generator" id="apidoc.element.jscs.generator">
        function <span class="apidocSignatureSpan">jscs.</span>generator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Generator() {
    this._config = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file" id="apidoc.element.jscs.js_file">
        function <span class="apidocSignatureSpan">jscs.</span>js_file
        <span class="apidocSignatureSpan">(params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">js_file = function (params) {
    params = params || {};
    this._parseErrors = [];
    this._filename = params.filename;
    this._source = params.source;

    this._es3 = params.es3 || false;

    this._lineBreaks = null;
    this._lines = this._source.split(/\r\n|\r|\n/);

    var parser = new Parser({
        strictMode: false,
        languageExtensions: {
            gritDirectives: true,
            appleInstrumentationDirectives: true
        }
    });

    try {
        this._program = parser.parse(this._source);
    } catch (e) {
        this._parseErrors.push(e);
        this._program = new Program([
            new Token(&#x27;EOF&#x27;, &#x27;&#x27;)
        ]);
    }

    // Lazy initialization
    this._scopes = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.jsdoc" id="apidoc.element.jscs.jsdoc">
        function <span class="apidocSignatureSpan">jscs.</span>jsdoc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsdoc = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.maximum_line_length" id="apidoc.element.jscs.maximum_line_length">
        function <span class="apidocSignatureSpan">jscs.</span>maximum_line_length
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maximum_line_length = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.maximum_number_of_lines" id="apidoc.element.jscs.maximum_number_of_lines">
        function <span class="apidocSignatureSpan">jscs.</span>maximum_number_of_lines
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maximum_number_of_lines = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.node_configuration" id="apidoc.element.jscs.node_configuration">
        function <span class="apidocSignatureSpan">jscs.</span>node_configuration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodeConfiguration() {
    Configuration.call(this);
    this._basePath = process.cwd();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_aligned_multiline_params" id="apidoc.element.jscs.require_aligned_multiline_params">
        function <span class="apidocSignatureSpan">jscs.</span>require_aligned_multiline_params
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_aligned_multiline_params = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_aligned_object_values" id="apidoc.element.jscs.require_aligned_object_values">
        function <span class="apidocSignatureSpan">jscs.</span>require_aligned_object_values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_aligned_object_values = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_anonymous_functions" id="apidoc.element.jscs.require_anonymous_functions">
        function <span class="apidocSignatureSpan">jscs.</span>require_anonymous_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_anonymous_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_array_destructuring" id="apidoc.element.jscs.require_array_destructuring">
        function <span class="apidocSignatureSpan">jscs.</span>require_array_destructuring
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_array_destructuring = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_arrow_functions" id="apidoc.element.jscs.require_arrow_functions">
        function <span class="apidocSignatureSpan">jscs.</span>require_arrow_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_arrow_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_blocks_on_newline" id="apidoc.element.jscs.require_blocks_on_newline">
        function <span class="apidocSignatureSpan">jscs.</span>require_blocks_on_newline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_blocks_on_newline = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers" id="apidoc.element.jscs.require_camelcase_or_uppercase_identifiers">
        function <span class="apidocSignatureSpan">jscs.</span>require_camelcase_or_uppercase_identifiers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_camelcase_or_uppercase_identifiers = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments" id="apidoc.element.jscs.require_capitalized_comments">
        function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_capitalized_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors" id="apidoc.element.jscs.require_capitalized_constructors">
        function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_capitalized_constructors = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors_new" id="apidoc.element.jscs.require_capitalized_constructors_new">
        function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors_new
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_capitalized_constructors_new = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_comma_before_line_break" id="apidoc.element.jscs.require_comma_before_line_break">
        function <span class="apidocSignatureSpan">jscs.</span>require_comma_before_line_break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_comma_before_line_break = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_curly_braces" id="apidoc.element.jscs.require_curly_braces">
        function <span class="apidocSignatureSpan">jscs.</span>require_curly_braces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_curly_braces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_dollar_before_jquery_assignment" id="apidoc.element.jscs.require_dollar_before_jquery_assignment">
        function <span class="apidocSignatureSpan">jscs.</span>require_dollar_before_jquery_assignment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_dollar_before_jquery_assignment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_dot_notation" id="apidoc.element.jscs.require_dot_notation">
        function <span class="apidocSignatureSpan">jscs.</span>require_dot_notation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_dot_notation = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_early_return" id="apidoc.element.jscs.require_early_return">
        function <span class="apidocSignatureSpan">jscs.</span>require_early_return
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_early_return = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_enhanced_object_literals" id="apidoc.element.jscs.require_enhanced_object_literals">
        function <span class="apidocSignatureSpan">jscs.</span>require_enhanced_object_literals
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_enhanced_object_literals = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_function_declarations" id="apidoc.element.jscs.require_function_declarations">
        function <span class="apidocSignatureSpan">jscs.</span>require_function_declarations
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_function_declarations = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_imports_alphabetized" id="apidoc.element.jscs.require_imports_alphabetized">
        function <span class="apidocSignatureSpan">jscs.</span>require_imports_alphabetized
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_imports_alphabetized = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_keywords_on_new_line" id="apidoc.element.jscs.require_keywords_on_new_line">
        function <span class="apidocSignatureSpan">jscs.</span>require_keywords_on_new_line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_keywords_on_new_line = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_line_break_after_variable_assignment" id="apidoc.element.jscs.require_line_break_after_variable_assignment">
        function <span class="apidocSignatureSpan">jscs.</span>require_line_break_after_variable_assignment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_line_break_after_variable_assignment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_line_feed_at_file_end" id="apidoc.element.jscs.require_line_feed_at_file_end">
        function <span class="apidocSignatureSpan">jscs.</span>require_line_feed_at_file_end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_line_feed_at_file_end = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_matching_function_name" id="apidoc.element.jscs.require_matching_function_name">
        function <span class="apidocSignatureSpan">jscs.</span>require_matching_function_name
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_matching_function_name = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_multi_line_ternary" id="apidoc.element.jscs.require_multi_line_ternary">
        function <span class="apidocSignatureSpan">jscs.</span>require_multi_line_ternary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_multi_line_ternary = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_multiple_var_decl" id="apidoc.element.jscs.require_multiple_var_decl">
        function <span class="apidocSignatureSpan">jscs.</span>require_multiple_var_decl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_multiple_var_decl = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_named_unassigned_functions" id="apidoc.element.jscs.require_named_unassigned_functions">
        function <span class="apidocSignatureSpan">jscs.</span>require_named_unassigned_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_named_unassigned_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_block_statements" id="apidoc.element.jscs.require_newline_before_block_statements">
        function <span class="apidocSignatureSpan">jscs.</span>require_newline_before_block_statements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_newline_before_block_statements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_single_statements_in_if" id="apidoc.element.jscs.require_newline_before_single_statements_in_if">
        function <span class="apidocSignatureSpan">jscs.</span>require_newline_before_single_statements_in_if
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_newline_before_single_statements_in_if = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_numeric_literals" id="apidoc.element.jscs.require_numeric_literals">
        function <span class="apidocSignatureSpan">jscs.</span>require_numeric_literals
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_numeric_literals = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_object_destructuring" id="apidoc.element.jscs.require_object_destructuring">
        function <span class="apidocSignatureSpan">jscs.</span>require_object_destructuring
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_object_destructuring = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_object_keys_on_new_line" id="apidoc.element.jscs.require_object_keys_on_new_line">
        function <span class="apidocSignatureSpan">jscs.</span>require_object_keys_on_new_line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_object_keys_on_new_line = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_operator_before_line_break" id="apidoc.element.jscs.require_operator_before_line_break">
        function <span class="apidocSignatureSpan">jscs.</span>require_operator_before_line_break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_operator_before_line_break = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration" id="apidoc.element.jscs.require_padding_newline_after_variable_declaration">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newline_after_variable_declaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newline_after_variable_declaration = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_blocks" id="apidoc.element.jscs.require_padding_newlines_after_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_after_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_use_strict" id="apidoc.element.jscs.require_padding_newlines_after_use_strict">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_use_strict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_after_use_strict = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_export" id="apidoc.element.jscs.require_padding_newlines_before_export">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_export
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_before_export = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_keywords" id="apidoc.element.jscs.require_padding_newlines_before_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_before_keywords = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_line_comments" id="apidoc.element.jscs.require_padding_newlines_before_line_comments">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_line_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_before_line_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_blocks" id="apidoc.element.jscs.require_padding_newlines_in_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_in_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_objects" id="apidoc.element.jscs.require_padding_newlines_in_objects">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_objects
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_in_objects = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_arrow_param" id="apidoc.element.jscs.require_parentheses_around_arrow_param">
        function <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_arrow_param
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_parentheses_around_arrow_param = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_iife" id="apidoc.element.jscs.require_parentheses_around_iife">
        function <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_iife
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_parentheses_around_iife = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_quoted_keys_in_objects" id="apidoc.element.jscs.require_quoted_keys_in_objects">
        function <span class="apidocSignatureSpan">jscs.</span>require_quoted_keys_in_objects
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_quoted_keys_in_objects = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_semicolons" id="apidoc.element.jscs.require_semicolons">
        function <span class="apidocSignatureSpan">jscs.</span>require_semicolons
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_semicolons = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_shorthand_arrow_functions" id="apidoc.element.jscs.require_shorthand_arrow_functions">
        function <span class="apidocSignatureSpan">jscs.</span>require_shorthand_arrow_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_shorthand_arrow_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_binary_operators" id="apidoc.element.jscs.require_space_after_binary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_binary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_binary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_comma" id="apidoc.element.jscs.require_space_after_comma">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_comma = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_keywords" id="apidoc.element.jscs.require_space_after_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_line_comment" id="apidoc.element.jscs.require_space_after_line_comment">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_line_comment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_line_comment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_object_keys" id="apidoc.element.jscs.require_space_after_object_keys">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_object_keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_object_keys = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_prefix_unary_operators" id="apidoc.element.jscs.require_space_after_prefix_unary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_prefix_unary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_prefix_unary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_binary_operators" id="apidoc.element.jscs.require_space_before_binary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_binary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_binary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_block_statements" id="apidoc.element.jscs.require_space_before_block_statements">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_block_statements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_block_statements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_comma" id="apidoc.element.jscs.require_space_before_comma">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_comma = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_destructured_values" id="apidoc.element.jscs.require_space_before_destructured_values">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_destructured_values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_destructured_values = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_keywords" id="apidoc.element.jscs.require_space_before_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_object_values" id="apidoc.element.jscs.require_space_before_object_values">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_object_values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_object_values = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_postfix_unary_operators" id="apidoc.element.jscs.require_space_before_postfix_unary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_postfix_unary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_postfix_unary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_between_arguments" id="apidoc.element.jscs.require_space_between_arguments">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_between_arguments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_between_arguments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression" id="apidoc.element.jscs.require_spaces_in_anonymous_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_anonymous_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_anonymous_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_call_expression" id="apidoc.element.jscs.require_spaces_in_call_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_call_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_call_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_conditional_expression" id="apidoc.element.jscs.require_spaces_in_conditional_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_conditional_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_conditional_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_for_statement" id="apidoc.element.jscs.require_spaces_in_for_statement">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_for_statement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_for_statement = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function" id="apidoc.element.jscs.require_spaces_in_function">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_function = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_declaration" id="apidoc.element.jscs.require_spaces_in_function_declaration">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_declaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_function_declaration = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_expression" id="apidoc.element.jscs.require_spaces_in_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_generator" id="apidoc.element.jscs.require_spaces_in_generator">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_generator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_generator = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_named_function_expression" id="apidoc.element.jscs.require_spaces_in_named_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_named_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_named_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_array_brackets" id="apidoc.element.jscs.require_spaces_inside_array_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_array_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_array_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_brackets" id="apidoc.element.jscs.require_spaces_inside_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces" id="apidoc.element.jscs.require_spaces_inside_imported_object_braces">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_imported_object_braces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_imported_object_braces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_object_brackets" id="apidoc.element.jscs.require_spaces_inside_object_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_object_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_object_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parentheses" id="apidoc.element.jscs.require_spaces_inside_parentheses">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parentheses
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_parentheses = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression" id="apidoc.element.jscs.require_spaces_inside_parenthesized_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parenthesized_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_parenthesized_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spread" id="apidoc.element.jscs.require_spread">
        function <span class="apidocSignatureSpan">jscs.</span>require_spread
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spread = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_template_strings" id="apidoc.element.jscs.require_template_strings">
        function <span class="apidocSignatureSpan">jscs.</span>require_template_strings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_template_strings = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_trailing_comma" id="apidoc.element.jscs.require_trailing_comma">
        function <span class="apidocSignatureSpan">jscs.</span>require_trailing_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_trailing_comma = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_use_strict" id="apidoc.element.jscs.require_use_strict">
        function <span class="apidocSignatureSpan">jscs.</span>require_use_strict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_use_strict = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_var_decl_first" id="apidoc.element.jscs.require_var_decl_first">
        function <span class="apidocSignatureSpan">jscs.</span>require_var_decl_first
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_var_decl_first = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_yoda_conditions" id="apidoc.element.jscs.require_yoda_conditions">
        function <span class="apidocSignatureSpan">jscs.</span>require_yoda_conditions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_yoda_conditions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.safe_context_keyword" id="apidoc.element.jscs.safe_context_keyword">
        function <span class="apidocSignatureSpan">jscs.</span>safe_context_keyword
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">safe_context_keyword = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_" id="apidoc.element.jscs.super_">
        function <span class="apidocSignatureSpan">jscs.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {
    this._configuredRules = [];

    this._errorsFound = 0;
    this._maxErrorsExceeded = false;

    this._configuration = this._createConfiguration();
    this._configuration.registerDefaultPresets();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert" id="apidoc.element.jscs.token_assert">
        function <span class="apidocSignatureSpan">jscs.</span>token_assert
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenAssert(file) {
    EventEmitter.call(this);

    this._file = file;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_index" id="apidoc.element.jscs.token_index">
        function <span class="apidocSignatureSpan">jscs.</span>token_index
        <span class="apidocSignatureSpan">(firstToken)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenIndex(firstToken) {
    this._buildIndex(firstToken);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_aligned_function_parameters" id="apidoc.element.jscs.validate_aligned_function_parameters">
        function <span class="apidocSignatureSpan">jscs.</span>validate_aligned_function_parameters
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_aligned_function_parameters = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_comment_position" id="apidoc.element.jscs.validate_comment_position">
        function <span class="apidocSignatureSpan">jscs.</span>validate_comment_position
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_comment_position = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_indentation" id="apidoc.element.jscs.validate_indentation">
        function <span class="apidocSignatureSpan">jscs.</span>validate_indentation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_indentation = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_line_breaks" id="apidoc.element.jscs.validate_line_breaks">
        function <span class="apidocSignatureSpan">jscs.</span>validate_line_breaks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_line_breaks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_newline_after_array_elements" id="apidoc.element.jscs.validate_newline_after_array_elements">
        function <span class="apidocSignatureSpan">jscs.</span>validate_newline_after_array_elements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_newline_after_array_elements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_order_in_object_keys" id="apidoc.element.jscs.validate_order_in_object_keys">
        function <span class="apidocSignatureSpan">jscs.</span>validate_order_in_object_keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_order_in_object_keys = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_parameter_separator" id="apidoc.element.jscs.validate_parameter_separator">
        function <span class="apidocSignatureSpan">jscs.</span>validate_parameter_separator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_parameter_separator = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_quote_marks" id="apidoc.element.jscs.validate_quote_marks">
        function <span class="apidocSignatureSpan">jscs.</span>validate_quote_marks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_quote_marks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








































































































































































































































































































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.cli_config" id="apidoc.module.jscs.cli_config">module jscs.cli_config</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.cli_config.getContent" id="apidoc.element.jscs.cli_config.getContent">
        function <span class="apidocSignatureSpan">jscs.cli_config.</span>getContent
        <span class="apidocSignatureSpan">(config, directory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContent = function (config, directory) {
    if (!config) {
        return;
    }

    if (!directory) {
        directory = process.cwd();
    }

    var configPath = path.resolve(directory, config);
    var ext;
    var data;
    var content;
    var requireConfigPath;

    if (fs.existsSync(configPath)) {
        config = path.basename(config);
        ext = path.extname(configPath);

        if (ext === &#x27;.js&#x27;) {
            content = require(configPath);
        } else {
            data = stripBOM(fs.readFileSync(configPath, &#x27;utf8&#x27;));

            if (ext === &#x27;.json&#x27;) {
                content = parseJson(stripJSONComments(data));
            } else if (ext === &#x27;.yaml&#x27;) {
                content = yaml.safeLoad(data);
            } else {
                // try both JSON and YAML

                try {
                    content = parseJson(stripJSONComments(data));
                } catch (jsonError) {
                    try {
                        content = yaml.safeLoad(data);
                    } catch (yamlError) {
                        if (stripJSONComments(data).trim()[0] === &#x27;{&#x27;) {
                            // the intention was probably JSON
                            throw jsonError;
                        } else {
                            // assume the intention was YAML
                            throw yamlError;
                        }
                    }
                }
            }
        }
    } else {
        // Try to load it as a node module
        try {
            requireConfigPath = resolve.sync(config, { basedir: directory });
            content = require(requireConfigPath);
        } catch (e) {}
    }

    if (content) {
        // Adding property via Object.defineProperty makes it
        // non-enumerable and avoids warning for unsupported rules
        Object.defineProperty(content, &#x27;configPath&#x27;, {
            value: requireConfigPath || configPath
        });
    }

    return content &#x26;&#x26; config === &#x27;package.json&#x27; ? content.jscsConfig : content;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
exports.load = function(config, cwd) {
var content;
var directory = cwd || process.cwd();

// If config option is given, attempt to load it
if (config) {
    return this.<span class="apidocCodeKeywordSpan">getContent</span>(config, directory);
}

content = this.getContent(
    findup(configs, { nocase: true, cwd: directory }, function(configPath) {
        if (path.basename(configPath) === &#x27;package.json&#x27;) {
            return !!this.getContent(configPath);
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.cli_config.getReporter" id="apidoc.element.jscs.cli_config.getReporter">
        function <span class="apidocSignatureSpan">jscs.cli_config.</span>getReporter
        <span class="apidocSignatureSpan">(reporter, colors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getReporter = function (reporter, colors) {
    var writerPath;
    var writer;

    if (colors !== false) {
        colors = true;
    }

    if (reporter) {
        // ensure reporter is a string (and allow non-string types to be coerced)
        reporter = reporter.toString();
        writerPath = path.resolve(process.cwd(), reporter);

        if (!fs.existsSync(writerPath)) {
            writerPath = path.resolve(__dirname, &#x27;./reporters/&#x27; + reporter);
        }
    } else {
        writerPath = path.resolve(
            __dirname, &#x27;./reporters/&#x27;, (colors &#x26;&#x26; supportsColor ? &#x27;console&#x27; : &#x27;text&#x27;)
        );
    }

    try {
        writer = require(writerPath);
    } catch (e) {
        writer = null;
    }

    if (!writer) {
        try {
            writer = require(reporter);
            writerPath = reporter;
        } catch (e) {}
    }

    return {
        path: writerPath,
        writer: writer
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!args.length &#x26;&#x26; process.stdin.isTTY &#x26;&#x26; typeof program.autoConfigure !== &#x27;string&#x27;) {
    console.error(&#x27;No input files specified. Try option --help for usage information.&#x27;);
    defer.reject(3);

    return returnArgs;
}

reporter = configFile.<span class="apidocCodeKeywordSpan">getReporter</span>(program.reporter, program.colors);

returnArgs.reporter = reporter.path;

if (!reporter.writer) {
    console.error(&#x27;Reporter &#x22;%s&#x22; does not exist.&#x27;, program.reporter);
    returnArgs.reporter = reporter.path;
    defer.reject(6);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.cli_config.load" id="apidoc.element.jscs.cli_config.load">
        function <span class="apidocSignatureSpan">jscs.cli_config.</span>load
        <span class="apidocSignatureSpan">(config, cwd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (config, cwd) {
    var content;
    var directory = cwd || process.cwd();

    // If config option is given, attempt to load it
    if (config) {
        return this.getContent(config, directory);
    }

    content = this.getContent(
        findup(configs, { nocase: true, cwd: directory }, function(configPath) {
            if (path.basename(configPath) === &#x27;package.json&#x27;) {
                return !!this.getContent(configPath);
            }

            return true;
        }.bind(this))
    );

    if (content) {
        return content;
    }

    // Try to load standard configs from home dir
    var directoryArr = [process.env.USERPROFILE, process.env.HOMEPATH, process.env.HOME];
    for (var i = 0, dirLen = directoryArr.length; i &#x3c; dirLen; i++) {
        if (!directoryArr[i]) {
            continue;
        }

        for (var j = 0, len = configs.length; j &#x3c; len; j++) {
            content = this.getContent(configs[j], directoryArr[i]);

            if (content) {
                return content;
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

promise.always(function(status) {
    exit(status.valueOf());
});

try {
    config = configFile.<span class="apidocCodeKeywordSpan">load</span>(program.config);
} catch (e) {
    console.error(&#x27;Config source is corrupted -&#x27;, e.toString());
    defer.reject(5);

    return returnArgs;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.configuration" id="apidoc.module.jscs.configuration">module jscs.configuration</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.configuration.configuration" id="apidoc.element.jscs.configuration.configuration">
        function <span class="apidocSignatureSpan">jscs.</span>configuration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Configuration() {
<span class="apidocCodeCommentSpan">    /**
     * List of the registered (not used) presets.
     *
     * @protected
     * @type {Object}
     */
</span>    this._presets = {};

    /**
     * Name of the preset (if used).
     *
     * @protected
     * @type {String|null}
     */
    this._presetName = null;

    /**
     * List of loaded presets.
     *
     * @protected
     * @type {String|null}
     */
    this._loadedPresets = [];

    /**
     * List of rules instances.
     *
     * @protected
     * @type {Object}
     */
    this._rules = {};

    /**
     * List of configurated rule instances.
     *
     * @protected
     * @type {Object}
     */
    this._ruleSettings = {};

    /**
     * List of configured rules.
     *
     * @protected
     * @type {Array}
     */
    this._configuredRules = [];

    /**
     * List of unsupported rules.
     *
     * @protected
     * @type {Array}
     */
    this._unsupportedRuleNames = [];

    /**
     * File extensions that would be checked.
     *
     * @protected
     * @type {Array}
     */
    this._fileExtensions = [];

    /**
     * List of defined options (not complete).
     *
     * @protected
     * @type {Array}
     */
    this._definedOptions = [];

    /**
     * Default file extensions that would be checked.
     *
     * @protected
     * @type {Array}
     */
    this._defaultFileExtensions = [&#x27;.js&#x27;];

    /**
     * Exclusion masks.
     *
     * @protected
     * @type {Array}
     */
    this._excludedFileMasks = [];

    /**
     * Default exclusion masks, will be rewritten if user has their own masks.
     *
     * @protected
     * @type {Array}
     */
    this._defaultExcludedFileMasks = [&#x27;.git/**&#x27;, &#x27;node_modules/**&#x27;];

    /**
     * List of existing files that falls under exclusion masks.
     *
     * @protected
     * @type {Array}
     */
    this._excludedFileMatchers = [];

    /**
     * Extraction masks.
     *
     * @protected
     * @type {Array}
     */
    this._extractFileMasks = [];

    /**
     * Default extractions masks.
     *
     * @protected
     * @type {Array}
     */
    this._defaultExtractFileMasks = [&#x27;**/*.+(htm|html|xhtml)&#x27;];

    /**
     * List of file matchers from which to extract JavaScript.
     *
     * @protected
     * @type {Array}
     */
    this._extractFileMatchers = [];

    /**
     * Maxixum amount of error that would be reportered.
     *
     * @protected
     * @type {Number}
     */
    this._maxErrors = defaults.maxErrors;

    /**
     * JSCS CWD.
     *
     * @protected
     * @type {String}
     */
    this._basePath = defaults.cwd;

    /**
     * List of overrided options (usually from CLI).
     *
     * @protected
     * @type {Object}
     */
    this._overrides = {};

    /**
     * Is &#x22;ES3&#x22; mode enabled?.
     *
     * @protected
     * @type {Boolean}
     */
    this._es3Enabled = false;

    /**
     * A filter function that determines whether or not to report an error.
     *
     * @protected
     * @type {Function|null}
     */
    this._errorFilter = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.configuration.prototype" id="apidoc.module.jscs.configuration.prototype">module jscs.configuration.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._errorOnRemovedOptions" id="apidoc.element.jscs.configuration.prototype._errorOnRemovedOptions">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_errorOnRemovedOptions
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_errorOnRemovedOptions = function (config) {
    var errors = [&#x27;Config values to remove in 3.0:&#x27;];

    if (config.hasOwnProperty(&#x27;esprima&#x27;)) {
        errors.push(&#x27;The `esprima` option since CST uses babylon (the babel parser) under the hood&#x27;);
    }

    if (config.hasOwnProperty(&#x27;esprimaOptions&#x27;)) {
        errors.push(&#x27;The `esprimaOptions` option.&#x27;);
    }

    if (config.hasOwnProperty(&#x27;esnext&#x27;)) {
        errors.push(&#x27;The `esnext` option is enabled by default.&#x27;);
    }

    if (config.hasOwnProperty(&#x27;verbose&#x27;)) {
        errors.push(&#x27;The `verbose` option is enabled by default.&#x27;);
    }

    if (errors.length &#x3e; 1) {
        throw new Error(errors.join(&#x27;\n&#x27;));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Copy configuration so original config would be intact
copyConfiguration(config, currentConfig);

// Override the properties
copyConfiguration(overrides, currentConfig);

this.<span class="apidocCodeKeywordSpan">_errorOnRemovedOptions</span>(currentConfig);

// NOTE: options is a separate object to ensure that future options must be added
// to BUILTIN_OPTIONS to work, which also assures they aren&#x27;t mistaken for a rule
var options = this._getOptionsFromConfig(currentConfig);

// Base path
if (this._basePath === defaults.cwd &#x26;&#x26; options.configPath) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._getOptionsFromConfig" id="apidoc.element.jscs.configuration.prototype._getOptionsFromConfig">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_getOptionsFromConfig
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getOptionsFromConfig = function (config) {
    return Object.keys(config).reduce(function(options, key) {
        if (BUILTIN_OPTIONS[key]) {
            options[key] = config[key];
        }
        return options;
    }, {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Override the properties
copyConfiguration(overrides, currentConfig);

this._errorOnRemovedOptions(currentConfig);

// NOTE: options is a separate object to ensure that future options must be added
// to BUILTIN_OPTIONS to work, which also assures they aren&#x27;t mistaken for a rule
var options = this.<span class="apidocCodeKeywordSpan">_getOptionsFromConfig</span>(currentConfig);

// Base path
if (this._basePath === defaults.cwd &#x26;&#x26; options.configPath) {
    assert(
        typeof options.configPath === &#x27;string&#x27;,
        &#x27;`configPath` option requires string value&#x27;
    );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._isDefined" id="apidoc.element.jscs.configuration.prototype._isDefined">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_isDefined
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isDefined = function (name) {
    return this._definedOptions.indexOf(name) &#x3e; -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Load default values for options which were not defined
 *
 * @private
 */
Configuration.prototype._loadDefaults = function() {
    if (!this.<span class="apidocCodeKeywordSpan">_isDefined</span>(&#x27;excludeFiles&#x27;)) {
        this._loadExcludedFiles(this._defaultExcludedFileMasks);
    }

    if (!this._isDefined(&#x27;fileExtensions&#x27;)) {
        this._loadFileExtensions(this._defaultFileExtensions);
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadAdditionalRule" id="apidoc.element.jscs.configuration.prototype._loadAdditionalRule">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadAdditionalRule
        <span class="apidocSignatureSpan">(additionalRule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadAdditionalRule = function (additionalRule) {
    assert(typeof additionalRule === &#x27;object&#x27;, &#x27;`additionalRule` should be an object&#x27;);
    this.registerRule(additionalRule);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this._definedOptions.push(&#x27;plugins&#x27;);
    }
}

if (options.hasOwnProperty(&#x27;additionalRules&#x27;)) {
    assert(Array.isArray(options.additionalRules), &#x27;`additionalRules` option requires array value&#x27;);
    options.additionalRules.forEach(function(rule) {
        this.<span class="apidocCodeKeywordSpan">_loadAdditionalRule</span>(rule, options.configPath);
    }, this);

    if (!this._isDefined(&#x27;additionalRules&#x27;)) {
        this._definedOptions.push(&#x27;additionalRules&#x27;);
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadDefaults" id="apidoc.element.jscs.configuration.prototype._loadDefaults">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadDefaults
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadDefaults = function () {
    if (!this._isDefined(&#x27;excludeFiles&#x27;)) {
        this._loadExcludedFiles(this._defaultExcludedFileMasks);
    }

    if (!this._isDefined(&#x27;fileExtensions&#x27;)) {
        this._loadFileExtensions(this._defaultFileExtensions);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
Configuration.prototype.load = function(config) {

   // Load all the options
   this._processConfig(config);

   // Load defaults if they weren&#x27;t set
   this.<span class="apidocCodeKeywordSpan">_loadDefaults</span>(config);

   // Load and apply all the rules
   this._useRules();
};

/**
* Load default values for options which were not defined
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadES3" id="apidoc.element.jscs.configuration.prototype._loadES3">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadES3
        <span class="apidocSignatureSpan">(es3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadES3 = function (es3) {
    assert(
        typeof es3 === &#x27;boolean&#x27; || es3 === null,
        &#x27;`es3` option requires boolean or null value&#x27;
    );
    this._es3Enabled = Boolean(es3);

    if (!this._isDefined(&#x27;es3&#x27;)) {
        this._definedOptions.push(&#x27;es3&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (options.hasOwnProperty(&#x27;fix&#x27;)) {
    this._loadFix(options.fix);
}

this._loadMaxError(options);

if (options.hasOwnProperty(&#x27;es3&#x27;)) {
    this.<span class="apidocCodeKeywordSpan">_loadES3</span>(options.es3);
}

if (options.hasOwnProperty(&#x27;errorFilter&#x27;)) {
    this._loadErrorFilter(options.errorFilter, options.configPath);
}

// Apply presets
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadErrorFilter" id="apidoc.element.jscs.configuration.prototype._loadErrorFilter">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadErrorFilter
        <span class="apidocSignatureSpan">(errorFilter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadErrorFilter = function (errorFilter) {
    assert(
        typeof errorFilter === &#x27;function&#x27; ||
        errorFilter === null,
        &#x27;`errorFilter` option requires a function or null value&#x27;
    );
    this._errorFilter = errorFilter;

    if (!this._isDefined(&#x27;errorFilter&#x27;)) {
        this._definedOptions.push(&#x27;errorFilter&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._loadMaxError(options);

if (options.hasOwnProperty(&#x27;es3&#x27;)) {
    this._loadES3(options.es3);
}

if (options.hasOwnProperty(&#x27;errorFilter&#x27;)) {
    this.<span class="apidocCodeKeywordSpan">_loadErrorFilter</span>(options.errorFilter, options.configPath);
}

// Apply presets
if (options.hasOwnProperty(&#x27;preset&#x27;)) {
    this._loadPreset(options.preset, options.configPath);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadExcludedFiles" id="apidoc.element.jscs.configuration.prototype._loadExcludedFiles">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadExcludedFiles
        <span class="apidocSignatureSpan">(masks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadExcludedFiles = function (masks) {
    assert(Array.isArray(masks), &#x27;`excludeFiles` option requires array value&#x27;);

    this._excludedFileMasks = this._excludedFileMasks.concat(masks);
    this._excludedFileMatchers = this._excludedFileMasks.map(function(fileMask) {
        return new minimatch.Minimatch(path.resolve(this._basePath, fileMask), {
            dot: true
        });
    }, this);

    if (!this._isDefined(&#x27;excludeFiles&#x27;)) {
        this._definedOptions.push(&#x27;excludeFiles&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Load default values for options which were not defined
 *
 * @private
 */
Configuration.prototype._loadDefaults = function() {
    if (!this._isDefined(&#x27;excludeFiles&#x27;)) {
        this.<span class="apidocCodeKeywordSpan">_loadExcludedFiles</span>(this._defaultExcludedFileMasks);
    }

    if (!this._isDefined(&#x27;fileExtensions&#x27;)) {
        this._loadFileExtensions(this._defaultFileExtensions);
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadExtract" id="apidoc.element.jscs.configuration.prototype._loadExtract">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadExtract
        <span class="apidocSignatureSpan">(masks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadExtract = function (masks) {
    if (masks === true) {
        masks = this._defaultExtractFileMasks;
    } else if (masks === false) {
        masks = [];
    }

    assert(Array.isArray(masks), &#x27;`extract` option should be array of strings&#x27;);
    this._extractFileMasks = masks.slice();
    this._extractFileMatchers = this._extractFileMasks.map(function(fileMask) {
        return new minimatch.Minimatch(path.resolve(this._basePath, fileMask), {
            dot: true
        });
    }, this);

    if (!this._isDefined(&#x27;extract&#x27;)) {
        this._definedOptions.push(&#x27;extract&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (!this._isDefined(&#x27;additionalRules&#x27;)) {
        this._definedOptions.push(&#x27;additionalRules&#x27;);
    }
}

if (options.hasOwnProperty(&#x27;extract&#x27;)) {
    this.<span class="apidocCodeKeywordSpan">_loadExtract</span>(options.extract);
}

if (options.hasOwnProperty(&#x27;fileExtensions&#x27;)) {
    this._loadFileExtensions(options.fileExtensions);
}

if (options.hasOwnProperty(&#x27;excludeFiles&#x27;)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadFileExtensions" id="apidoc.element.jscs.configuration.prototype._loadFileExtensions">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadFileExtensions
        <span class="apidocSignatureSpan">(extensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadFileExtensions = function (extensions) {
    assert(
        typeof extensions === &#x27;string&#x27; || Array.isArray(extensions),
        &#x27;`fileExtensions` option requires string or array value&#x27;
    );

    this._fileExtensions = this._fileExtensions.concat(extensions).map(function(ext) {
        return ext.toLowerCase();
    });

    if (!this._isDefined(&#x27;fileExtensions&#x27;)) {
        this._definedOptions.push(&#x27;fileExtensions&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
Configuration.prototype._loadDefaults = function() {
   if (!this._isDefined(&#x27;excludeFiles&#x27;)) {
       this._loadExcludedFiles(this._defaultExcludedFileMasks);
   }

   if (!this._isDefined(&#x27;fileExtensions&#x27;)) {
       this.<span class="apidocCodeKeywordSpan">_loadFileExtensions</span>(this._defaultFileExtensions);
   }
};

/**
* Returns resulting configuration after preset is applied and options are processed.
*
* @return {Object}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadFix" id="apidoc.element.jscs.configuration.prototype._loadFix">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadFix
        <span class="apidocSignatureSpan">(fix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadFix = function (fix) {
    fix = fix === null ? false : fix;

    assert(
        typeof fix === &#x27;boolean&#x27;,
        &#x27;`fix` option requires boolean or null value&#x27;
    );

    this._fix = fix;

    if (!this._isDefined(&#x27;fix&#x27;)) {
        this._definedOptions.push(&#x27;fix&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (options.hasOwnProperty(&#x27;excludeFiles&#x27;)) {
    this._loadExcludedFiles(options.excludeFiles);
}

if (options.hasOwnProperty(&#x27;fix&#x27;)) {
    this.<span class="apidocCodeKeywordSpan">_loadFix</span>(options.fix);
}

this._loadMaxError(options);

if (options.hasOwnProperty(&#x27;es3&#x27;)) {
    this._loadES3(options.es3);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadMaxError" id="apidoc.element.jscs.configuration.prototype._loadMaxError">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadMaxError
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadMaxError = function (options) {

    // If &#x22;fix&#x22; option is enabled, set to Inifinity, otherwise this option
    // doesn&#x27;t make sense with &#x22;fix&#x22; conjunction
    if (this._fix === true) {
        this._maxErrors = Infinity;

        return;
    }

    if (!options.hasOwnProperty(&#x27;maxErrors&#x27;)) {
        return;
    }

    var maxErrors = options.maxErrors === null ? null : Number(options.maxErrors);

    assert(
        maxErrors === -1 || maxErrors &#x3e; 0 || maxErrors === null,
        &#x27;`maxErrors` option requires -1, null value or positive number&#x27;
    );

    this._maxErrors = maxErrors;

    if (!this._isDefined(&#x27;fix&#x27;)) {
        this._definedOptions.push(&#x27;fix&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._loadExcludedFiles(options.excludeFiles);
}

if (options.hasOwnProperty(&#x27;fix&#x27;)) {
    this._loadFix(options.fix);
}

this.<span class="apidocCodeKeywordSpan">_loadMaxError</span>(options);

if (options.hasOwnProperty(&#x27;es3&#x27;)) {
    this._loadES3(options.es3);
}

if (options.hasOwnProperty(&#x27;errorFilter&#x27;)) {
    this._loadErrorFilter(options.errorFilter, options.configPath);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadPlugin" id="apidoc.element.jscs.configuration.prototype._loadPlugin">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadPlugin
        <span class="apidocSignatureSpan">(plugin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadPlugin = function (plugin) {
    assert(typeof plugin === &#x27;function&#x27;, &#x27;`plugin` should be a function&#x27;);
    plugin(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    );
    this._basePath = path.dirname(options.configPath);
}

if (options.hasOwnProperty(&#x27;plugins&#x27;)) {
    assert(Array.isArray(options.plugins), &#x27;`plugins` option requires array value&#x27;);
    options.plugins.forEach(function(plugin) {
        this.<span class="apidocCodeKeywordSpan">_loadPlugin</span>(plugin, options.configPath);
    }, this);

    if (!this._isDefined(&#x27;plugins&#x27;)) {
        this._definedOptions.push(&#x27;plugins&#x27;);
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadPreset" id="apidoc.element.jscs.configuration.prototype._loadPreset">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadPreset
        <span class="apidocSignatureSpan">(preset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadPreset = function (preset) {
    if (this._loadedPresets.indexOf(preset) &#x3e; -1) {
        return;
    }

    // Do not keep adding preset from CLI (#2087)
    delete this._overrides.preset;

    this._loadedPresets.push(preset);

    // If preset is loaded from another preset - preserve the original name
    if (!this._presetName) {
        this._presetName = preset;
    }
    assert(typeof preset === &#x27;string&#x27;, &#x27;`preset` option requires string value&#x27;);

    var presetData = this._presets[preset];
    assert(Boolean(presetData), &#x27;Preset &#x22;&#x27; + preset + &#x27;&#x22; does not exist&#x27;);

    if (!this._isDefined(&#x27;preset&#x27;)) {
        this._definedOptions.push(&#x27;preset&#x27;);
    }

    // Process config from the preset
    this._processConfig(this._presets[preset]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   if (options.hasOwnProperty(&#x27;errorFilter&#x27;)) {
       this._loadErrorFilter(options.errorFilter, options.configPath);
   }

   // Apply presets
   if (options.hasOwnProperty(&#x27;preset&#x27;)) {
       this.<span class="apidocCodeKeywordSpan">_loadPreset</span>(options.preset, options.configPath);
   }

   this._loadRules(currentConfig);
};

/**
* Loads plugin data.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadRules" id="apidoc.element.jscs.configuration.prototype._loadRules">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadRules
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadRules = function (config) {
    Object.keys(config).forEach(function(key) {

        // Only rules should be processed
        if (BUILTIN_OPTIONS[key]) {
            return;
        }

        if (this._rules[key]) {
            var optionValue = config[key];

            // Disable rule it it equals &#x22;false&#x22; or &#x22;null&#x22;
            if (optionValue === null || optionValue === false) {
                delete this._ruleSettings[key];

            } else {
                this._ruleSettings[key] = config[key];
            }

        } else if (this._unsupportedRuleNames.indexOf(key) === -1) {
            this._unsupportedRuleNames.push(key);
        }
    }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }

   // Apply presets
   if (options.hasOwnProperty(&#x27;preset&#x27;)) {
       this._loadPreset(options.preset, options.configPath);
   }

   this.<span class="apidocCodeKeywordSpan">_loadRules</span>(currentConfig);
};

/**
* Loads plugin data.
*
* @param {function(Configuration)} plugin
* @protected
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._processConfig" id="apidoc.element.jscs.configuration.prototype._processConfig">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_processConfig
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processConfig = function (config) {
    var overrides = this._overrides;
    var currentConfig = {};

    // Copy configuration so original config would be intact
    copyConfiguration(config, currentConfig);

    // Override the properties
    copyConfiguration(overrides, currentConfig);

    this._errorOnRemovedOptions(currentConfig);

    // NOTE: options is a separate object to ensure that future options must be added
    // to BUILTIN_OPTIONS to work, which also assures they aren&#x27;t mistaken for a rule
    var options = this._getOptionsFromConfig(currentConfig);

    // Base path
    if (this._basePath === defaults.cwd &#x26;&#x26; options.configPath) {
        assert(
            typeof options.configPath === &#x27;string&#x27;,
            &#x27;`configPath` option requires string value&#x27;
        );
        this._basePath = path.dirname(options.configPath);
    }

    if (options.hasOwnProperty(&#x27;plugins&#x27;)) {
        assert(Array.isArray(options.plugins), &#x27;`plugins` option requires array value&#x27;);
        options.plugins.forEach(function(plugin) {
            this._loadPlugin(plugin, options.configPath);
        }, this);

        if (!this._isDefined(&#x27;plugins&#x27;)) {
            this._definedOptions.push(&#x27;plugins&#x27;);
        }
    }

    if (options.hasOwnProperty(&#x27;additionalRules&#x27;)) {
        assert(Array.isArray(options.additionalRules), &#x27;`additionalRules` option requires array value&#x27;);
        options.additionalRules.forEach(function(rule) {
            this._loadAdditionalRule(rule, options.configPath);
        }, this);

        if (!this._isDefined(&#x27;additionalRules&#x27;)) {
            this._definedOptions.push(&#x27;additionalRules&#x27;);
        }
    }

    if (options.hasOwnProperty(&#x27;extract&#x27;)) {
        this._loadExtract(options.extract);
    }

    if (options.hasOwnProperty(&#x27;fileExtensions&#x27;)) {
        this._loadFileExtensions(options.fileExtensions);
    }

    if (options.hasOwnProperty(&#x27;excludeFiles&#x27;)) {
        this._loadExcludedFiles(options.excludeFiles);
    }

    if (options.hasOwnProperty(&#x27;fix&#x27;)) {
        this._loadFix(options.fix);
    }

    this._loadMaxError(options);

    if (options.hasOwnProperty(&#x27;es3&#x27;)) {
        this._loadES3(options.es3);
    }

    if (options.hasOwnProperty(&#x27;errorFilter&#x27;)) {
        this._loadErrorFilter(options.errorFilter, options.configPath);
    }

    // Apply presets
    if (options.hasOwnProperty(&#x27;preset&#x27;)) {
        this._loadPreset(options.preset, options.configPath);
    }

    this._loadRules(currentConfig);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Load settings from a configuration.
 *
 * @param {Object} config
 */
Configuration.prototype.load = function(config) {

    // Load all the options
    this.<span class="apidocCodeKeywordSpan">_processConfig</span>(config);

    // Load defaults if they weren&#x27;t set
    this._loadDefaults(config);

    // Load and apply all the rules
    this._useRules();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._useRules" id="apidoc.element.jscs.configuration.prototype._useRules">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_useRules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_useRules = function () {
    this._configuredRules = [];

    Object.keys(this._ruleSettings).forEach(function(optionName) {
        var rule = this._rules[optionName];
        rule.configure(this._ruleSettings[optionName]);
        this._configuredRules.push(rule);
    }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   // Load all the options
   this._processConfig(config);

   // Load defaults if they weren&#x27;t set
   this._loadDefaults(config);

   // Load and apply all the rules
   this.<span class="apidocCodeKeywordSpan">_useRules</span>();
};

/**
* Load default values for options which were not defined
*
* @private
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getBasePath" id="apidoc.element.jscs.configuration.prototype.getBasePath">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getBasePath
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBasePath = function () {
    return this._basePath;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param  {String} path - The path containing file(s) used to guide the configuration
 *
 * @return {Promise} Resolved with the generated, JSCS configuration
 */
Generator.prototype.generate = function(path) {
var checker = getChecker();
var _path = utils.normalizePath(path, checker.getConfiguration().<span class="apidocCodeKeywordSpan">getBasePath</span>());
var presetNames = Object.keys(checker.getConfiguration().getRegisteredPresets());
var statsForPresets;

console.log(&#x27;Checking&#x27;, _path, &#x27;against the presets&#x27;);

return Vow
.all(presetNames.map(this._checkAgainstPreset.bind(this, _path)))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getConfiguredRule" id="apidoc.element.jscs.configuration.prototype.getConfiguredRule">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getConfiguredRule
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConfiguredRule = function (name) {
    return this._configuredRules.filter(function(rule) {
        return rule.getOptionName() === name;
    })[0] || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {JsFile} file
     * @param {Error} error
     * @return {Boolean} whether the correction was carried out
     * @private
     */
    _fixSpecificError: function(file, error) {
var configuration = this.getConfiguration();
var instance = configuration.<span class="apidocCodeKeywordSpan">getConfiguredRule</span>(error.rule);

if (instance &#x26;&#x26; instance._fix) {
    // &#x22;error.fixed = true&#x22; should go first, so rule can
    // decide for itself (with &#x22;error.fixed = false&#x22;)
    // if it can fix this particular error
    error.fixed = true;
    instance._fix(file, error);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getConfiguredRules" id="apidoc.element.jscs.configuration.prototype.getConfiguredRules">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getConfiguredRules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConfiguredRules = function () {
    return this._configuredRules;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Loads configuration from JS Object. Activates and configures required rules.
 *
 * @param {Object} config
 */
configure: function(config) {
    this._configuration.load(config);

    this._configuredRules = this._configuration.<span class="apidocCodeKeywordSpan">getConfiguredRules</span>();
    this._maxErrors = this._configuration.getMaxErrors();
},

/**
 * Checks file provided with a string.
 *
 * @param {String} source
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getErrorFilter" id="apidoc.element.jscs.configuration.prototype.getErrorFilter">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getErrorFilter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getErrorFilter = function () {
    return this._errorFilter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @protected
     */
    _checkJsFile: function(file, errors) {
        if (this._maxErrorsExceeded) {
return;
        }

        var errorFilter = this._configuration.<span class="apidocCodeKeywordSpan">getErrorFilter</span>();

        this._configuredRules.forEach(function(rule) {
errors.setCurrentRule(rule.getOptionName());

try {
    rule.check(file, errors);
} catch (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getExcludedFileMasks" id="apidoc.element.jscs.configuration.prototype.getExcludedFileMasks">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getExcludedFileMasks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getExcludedFileMasks = function () {
    return this._excludedFileMasks;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getExtractFileMasks" id="apidoc.element.jscs.configuration.prototype.getExtractFileMasks">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getExtractFileMasks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getExtractFileMasks = function () {
    return this._extractFileMasks;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getFileExtensions" id="apidoc.element.jscs.configuration.prototype.getFileExtensions">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getFileExtensions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFileExtensions = function () {
    return this._fileExtensions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Returns true if the file extension matches a file extension to process.
 *
 * @returns {Boolean}
 */
Configuration.prototype.hasCorrectExtension = function(testPath) {
    var extension = path.extname(testPath).toLowerCase();
    var basename = path.basename(testPath).toLowerCase();
    var fileExtensions = this.<span class="apidocCodeKeywordSpan">getFileExtensions</span>();

    return !(
        fileExtensions.indexOf(extension) &#x3c; 0 &#x26;&#x26;
        fileExtensions.indexOf(basename) &#x3c; 0 &#x26;&#x26;
        fileExtensions.indexOf(&#x27;*&#x27;) &#x3c; 0
    );
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getFix" id="apidoc.element.jscs.configuration.prototype.getFix">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getFix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFix = function () {
    return !!this._fix;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Execute checker depending on config value either checks or checks and fixes
*
* @see Checker#checkPath/Checker#fixPath
*/
Checker.prototype.execute = function() {
   var method = this._configuration.<span class="apidocCodeKeywordSpan">getFix</span>() === true ? this.fixPath : this.checkPath
;

   return method.apply(this, arguments);
};

/**
* Checks single file.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getMaxErrors" id="apidoc.element.jscs.configuration.prototype.getMaxErrors">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getMaxErrors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMaxErrors = function () {
    return this._maxErrors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Object} config
 */
configure: function(config) {
    this._configuration.load(config);

    this._configuredRules = this._configuration.getConfiguredRules();
    this._maxErrors = this._configuration.<span class="apidocCodeKeywordSpan">getMaxErrors</span>();
},

/**
 * Checks file provided with a string.
 *
 * @param {String} source
 * @param {String} [filename=&#x27;input&#x27;]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getPresetName" id="apidoc.element.jscs.configuration.prototype.getPresetName">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getPresetName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPresetName = function () {
    return this._presetName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getProcessedConfig" id="apidoc.element.jscs.configuration.prototype.getProcessedConfig">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getProcessedConfig
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getProcessedConfig = function () {
    var result = {};
    Object.keys(this._ruleSettings).forEach(function(key) {
        result[key] = this._ruleSettings[key];
    }, this);
    result.excludeFiles = this._excludedFileMasks;
    result.fileExtensions = this._fileExtensions;
    result.extract = this._extractFileMasks;
    result.maxErrors = this._maxErrors;
    result.preset = this._presetName;
    result.es3 = this._es3Enabled;
    result.errorFilter = this._errorFilter;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Get processed config.
 *
 * @return {Object}
 */
getProcessedConfig: function() {
    return this._configuration.<span class="apidocCodeKeywordSpan">getProcessedConfig</span>();
},

/**
 * Loads configuration from JS Object. Activates and configures required rules.
 *
 * @param {Object} config
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getRegisteredPresets" id="apidoc.element.jscs.configuration.prototype.getRegisteredPresets">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getRegisteredPresets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRegisteredPresets = function () {
    return this._presets;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} path - The path containing file(s) used to guide the configuration
 *
 * @return {Promise} Resolved with the generated, JSCS configuration
 */
Generator.prototype.generate = function(path) {
var checker = getChecker();
var _path = utils.normalizePath(path, checker.getConfiguration().getBasePath());
var presetNames = Object.keys(checker.getConfiguration().<span class="apidocCodeKeywordSpan">getRegisteredPresets</span>());
var statsForPresets;

console.log(&#x27;Checking&#x27;, _path, &#x27;against the presets&#x27;);

return Vow
.all(presetNames.map(this._checkAgainstPreset.bind(this, _path)))
.then(function(resultsPerPreset) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getRegisteredRules" id="apidoc.element.jscs.configuration.prototype.getRegisteredRules">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getRegisteredRules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRegisteredRules = function () {
    var rules = this._rules;
    return Object.keys(rules).map(function(ruleOptionName) {
        return rules[ruleOptionName];
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getUnsupportedRuleNames" id="apidoc.element.jscs.configuration.prototype.getUnsupportedRuleNames">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getUnsupportedRuleNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getUnsupportedRuleNames = function () {
    return this._unsupportedRuleNames;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        rule.check(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.<span class="apidocCodeKeywordSpan">getUnsupportedRuleNames</span>().forEach(function(rulename) {
    errors.add(&#x27;Unsupported rule: &#x27; + rulename, file.getProgram());
});

var program = file.getProgram();
var tokenIndex = new TokenIndex(program.getFirstToken());
errors.calculateErrorLocations(tokenIndex);
errors.filter(function(error) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.hasCorrectExtension" id="apidoc.element.jscs.configuration.prototype.hasCorrectExtension">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>hasCorrectExtension
        <span class="apidocSignatureSpan">(testPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasCorrectExtension = function (testPath) {
    var extension = path.extname(testPath).toLowerCase();
    var basename = path.basename(testPath).toLowerCase();
    var fileExtensions = this.getFileExtensions();

    return !(
        fileExtensions.indexOf(extension) &#x3c; 0 &#x26;&#x26;
        fileExtensions.indexOf(basename) &#x3c; 0 &#x26;&#x26;
        fileExtensions.indexOf(&#x27;*&#x27;) &#x3c; 0
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }

            return vowFs.stat(fullname).then(function(stat) {
if (stat.isDirectory()) {
    return this._processDirectory(fullname, fileHandler);
}

if (!this._configuration.<span class="apidocCodeKeywordSpan">hasCorrectExtension</span>(fullname)) {
    if (!this._configuration.shouldExtractFile(fullname)) {
        return [];
    }

    return this.extractFile(fullname);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.hasPreset" id="apidoc.element.jscs.configuration.prototype.hasPreset">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>hasPreset
        <span class="apidocSignatureSpan">(presetName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasPreset = function (presetName) {
    return this._presets.hasOwnProperty(presetName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.isES3Enabled" id="apidoc.element.jscs.configuration.prototype.isES3Enabled">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>isES3Enabled
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isES3Enabled = function () {
    return this._es3Enabled;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {String} source
 * @private
 */
_createJsFileInstance: function(filename, source) {
    return new JsFile({
        filename: filename,
        source: source,
        es3: this._configuration.<span class="apidocCodeKeywordSpan">isES3Enabled</span>()
    });
},

/**
 * Checks and fix file provided with a string.
 *
 * @param {String} source
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.isFileExcluded" id="apidoc.element.jscs.configuration.prototype.isFileExcluded">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>isFileExcluded
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFileExcluded = function (filePath) {
    filePath = path.resolve(filePath);

    return this._excludedFileMatchers.some(function(matcher) {
        return matcher.match(filePath);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Checks single file.
 *
 * @param {String} path
 * @returns {Promise.&#x3c;Errors&#x3e;}
 */
Checker.prototype.checkFile = function(path) {
    if (this._configuration.<span class="apidocCodeKeywordSpan">isFileExcluded</span>(path)) {
        return Vow.resolve(null);
    }

    return vowFs.read(path, &#x27;utf8&#x27;).then(function(data) {
        return this.checkString(data, path);
    }, this);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.load" id="apidoc.element.jscs.configuration.prototype.load">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>load
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (config) {

    // Load all the options
    this._processConfig(config);

    // Load defaults if they weren&#x27;t set
    this._loadDefaults(config);

    // Load and apply all the rules
    this._useRules();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

promise.always(function(status) {
    exit(status.valueOf());
});

try {
    config = configFile.<span class="apidocCodeKeywordSpan">load</span>(program.config);
} catch (e) {
    console.error(&#x27;Config source is corrupted -&#x27;, e.toString());
    defer.reject(5);

    return returnArgs;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.override" id="apidoc.element.jscs.configuration.prototype.override">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>override
        <span class="apidocSignatureSpan">(overrides)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">override = function (overrides) {
    Object.keys(overrides).forEach(function(key) {
        this._overrides[key] = overrides[key];
    }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   OVERRIDE_OPTIONS.forEach(function(option) {
       if (option in program) {
           overrides[option] = program[option];
       }
   });

   this.<span class="apidocCodeKeywordSpan">override</span>(overrides);
};

/**
* Load external module.
*
* @param {String|null} external - path (relative or absolute) or name to the external module
* @param {String} type - type of the module
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.registerDefaultPresets" id="apidoc.element.jscs.configuration.prototype.registerDefaultPresets">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>registerDefaultPresets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerDefaultPresets = function () {
    var dir = path.join(__dirname, &#x27;../../presets/&#x27;);

    fs.readdirSync(dir).forEach(function(preset) {
        var name = preset.split(&#x27;.&#x27;)[0];
        var p = path.join(dir, preset);

        this.registerPreset(name, require(p));
    }, this);

    this.registerPreset(&#x27;wikimedia&#x27;, require(&#x27;jscs-preset-wikimedia&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var StringChecker = function() {
this._configuredRules = [];

this._errorsFound = 0;
this._maxErrorsExceeded = false;

this._configuration = this._createConfiguration();
this._configuration.<span class="apidocCodeKeywordSpan">registerDefaultPresets</span>();
};

StringChecker.prototype = {
/**
 * Registers single Code Style checking rule.
 *
 * @param {Rule} rule
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.registerDefaultRules" id="apidoc.element.jscs.configuration.prototype.registerDefaultRules">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>registerDefaultRules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerDefaultRules = function () {
    var dir = path.join(__dirname, &#x27;../rules&#x27;);

    fs.readdirSync(dir).forEach(function(rule) {
        this.registerRule(
            require(path.join(dir, rule))
        );
    }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// To run autoconfigure over all errors in the path
if (program.autoConfigure) {
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().<span class="apidocCodeKeywordSpan">registerDefaultRules</span>();

try {
    checker.configure(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.registerPreset" id="apidoc.element.jscs.configuration.prototype.registerPreset">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>registerPreset
        <span class="apidocSignatureSpan">(presetName, presetConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerPreset = function (presetName, presetConfig) {
    assert(_.isPlainObject(presetConfig), &#x27;Preset should be an object&#x27;);

    for (var key in presetConfig) {
        assert(typeof presetConfig[key] !== &#x27;function&#x27;, &#x27;Preset should be an JSON object&#x27;);
    }

    this._presets[presetName] = presetConfig;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Configuration.prototype.registerDefaultPresets = function() {
    var dir = path.join(__dirname, &#x27;../../presets/&#x27;);

    fs.readdirSync(dir).forEach(function(preset) {
        var name = preset.split(&#x27;.&#x27;)[0];
        var p = path.join(dir, preset);

        this.<span class="apidocCodeKeywordSpan">registerPreset</span>(name, require(p));
    }, this);

    this.registerPreset(&#x27;wikimedia&#x27;, require(&#x27;jscs-preset-wikimedia&#x27;));
};

module.exports = Configuration;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.registerRule" id="apidoc.element.jscs.configuration.prototype.registerRule">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>registerRule
        <span class="apidocSignatureSpan">(rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerRule = function (rule) {
    if (typeof rule === &#x27;function&#x27;) {
        var RuleClass = rule;
        rule = new RuleClass();
    }

    var optionName = rule.getOptionName();
    assert(!this._rules.hasOwnProperty(optionName), &#x27;Rule &#x22;&#x27; + optionName + &#x27;&#x22; is already registered&#x27;);
    this._rules[optionName] = rule;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
StringChecker.prototype = {
/**
 * Registers single Code Style checking rule.
 *
 * @param {Rule} rule
 */
registerRule: function(rule) {
    this._configuration.<span class="apidocCodeKeywordSpan">registerRule</span>(rule);
},

/**
 * Registers built-in Code Style checking rules.
 */
registerDefaultRules: function() {
    this._configuration.registerDefaultRules();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.shouldExtractFile" id="apidoc.element.jscs.configuration.prototype.shouldExtractFile">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>shouldExtractFile
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shouldExtractFile = function (filePath) {
    filePath = path.resolve(filePath);
    return this._extractFileMatchers.some(function(matcher) {
        return matcher.match(filePath);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {Promise.&#x3c;Errors&#x3e;}
 */
Checker.prototype.extractFile = function(path) {
    if (this._configuration.isFileExcluded(path)) {
return Vow.resolve(null);
    }

    if (!this._configuration.<span class="apidocCodeKeywordSpan">shouldExtractFile</span>(path)) {
return Vow.resolve(null);
    }

    return vowFs.read(path, &#x27;utf8&#x27;).then(function(data) {
var result = extractJs(path, data);

result.sources.forEach(function(script) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.usePlugin" id="apidoc.element.jscs.configuration.prototype.usePlugin">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>usePlugin
        <span class="apidocSignatureSpan">(plugin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">usePlugin = function (plugin) {
    this._loadPlugin(plugin);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_anonymous_functions" id="apidoc.module.jscs.disallow_anonymous_functions">module jscs.disallow_anonymous_functions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_anonymous_functions.disallow_anonymous_functions" id="apidoc.element.jscs.disallow_anonymous_functions.disallow_anonymous_functions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_anonymous_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_anonymous_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_anonymous_functions.prototype" id="apidoc.module.jscs.disallow_anonymous_functions.prototype">module jscs.disallow_anonymous_functions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_anonymous_functions.prototype.check" id="apidoc.element.jscs.disallow_anonymous_functions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_anonymous_functions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType([&#x27;FunctionExpression&#x27;, &#x27;FunctionDeclaration&#x27;], function(node) {
        if (node.id === null) {
            errors.add(&#x27;Anonymous functions need to be named&#x27;, node);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_anonymous_functions.prototype.configure" id="apidoc.element.jscs.disallow_anonymous_functions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_anonymous_functions.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_anonymous_functions.prototype.getOptionName" id="apidoc.element.jscs.disallow_anonymous_functions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_anonymous_functions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowAnonymousFunctions&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_array_destructuring_return" id="apidoc.module.jscs.disallow_array_destructuring_return">module jscs.disallow_array_destructuring_return</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_array_destructuring_return.disallow_array_destructuring_return" id="apidoc.element.jscs.disallow_array_destructuring_return.disallow_array_destructuring_return">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_array_destructuring_return
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_array_destructuring_return = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_array_destructuring_return.prototype" id="apidoc.module.jscs.disallow_array_destructuring_return.prototype">module jscs.disallow_array_destructuring_return.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_array_destructuring_return.prototype.check" id="apidoc.element.jscs.disallow_array_destructuring_return.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_array_destructuring_return.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var addError = function(node) {
        errors.add(
            &#x27;Array destructuring is not allowed for return, &#x27; +
            &#x27;use object destructuring instead&#x27;,
            node
        );
    };

    var isViolationDetected = function(maybeArrayPattern, maybeCallExpression) {

        return maybeCallExpression &#x26;&#x26; maybeCallExpression.type === &#x27;CallExpression&#x27; &#x26;&#x26;
            maybeArrayPattern &#x26;&#x26; maybeArrayPattern.type === &#x27;ArrayPattern&#x27;;
    };

    file.iterateNodesByType([&#x27;VariableDeclaration&#x27;, &#x27;AssignmentExpression&#x27;], function(node) {

        if (node.type === &#x27;VariableDeclaration&#x27;) {
            node.declarations.forEach(function(declaration) {
                if (!isViolationDetected(declaration.id, declaration.init)) {
                    return;
                }

                addError(declaration.init);
            });
        }

        if (node.type === &#x27;AssignmentExpression&#x27;) {
            if (!isViolationDetected(node.left, node.right)) {
                return;
            }

            addError(node.right);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_array_destructuring_return.prototype.configure" id="apidoc.element.jscs.disallow_array_destructuring_return.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_array_destructuring_return.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_array_destructuring_return.prototype.getOptionName" id="apidoc.element.jscs.disallow_array_destructuring_return.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_array_destructuring_return.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowArrayDestructuringReturn&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_arrow_functions" id="apidoc.module.jscs.disallow_arrow_functions">module jscs.disallow_arrow_functions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_arrow_functions.disallow_arrow_functions" id="apidoc.element.jscs.disallow_arrow_functions.disallow_arrow_functions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_arrow_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_arrow_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_arrow_functions.prototype" id="apidoc.module.jscs.disallow_arrow_functions.prototype">module jscs.disallow_arrow_functions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_arrow_functions.prototype.check" id="apidoc.element.jscs.disallow_arrow_functions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_arrow_functions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType([&#x27;ArrowFunctionExpression&#x27;], function(node) {
        errors.add(&#x27;Do not use arrow functions&#x27;, node);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_arrow_functions.prototype.configure" id="apidoc.element.jscs.disallow_arrow_functions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_arrow_functions.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_arrow_functions.prototype.getOptionName" id="apidoc.element.jscs.disallow_arrow_functions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_arrow_functions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowArrowFunctions&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_capitalized_comments" id="apidoc.module.jscs.disallow_capitalized_comments">module jscs.disallow_capitalized_comments</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_capitalized_comments.disallow_capitalized_comments" id="apidoc.element.jscs.disallow_capitalized_comments.disallow_capitalized_comments">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_capitalized_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_capitalized_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_capitalized_comments.prototype" id="apidoc.module.jscs.disallow_capitalized_comments.prototype">module jscs.disallow_capitalized_comments.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_capitalized_comments.prototype.check" id="apidoc.element.jscs.disallow_capitalized_comments.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_capitalized_comments.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var letterPattern = require(&#x27;../../patterns/L&#x27;);
    var lowerCasePattern = require(&#x27;../../patterns/Ll&#x27;);

    file.iterateTokensByType([&#x27;CommentLine&#x27;, &#x27;CommentBlock&#x27;], function(comment) {
        var stripped = comment.value.replace(/[\n\s\*]/g, &#x27;&#x27;);
        var firstChar = stripped[0];

        if (letterPattern.test(firstChar) &#x26;&#x26; !lowerCasePattern.test(firstChar)) {
            errors.add(
                &#x27;Comments must start with a lowercase letter&#x27;,
                comment
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_capitalized_comments.prototype.configure" id="apidoc.element.jscs.disallow_capitalized_comments.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_capitalized_comments.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_capitalized_comments.prototype.getOptionName" id="apidoc.element.jscs.disallow_capitalized_comments.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_capitalized_comments.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowCapitalizedComments&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_comma_before_line_break" id="apidoc.module.jscs.disallow_comma_before_line_break">module jscs.disallow_comma_before_line_break</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_comma_before_line_break.disallow_comma_before_line_break" id="apidoc.element.jscs.disallow_comma_before_line_break.disallow_comma_before_line_break">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_comma_before_line_break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_comma_before_line_break = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_comma_before_line_break.prototype" id="apidoc.module.jscs.disallow_comma_before_line_break.prototype">module jscs.disallow_comma_before_line_break.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_comma_before_line_break.prototype.check" id="apidoc.element.jscs.disallow_comma_before_line_break.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_comma_before_line_break.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptFunction = this._exceptFunction;

    function canSkip(token) {
        var node = token.parentElement;
        if (node.getNewlineCount() === 0) {
            return true;
        }

        // exception for function params
        if (
            node.params &#x26;&#x26;
            file.isOnTheSameLine(node.params[0], node.params[node.params.length - 1])
        ) {
            return true;
        }

        // See #1841
        if (!exceptFunction || !node.properties) {
            return false;
        }

        return node.properties.some(function(property) {
            return property.value.type === &#x27;FunctionExpression&#x27;;
        });
    }

    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;,&#x27;, function(token) {
        var nextToken = token.getNextCodeToken();

        if (canSkip(token) || nextToken.value === &#x27;,&#x27;) {
            return;
        }

        errors.assert.sameLine({
            token: token,
            nextToken: nextToken,
            message: &#x27;Commas should be placed on the same line as value&#x27;
        });

        errors.assert.differentLine({
            token: token.getPreviousCodeToken(),
            nextToken: token,
            message: &#x27;Commas should be placed on new line&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_comma_before_line_break.prototype.configure" id="apidoc.element.jscs.disallow_comma_before_line_break.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_comma_before_line_break.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var optionName = this.getOptionName();

    if (typeof options !== &#x27;object&#x27;) {
        assert(
            options === true,
            optionName + &#x27; option requires either a true value or an object&#x27;
        );

        var _options = {allExcept: []};
        return this.configure(_options);
    }

    assert(
        Array.isArray(options.allExcept),
        &#x27;Property `allExcept` in &#x27; + optionName + &#x27; should be an array of strings&#x27;
    );

    this._exceptFunction = options.allExcept.indexOf(&#x27;function&#x27;) &#x3e; -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_comma_before_line_break.prototype.getOptionName" id="apidoc.element.jscs.disallow_comma_before_line_break.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_comma_before_line_break.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowCommaBeforeLineBreak&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_curly_braces" id="apidoc.module.jscs.disallow_curly_braces">module jscs.disallow_curly_braces</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_curly_braces.disallow_curly_braces" id="apidoc.element.jscs.disallow_curly_braces.disallow_curly_braces">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_curly_braces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_curly_braces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_curly_braces.prototype" id="apidoc.module.jscs.disallow_curly_braces.prototype">module jscs.disallow_curly_braces.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_curly_braces.prototype.check" id="apidoc.element.jscs.disallow_curly_braces.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_curly_braces.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {

    function isSingleBlockStatement(node) {
        return node &#x26;&#x26; node.type === &#x27;BlockStatement&#x27; &#x26;&#x26;
        node.body.length === 1;
    }

    function addError(typeString, entity) {
        errors.add(
            typeString + &#x27; statement with extra curly braces&#x27;,
            entity
        );
    }

    function checkBody(type, typeString) {
        file.iterateNodesByType(type, function(node) {
            if (isSingleBlockStatement(node.body)) {
                addError(typeString, node);
            }
        });
    }

    var typeIndex = this._typeIndex;

    if (typeIndex.if || typeIndex.else) {
        file.iterateNodesByType(&#x27;IfStatement&#x27;, function(node) {
            if (typeIndex.if &#x26;&#x26; isSingleBlockStatement(node.consequent)) {
                addError(&#x27;If&#x27;, node);
            }
            if (typeIndex.else &#x26;&#x26; isSingleBlockStatement(node.alternate)) {
                addError(&#x27;Else&#x27;, node.alternate.getFirstToken());
            }
        });
    }

    if (typeIndex.while) {
        checkBody(&#x27;WhileStatement&#x27;, &#x27;While&#x27;);
    }

    if (typeIndex.for) {
        checkBody(&#x27;ForStatement&#x27;, &#x27;For&#x27;);
        checkBody(&#x27;ForInStatement&#x27;, &#x27;For in&#x27;);
        checkBody(&#x27;ForOfStatement&#x27;, &#x27;For of&#x27;);
    }

    if (typeIndex.do) {
        checkBody(&#x27;DoWhileStatement&#x27;, &#x27;Do while&#x27;);
    }

    if (typeIndex.with) {
        checkBody(&#x27;WithStatement&#x27;, &#x27;With&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_curly_braces.prototype.configure" id="apidoc.element.jscs.disallow_curly_braces.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_curly_braces.prototype.</span>configure
        <span class="apidocSignatureSpan">(statementTypes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (statementTypes) {
    assert(
        Array.isArray(statementTypes) || statementTypes === true,
        this.getOptionName() + &#x27; option requires array or true value&#x27;
    );

    if (statementTypes === true) {
        statementTypes = defaultKeywords;
    }

    this._typeIndex = {};
    statementTypes.forEach(function(type) {
        this._typeIndex[type] = true;
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_curly_braces.prototype.getOptionName" id="apidoc.element.jscs.disallow_curly_braces.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_curly_braces.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowCurlyBraces&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_dangling_underscores" id="apidoc.module.jscs.disallow_dangling_underscores">module jscs.disallow_dangling_underscores</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_dangling_underscores.disallow_dangling_underscores" id="apidoc.element.jscs.disallow_dangling_underscores.disallow_dangling_underscores">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_dangling_underscores
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_dangling_underscores = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_dangling_underscores.prototype" id="apidoc.module.jscs.disallow_dangling_underscores.prototype">module jscs.disallow_dangling_underscores.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_dangling_underscores.prototype.check" id="apidoc.element.jscs.disallow_dangling_underscores.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_dangling_underscores.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var allowedIdentifiers = this._identifierIndex;

    file.iterateTokensByType(&#x27;Identifier&#x27;, function(token) {
        var value = token.value;

        if ((value[0] === &#x27;_&#x27; || value.slice(-1) === &#x27;_&#x27;) &#x26;&#x26;
            allowedIdentifiers.indexOf(value) &#x3c; 0
        ) {
            errors.add(
                &#x27;Invalid dangling underscore found&#x27;,
                token
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_dangling_underscores.prototype.configure" id="apidoc.element.jscs.disallow_dangling_underscores.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_dangling_underscores.prototype.</span>configure
        <span class="apidocSignatureSpan">(identifiers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (identifiers) {
    assert(
        identifiers === true ||
        typeof identifiers === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option requires the value `true` &#x27; +
        &#x27;or an object with String[] `allExcept` property&#x27;
    );

    // verify first item in `allExcept` property in object (if it&#x27;s an object)
    assert(
        typeof identifiers !== &#x27;object&#x27; ||
        Array.isArray(identifiers.allExcept) &#x26;&#x26;
        typeof identifiers.allExcept[0] === &#x27;string&#x27;,
        &#x27;Property `allExcept` in &#x27; + this.getOptionName() + &#x27; should be an array of strings&#x27;
    );

    var isTrue = identifiers === true;
    var defaultIdentifiers = [
        &#x27;__proto__&#x27;,
        &#x27;_&#x27;,
        &#x27;__dirname&#x27;,
        &#x27;__filename&#x27;,
        &#x27;super_&#x27;
    ];

    if (isTrue) {
        identifiers = defaultIdentifiers;
    } else {
        identifiers = (identifiers.allExcept).concat(defaultIdentifiers);
    }

    this._identifierIndex = identifiers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_dangling_underscores.prototype.getOptionName" id="apidoc.element.jscs.disallow_dangling_underscores.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_dangling_underscores.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowDanglingUnderscores&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_empty_blocks" id="apidoc.module.jscs.disallow_empty_blocks">module jscs.disallow_empty_blocks</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_empty_blocks.disallow_empty_blocks" id="apidoc.element.jscs.disallow_empty_blocks.disallow_empty_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_empty_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_empty_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_empty_blocks.prototype" id="apidoc.module.jscs.disallow_empty_blocks.prototype">module jscs.disallow_empty_blocks.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_empty_blocks.prototype.check" id="apidoc.element.jscs.disallow_empty_blocks.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_empty_blocks.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptComments = this._exceptComments;

    function canSkip(token) {
        if (!exceptComments) {
            return false;
        }
        var canSkipToken = false;
        var tokenLoc = token.getLoc();
        file.getComments().forEach(function(comment) {
            var commentLoc = comment.getLoc();
            if (commentLoc.start.line &#x3e;= tokenLoc.start.line &#x26;&#x26;
                commentLoc.end.line &#x3c;= tokenLoc.end.line) {
                canSkipToken = true;
            }
        });
        return canSkipToken;
    }

    file.iterateNodesByType(&#x27;BlockStatement&#x27;, function(node) {
        if (node.body.length) {
            return true;
        }

        if (canSkip(node)) {
            return true;
        }

        if (node.parentElement.type !== &#x27;CatchClause&#x27; &#x26;&#x26;
            node.parentElement.type !== &#x27;FunctionDeclaration&#x27; &#x26;&#x26;
            node.parentElement.type !== &#x27;FunctionExpression&#x27; &#x26;&#x26;
            node.parentElement.type !== &#x27;ArrowFunctionExpression&#x27; &#x26;&#x26;
            node.parentElement.type !== &#x27;ObjectMethod&#x27;) {
            errors.add(&#x27;Empty block found&#x27;, node.lastChild);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_empty_blocks.prototype.configure" id="apidoc.element.jscs.disallow_empty_blocks.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_empty_blocks.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var optionName = this.getOptionName();

    if (typeof options !== &#x27;object&#x27;) {
        assert(
            options === true,
            optionName + &#x27; option requires a true value or an object like: { allExcept: [\&#x27;comments\&#x27;] }&#x27;
        );

        var _options = {
            allExcept: []
        };
        return this.configure(_options);
    }

    assert(
        Array.isArray(options.allExcept),
        &#x27;Property `allExcept` in &#x27; + optionName + &#x27; should be an array of strings&#x27;
    );

    this._exceptComments = options.allExcept.indexOf(&#x27;comments&#x27;) &#x3e; -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_empty_blocks.prototype.getOptionName" id="apidoc.element.jscs.disallow_empty_blocks.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_empty_blocks.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowEmptyBlocks&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_function_declarations" id="apidoc.module.jscs.disallow_function_declarations">module jscs.disallow_function_declarations</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_function_declarations.disallow_function_declarations" id="apidoc.element.jscs.disallow_function_declarations.disallow_function_declarations">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_function_declarations
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_function_declarations = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_function_declarations.prototype" id="apidoc.module.jscs.disallow_function_declarations.prototype">module jscs.disallow_function_declarations.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_function_declarations.prototype.check" id="apidoc.element.jscs.disallow_function_declarations.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_function_declarations.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;FunctionDeclaration&#x27;, function(node) {
        errors.add(&#x27;Illegal function declaration&#x27;, node);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_function_declarations.prototype.configure" id="apidoc.element.jscs.disallow_function_declarations.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_function_declarations.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_function_declarations.prototype.getOptionName" id="apidoc.element.jscs.disallow_function_declarations.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_function_declarations.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowFunctionDeclarations&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_identical_destructuring_names" id="apidoc.module.jscs.disallow_identical_destructuring_names">module jscs.disallow_identical_destructuring_names</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_identical_destructuring_names.disallow_identical_destructuring_names" id="apidoc.element.jscs.disallow_identical_destructuring_names.disallow_identical_destructuring_names">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_identical_destructuring_names
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_identical_destructuring_names = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_identical_destructuring_names.prototype" id="apidoc.module.jscs.disallow_identical_destructuring_names.prototype">module jscs.disallow_identical_destructuring_names.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_identical_destructuring_names.prototype.check" id="apidoc.element.jscs.disallow_identical_destructuring_names.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_identical_destructuring_names.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType([&#x27;ObjectPattern&#x27;], function(node) {
        var props = node.properties;
        for (var i = 0; i &#x3c; props.length; i++) {
            var prop = props[i];
            if (prop.type === &#x27;ObjectProperty&#x27; &#x26;&#x26; !prop.shorthand &#x26;&#x26; !prop.computed &#x26;&#x26;
                prop.key.name === prop.value.name) {
                errors.add(&#x27;Use the shorthand form of destructuring instead&#x27;, prop);
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_identical_destructuring_names.prototype.configure" id="apidoc.element.jscs.disallow_identical_destructuring_names.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_identical_destructuring_names.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_identical_destructuring_names.prototype.getOptionName" id="apidoc.element.jscs.disallow_identical_destructuring_names.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_identical_destructuring_names.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowIdenticalDestructuringNames&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_identifier_names" id="apidoc.module.jscs.disallow_identifier_names">module jscs.disallow_identifier_names</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_identifier_names.disallow_identifier_names" id="apidoc.element.jscs.disallow_identifier_names.disallow_identifier_names">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_identifier_names
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_identifier_names = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_identifier_names.prototype" id="apidoc.module.jscs.disallow_identifier_names.prototype">module jscs.disallow_identifier_names.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_identifier_names.prototype.check" id="apidoc.element.jscs.disallow_identifier_names.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_identifier_names.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var disallowedIdentifiers = this._identifierIndex;

    file.iterateNodesByType(&#x27;Identifier&#x27;, function(node) {
        if (Object.prototype.hasOwnProperty.call(disallowedIdentifiers, node.name)) {
            errors.add(&#x27;Illegal Identifier name: &#x27; + node.name, node);
        }
    });

    file.iterateNodesByType(&#x27;MemberExpression&#x27;, function(node) {
        if (node.property.type === &#x27;StringLiteral&#x27;) {
            if (Object.prototype.hasOwnProperty.call(disallowedIdentifiers, node.property.value)) {
                errors.add(&#x27;Illegal Identifier name: &#x27; + node.property.value, node.property);
            }
        }
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_identifier_names.prototype.configure" id="apidoc.element.jscs.disallow_identifier_names.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_identifier_names.prototype.</span>configure
        <span class="apidocSignatureSpan">(identifiers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (identifiers) {
    assert(
        Array.isArray(identifiers),
        &#x27;disallowIdentifierNames option requires an array&#x27;
    );

    this._identifierIndex = {};
    for (var i = 0, l = identifiers.length; i &#x3c; l; i++) {
        this._identifierIndex[identifiers[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_identifier_names.prototype.getOptionName" id="apidoc.element.jscs.disallow_identifier_names.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_identifier_names.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowIdentifierNames&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_implicit_type_conversion" id="apidoc.module.jscs.disallow_implicit_type_conversion">module jscs.disallow_implicit_type_conversion</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_implicit_type_conversion.disallow_implicit_type_conversion" id="apidoc.element.jscs.disallow_implicit_type_conversion.disallow_implicit_type_conversion">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_implicit_type_conversion
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_implicit_type_conversion = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_implicit_type_conversion.prototype" id="apidoc.module.jscs.disallow_implicit_type_conversion.prototype">module jscs.disallow_implicit_type_conversion.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_implicit_type_conversion.prototype.check" id="apidoc.element.jscs.disallow_implicit_type_conversion.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_implicit_type_conversion.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var types = this._typeIndex;
    if (types.numeric || types.boolean || types.binary) {
        file.iterateNodesByType(&#x27;UnaryExpression&#x27;, function(node) {
            if (types.numeric &#x26;&#x26; node.operator === &#x27;+&#x27;) {
                errors.add(&#x27;Implicit numeric conversion&#x27;, node);
            }
            if (types.binary &#x26;&#x26; node.operator === &#x27;~&#x27;) {
                errors.add(&#x27;Implicit binary conversion&#x27;, node);
            }
            if (types.boolean &#x26;&#x26;
                node.operator === &#x27;!&#x27; &#x26;&#x26;
                node.argument.type === &#x27;UnaryExpression&#x27; &#x26;&#x26;
                node.argument.operator === &#x27;!&#x27;
            ) {
                errors.add(&#x27;Implicit boolean conversion&#x27;, node);
            }
        });
    }
    if (types.string) {
        file.iterateNodesByType(&#x27;BinaryExpression&#x27;, function(node) {

            if (node.operator !== &#x27;+&#x27;) {
                return;
            }

            // Do not report concatination for same string literals (#1538)
            if (node.left.type === node.right.type) {
                return;
            }

            if (
                (node.left.type === &#x27;StringLiteral&#x27; &#x26;&#x26; node.left.value === &#x27;&#x27;) ||
                (node.right.type === &#x27;StringLiteral&#x27; &#x26;&#x26; node.right.value === &#x27;&#x27;)
            ) {
                errors.add(&#x27;Implicit string conversion&#x27;, node);
            }
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_implicit_type_conversion.prototype.configure" id="apidoc.element.jscs.disallow_implicit_type_conversion.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_implicit_type_conversion.prototype.</span>configure
        <span class="apidocSignatureSpan">(types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (types) {
    assert(Array.isArray(types), this.getOptionName() + &#x27; option requires array value&#x27;);
    this._typeIndex = {};
    for (var i = 0, l = types.length; i &#x3c; l; i++) {
        this._typeIndex[types[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_implicit_type_conversion.prototype.getOptionName" id="apidoc.element.jscs.disallow_implicit_type_conversion.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_implicit_type_conversion.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowImplicitTypeConversion&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_keywords" id="apidoc.module.jscs.disallow_keywords">module jscs.disallow_keywords</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords.disallow_keywords" id="apidoc.element.jscs.disallow_keywords.disallow_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_keywords.prototype" id="apidoc.module.jscs.disallow_keywords.prototype">module jscs.disallow_keywords.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords.prototype.check" id="apidoc.element.jscs.disallow_keywords.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue(&#x27;Keyword&#x27;, this._keywords, function(token) {
        errors.add(&#x27;Illegal keyword: &#x27; + token.value, token);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords.prototype.configure" id="apidoc.element.jscs.disallow_keywords.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(Array.isArray(keywords), this.getOptionName() + &#x27; option requires array value&#x27;);
    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords.prototype.getOptionName" id="apidoc.element.jscs.disallow_keywords.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowKeywords&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_keywords_in_comments" id="apidoc.module.jscs.disallow_keywords_in_comments">module jscs.disallow_keywords_in_comments</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_in_comments.disallow_keywords_in_comments" id="apidoc.element.jscs.disallow_keywords_in_comments.disallow_keywords_in_comments">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_in_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_keywords_in_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_keywords_in_comments.prototype" id="apidoc.module.jscs.disallow_keywords_in_comments.prototype">module jscs.disallow_keywords_in_comments.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_in_comments.prototype.check" id="apidoc.element.jscs.disallow_keywords_in_comments.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords_in_comments.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var keywordRegEx = this._keywordRegEx;
    file.iterateTokensByType([&#x27;CommentLine&#x27;, &#x27;CommentBlock&#x27;], function(comment) {
        var match;

        // Both &#x27;//&#x27; and &#x27;/*&#x27; comment starters have offset &#x27;2&#x27;
        var commentOffset = 2;
        keywordRegEx.lastIndex = 0;
        while ((match = keywordRegEx.exec(comment.value)) !== null) {
            errors.add(
                this.mesage,
                comment,
                match.index + commentOffset
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_in_comments.prototype.configure" id="apidoc.element.jscs.disallow_keywords_in_comments.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords_in_comments.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    this._message = &#x27;Comments cannot contain the following keywords: &#x27;;
    this._keywords = [&#x27;todo&#x27;, &#x27;fixme&#x27;];

    switch (true) {
        case Array.isArray(keywords):
            // use the array of strings provided to build RegExp pattern
            this._keywords = keywords;
<span class="apidocCodeCommentSpan">            /* falls through */
</span>        case keywords:
            // use default keywords
            this._message += this._keywords.join(&#x27;, &#x27;);
            this._keywordRegEx = new RegExp(&#x27;\\b(&#x27; + this._keywords.join(&#x27;|&#x27;) + &#x27;)\\b&#x27;, &#x27;gi&#x27;);
            break;
        case typeof keywords === &#x27;string&#x27;:
            // use string passed in as the RegExp pattern
            this._message = &#x27;Comments cannot contain keywords based on the expression you provided&#x27;;
            this._keywordRegEx = new RegExp(keywords, &#x27;gi&#x27;);
            break;
        default:
            assert(false, this.getOptionName() + &#x27; option requires a true value, a string or an array&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_in_comments.prototype.getOptionName" id="apidoc.element.jscs.disallow_keywords_in_comments.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords_in_comments.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowKeywordsInComments&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_keywords_on_new_line" id="apidoc.module.jscs.disallow_keywords_on_new_line">module jscs.disallow_keywords_on_new_line</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_on_new_line.disallow_keywords_on_new_line" id="apidoc.element.jscs.disallow_keywords_on_new_line.disallow_keywords_on_new_line">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_on_new_line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_keywords_on_new_line = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_keywords_on_new_line.prototype" id="apidoc.module.jscs.disallow_keywords_on_new_line.prototype">module jscs.disallow_keywords_on_new_line.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_on_new_line.prototype.check" id="apidoc.element.jscs.disallow_keywords_on_new_line.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords_on_new_line.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue(&#x27;Keyword&#x27;, this._keywords, function(token) {
        var prevToken = token.getPreviousCodeToken();

        if (token.value === &#x27;else&#x27;) {
            if (prevToken.value !== &#x27;}&#x27;) {
                // Special case for #905, even though it contradicts rule meaning,
                // it makes more sense that way.
                return;
            }

            if (isPreviousTokenAComment(token)) {
                // Special case for #1421, to handle comments before the else
                return;
            }
        }

        // Special cases for #885, using while as the keyword contradicts rule meaning
        // but it is more efficient and reduces complexity of the code in this rule
        if (token.value === &#x27;while&#x27;) {
            var parentElement = token.parentElement;

            // &#x22;while&#x22; that is part of a do will not return nodes as it is not a start token
            if (parentElement.type !== &#x27;DoWhileStatement&#x27; || prevToken.value !== &#x27;}&#x27;) {
                // allow &#x22;while&#x22; that is part of a &#x22;do while&#x22; with no braces to succeed
                return;
            }

            if (isPreviousTokenAComment(token)) {
                // Special case for #1421, to handle comments before the else
                return;
            }
        }

        errors.assert.sameLine({
            token: prevToken,
            nextToken: token
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_on_new_line.prototype.configure" id="apidoc.element.jscs.disallow_keywords_on_new_line.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords_on_new_line.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(Array.isArray(keywords), this.getOptionName() + &#x27; option requires array value&#x27;);
    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_on_new_line.prototype.getOptionName" id="apidoc.element.jscs.disallow_keywords_on_new_line.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords_on_new_line.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowKeywordsOnNewLine&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_mixed_spaces_and_tabs" id="apidoc.module.jscs.disallow_mixed_spaces_and_tabs">module jscs.disallow_mixed_spaces_and_tabs</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs.disallow_mixed_spaces_and_tabs" id="apidoc.element.jscs.disallow_mixed_spaces_and_tabs.disallow_mixed_spaces_and_tabs">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_mixed_spaces_and_tabs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_mixed_spaces_and_tabs = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_mixed_spaces_and_tabs.prototype" id="apidoc.module.jscs.disallow_mixed_spaces_and_tabs.prototype">module jscs.disallow_mixed_spaces_and_tabs.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.check" id="apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_mixed_spaces_and_tabs.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var test = this._options === true ?
        (/ \t|\t [^\*]|\t $/) :
        (/ \t/);

    file.iterateTokensByType(&#x27;Whitespace&#x27;, function(token) {
        var match = test.exec(token.value);
        if (match) {
            errors.add(&#x27;Mixed spaces and tabs found&#x27;, token, token.index);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.configure" id="apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_mixed_spaces_and_tabs.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || options === &#x27;smart&#x27;,
        this.getOptionName() + &#x27; option requires a true value or &#x22;smart&#x22;&#x27;
    );

    this._options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.getOptionName" id="apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_mixed_spaces_and_tabs.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowMixedSpacesAndTabs&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multi_line_ternary" id="apidoc.module.jscs.disallow_multi_line_ternary">module jscs.disallow_multi_line_ternary</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multi_line_ternary.disallow_multi_line_ternary" id="apidoc.element.jscs.disallow_multi_line_ternary.disallow_multi_line_ternary">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multi_line_ternary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multi_line_ternary = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multi_line_ternary.prototype" id="apidoc.module.jscs.disallow_multi_line_ternary.prototype">module jscs.disallow_multi_line_ternary.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multi_line_ternary.prototype.check" id="apidoc.element.jscs.disallow_multi_line_ternary.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_multi_line_ternary.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;ConditionalExpression&#x27;, function(node) {

        errors.assert.sameLine({
            token: node.test,
            nextToken: node.consequent,
            message: &#x27;Illegal new line after test&#x27;
        });

        errors.assert.sameLine({
            token: node.consequent,
            nextToken: node.alternate,
            message: &#x27;Illegal new line after consequent&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multi_line_ternary.prototype.configure" id="apidoc.element.jscs.disallow_multi_line_ternary.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_multi_line_ternary.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multi_line_ternary.prototype.getOptionName" id="apidoc.element.jscs.disallow_multi_line_ternary.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_multi_line_ternary.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowMultiLineTernary&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multiple_line_breaks" id="apidoc.module.jscs.disallow_multiple_line_breaks">module jscs.disallow_multiple_line_breaks</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_breaks.disallow_multiple_line_breaks" id="apidoc.element.jscs.disallow_multiple_line_breaks.disallow_multiple_line_breaks">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_breaks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multiple_line_breaks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multiple_line_breaks.prototype" id="apidoc.module.jscs.disallow_multiple_line_breaks.prototype">module jscs.disallow_multiple_line_breaks.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_breaks.prototype.check" id="apidoc.element.jscs.disallow_multiple_line_breaks.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_breaks.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    // Iterate over all tokens (including comments)
    file.iterateTokensByType(&#x27;Whitespace&#x27;, function(whitespaceToken) {
        if (whitespaceToken.getNewlineCount() === 0) {
            return;
        }

        var token = whitespaceToken.getPreviousNonWhitespaceToken();

        if (!token) {
            return;
        }

        var nextToken = token.getNextNonWhitespaceToken();

        errors.assert.linesBetween({
            token: token,
            nextToken: nextToken,
            atMost: 2
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_breaks.prototype.configure" id="apidoc.element.jscs.disallow_multiple_line_breaks.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_breaks.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_breaks.prototype.getOptionName" id="apidoc.element.jscs.disallow_multiple_line_breaks.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_breaks.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowMultipleLineBreaks&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multiple_line_strings" id="apidoc.module.jscs.disallow_multiple_line_strings">module jscs.disallow_multiple_line_strings</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_strings.disallow_multiple_line_strings" id="apidoc.element.jscs.disallow_multiple_line_strings.disallow_multiple_line_strings">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_strings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multiple_line_strings = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multiple_line_strings.prototype" id="apidoc.module.jscs.disallow_multiple_line_strings.prototype">module jscs.disallow_multiple_line_strings.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_strings.prototype.check" id="apidoc.element.jscs.disallow_multiple_line_strings.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_strings.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByType(&#x27;String&#x27;, function(token) {
        if (token.getNewlineCount() !== 0) {
            errors.add(&#x27;Multiline strings are disallowed.&#x27;, token);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_strings.prototype.configure" id="apidoc.element.jscs.disallow_multiple_line_strings.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_strings.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_strings.prototype.getOptionName" id="apidoc.element.jscs.disallow_multiple_line_strings.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_strings.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowMultipleLineStrings&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multiple_spaces" id="apidoc.module.jscs.disallow_multiple_spaces">module jscs.disallow_multiple_spaces</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_spaces.disallow_multiple_spaces" id="apidoc.element.jscs.disallow_multiple_spaces.disallow_multiple_spaces">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_spaces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multiple_spaces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multiple_spaces.prototype" id="apidoc.module.jscs.disallow_multiple_spaces.prototype">module jscs.disallow_multiple_spaces.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_spaces.prototype.check" id="apidoc.element.jscs.disallow_multiple_spaces.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_spaces.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var token = file.getProgram().getFirstToken();
    var nextToken;

    while (token) {
        nextToken = token.getNextNonWhitespaceToken();

        if (!nextToken) {
            break;
        }

        if (!this._allowEOLComments || nextToken.type !== &#x27;CommentLine&#x27;) {
            errors.assert.spacesBetween({
                token: token,
                nextToken: nextToken,
                atMost: 1
            });
        }

        token = token.getNextNonWhitespaceToken();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_spaces.prototype.configure" id="apidoc.element.jscs.disallow_multiple_spaces.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_spaces.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true ||
        typeof options === &#x27;object&#x27; &#x26;&#x26;
        options.allowEOLComments === true,
        this.getOptionName() + &#x27; option requires true value &#x27; +
        &#x27;or an object with `allowEOLComments` property&#x27;
    );

    this._allowEOLComments = options.allowEOLComments;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_spaces.prototype.getOptionName" id="apidoc.element.jscs.disallow_multiple_spaces.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_spaces.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowMultipleSpaces&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multiple_var_decl" id="apidoc.module.jscs.disallow_multiple_var_decl">module jscs.disallow_multiple_var_decl</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_var_decl.disallow_multiple_var_decl" id="apidoc.element.jscs.disallow_multiple_var_decl.disallow_multiple_var_decl">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_var_decl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multiple_var_decl = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multiple_var_decl.prototype" id="apidoc.module.jscs.disallow_multiple_var_decl.prototype">module jscs.disallow_multiple_var_decl.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_var_decl.prototype.check" id="apidoc.element.jscs.disallow_multiple_var_decl.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_var_decl.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {

    function isSourcedFromRequire(node) {
        // If this node is a CallExpression it has a callee,
        // check if this is the `require` function
        if (node.callee &#x26;&#x26; node.callee.name === &#x27;require&#x27;) {
            return true;
        }

        // If this CallExpression is not a `require` we keep looking for
        // the `require` method up in the tree
        if (node.callee &#x26;&#x26; node.callee.object) {
            return isSourcedFromRequire(node.callee.object);
        }

        // If there is no `callee` this might be a MemberExpression, keep
        // look for the `require` method up in the tree.
        if (node.object) {
            return isSourcedFromRequire(node.object);
        }

        return false;
    }

    var inStrictMode = this._strictMode;
    var exceptUndefined = this._exceptUndefined;
    var exceptRequire = this._exceptRequire;

    file.iterateNodesByType(&#x27;VariableDeclaration&#x27;, function(node) {
        var definedVariables = node.declarations.filter(function(declaration) {
            return !!declaration.init;
        });
        var hasDefinedVariables = definedVariables.length &#x3e; 0;

        var requireStatements = node.declarations.filter(function(declaration) {
            var init = declaration.init;
            return init &#x26;&#x26; isSourcedFromRequire(init);
        });
        var allRequireStatements = requireStatements.length === node.declarations.length;

        var isForStatement = node.parentElement.type === &#x27;ForStatement&#x27;;

        // allow single var declarations
        if (node.declarations.length === 1) {
            return;
        }

        // allow multiple var declarations in for statement unless we&#x27;re in strict mode
        // for (var i = 0, j = myArray.length; i &#x3c; j; i++) {}
        if (!inStrictMode &#x26;&#x26; isForStatement) {
            return;
        }

        // allow multiple var declarations with all undefined variables in exceptUndefined mode
        // var a, b, c
        if (exceptUndefined &#x26;&#x26; !hasDefinedVariables) {
            return;
        }

        // allow multiple var declaration with all require
        // var a = require(&#x22;a&#x22;), b = require(&#x22;b&#x22;)
        if (exceptRequire &#x26;&#x26; allRequireStatements) {
            return;
        }

        // allow multiple var declarations only with require &#x26;&#x26; undefined
        // var a = require(&#x22;a&#x22;), b = require(&#x22;b&#x22;), x, y
        if (exceptUndefined &#x26;&#x26; exceptRequire &#x26;&#x26; definedVariables.length === requireStatements.length) {
            return;
        }

        errors.add(&#x27;Multiple var declaration&#x27;, node);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_var_decl.prototype.configure" id="apidoc.element.jscs.disallow_multiple_var_decl.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_var_decl.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    // support for legacy options
    if (typeof options !== &#x27;object&#x27;) {
        assert(
            options === true ||
            options === &#x27;strict&#x27; ||
            options === &#x27;exceptUndefined&#x27;,
            this.getOptionName() +
                &#x27; option requires a true value, &#x22;strict&#x22;, &#x22;exceptUndefined&#x22;, or an object&#x27;
        );

        var _options = {
            strict: options === &#x27;strict&#x27;,
            allExcept: []
        };

        if (options === &#x27;exceptUndefined&#x27;) {
            _options.allExcept.push(&#x27;undefined&#x27;);
        }

        return this.configure(_options);
    }

    if (Array.isArray(options.allExcept)) {
        this._exceptUndefined = options.allExcept.indexOf(&#x27;undefined&#x27;) &#x3e; -1;
        this._exceptRequire = options.allExcept.indexOf(&#x27;require&#x27;) &#x3e; -1;
    }

    this._strictMode = options.strict === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_var_decl.prototype.getOptionName" id="apidoc.element.jscs.disallow_multiple_var_decl.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_var_decl.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowMultipleVarDecl&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_named_unassigned_functions" id="apidoc.module.jscs.disallow_named_unassigned_functions">module jscs.disallow_named_unassigned_functions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_named_unassigned_functions.disallow_named_unassigned_functions" id="apidoc.element.jscs.disallow_named_unassigned_functions.disallow_named_unassigned_functions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_named_unassigned_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_named_unassigned_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_named_unassigned_functions.prototype" id="apidoc.module.jscs.disallow_named_unassigned_functions.prototype">module jscs.disallow_named_unassigned_functions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_named_unassigned_functions.prototype.check" id="apidoc.element.jscs.disallow_named_unassigned_functions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_named_unassigned_functions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;FunctionExpression&#x27;, function(node) {
        // If the function has been named via left hand assignment, skip it
        //   e.g. `var hello = function() {`, `foo.bar = function() {`
        if (node.parentElement.type.match(/VariableDeclarator|Property|AssignmentExpression/)) {
            return;
        }

        // If the function has not been named, skip it
        //   e.g. `[].forEach(function() {`
        if (node.id === null) {
            return;
        }

        // Otherwise, complain that it is being named
        errors.add(&#x27;Inline functions cannot be named&#x27;, node);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_named_unassigned_functions.prototype.configure" id="apidoc.element.jscs.disallow_named_unassigned_functions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_named_unassigned_functions.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires true value&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_named_unassigned_functions.prototype.getOptionName" id="apidoc.element.jscs.disallow_named_unassigned_functions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_named_unassigned_functions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowNamedUnassignedFunctions&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_nested_ternaries" id="apidoc.module.jscs.disallow_nested_ternaries">module jscs.disallow_nested_ternaries</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_nested_ternaries.disallow_nested_ternaries" id="apidoc.element.jscs.disallow_nested_ternaries.disallow_nested_ternaries">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_nested_ternaries
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_nested_ternaries = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_nested_ternaries.prototype" id="apidoc.module.jscs.disallow_nested_ternaries.prototype">module jscs.disallow_nested_ternaries.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_nested_ternaries.prototype.check" id="apidoc.element.jscs.disallow_nested_ternaries.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_nested_ternaries.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var maxLevel = this._maxLevel;
    file.iterateNodesByType(&#x27;ConditionalExpression&#x27;, function(node) {
        var level = 0;
        var getLevel = function(currentNode) {
            if (currentNode.parentElement &#x26;&#x26; currentNode.parentElement.type === &#x27;ConditionalExpression&#x27;) {
                level += 1;
                if (level &#x3e; maxLevel) {
                    errors.add(&#x27;Illegal nested ternary&#x27;, node);
                    return;
                }
                getLevel(currentNode.parentElement);
            }
        };
        getLevel(node);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_nested_ternaries.prototype.configure" id="apidoc.element.jscs.disallow_nested_ternaries.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_nested_ternaries.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || (typeof options.maxLevel === &#x27;number&#x27; &#x26;&#x26; options.maxLevel &#x3e; 0),
        this.getOptionName() + &#x27; option requires a true value or an object with &#x22;maxLevel&#x22; property&#x27;
    );

    this._maxLevel = 0;
    if (options.maxLevel) {
        this._maxLevel = options.maxLevel;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_nested_ternaries.prototype.getOptionName" id="apidoc.element.jscs.disallow_nested_ternaries.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_nested_ternaries.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowNestedTernaries&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_newline_before_block_statements" id="apidoc.module.jscs.disallow_newline_before_block_statements">module jscs.disallow_newline_before_block_statements</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_newline_before_block_statements.disallow_newline_before_block_statements" id="apidoc.element.jscs.disallow_newline_before_block_statements.disallow_newline_before_block_statements">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_newline_before_block_statements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_newline_before_block_statements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_newline_before_block_statements.prototype" id="apidoc.module.jscs.disallow_newline_before_block_statements.prototype">module jscs.disallow_newline_before_block_statements.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_newline_before_block_statements.prototype.check" id="apidoc.element.jscs.disallow_newline_before_block_statements.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_newline_before_block_statements.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var setting = this._setting;
    var hasMultiLineEx = this._hasMultiLineEx;

    function assertSameLine(token, nextToken) {
        errors.assert.sameLine({
            token: token,
            nextToken: nextToken,
            message: &#x27;Newline before curly brace for block statement is disallowed&#x27;
        });
    }
    function assertDifferentLine(token, nextToken) {
        errors.assert.differentLine({
            token: token,
            nextToken: nextToken,
            message: &#x27;Newline before curly brace for block statement is required&#x27;
        });
    }

    file.iterateNodesByType([&#x27;BlockStatement&#x27;, &#x27;ClassBody&#x27;], function(node) {
        if (isBareBlock(node)) {
            return;
        }

        if (setting === true || setting.indexOf(getBlockType(node)) !== -1) {
            var openingBrace = node.getFirstToken();
            var prevToken = openingBrace.getPreviousCodeToken();

            if (hasMultiLineEx !== true) {
                assertSameLine(prevToken, openingBrace);
                return;
            }

            // Check if the &#x27;conditions&#x27; span on multiple lines.
            // The simplest way is to check if the round braces are on different lines.
            //
            // For example:
            //     // same line
            //     for (var i = 0; i &#x3c; length; i++) {
            //     }
            //
            //     // different lines:
            //     for (var i = 0;
            //          i &#x3c; length;
            //          i++)
            //     {
            //     }
            var parentElement = node.parentElement;
            var parentNextToken = file.getFirstNodeToken(parentElement);
            var openingRoundBrace = file.findNextToken(parentNextToken, &#x27;Punctuator&#x27;, &#x27;(&#x27;);
            var closingRoundBrace = file.findPrevToken(openingBrace, &#x27;Punctuator&#x27;, &#x27;)&#x27;);

            // Not always the conditions are there: to check look for the presence of round braces.
            // For example:
            //     try {
            //     } ...
            if (openingRoundBrace &#x26;&#x26; closingRoundBrace &#x26;&#x26;
                    !file.isOnTheSameLine(openingRoundBrace, closingRoundBrace)) {
                assertDifferentLine(prevToken, openingBrace);
            } else {
                assertSameLine(prevToken, openingBrace);
            }
        }
    });

    if (setting === true || setting.indexOf(&#x27;switch&#x27;) !== -1) {
        file.iterateNodesByType([&#x27;SwitchStatement&#x27;], function(node) {
            var openingBrace = file.findNextToken(file.getLastNodeToken(node.discriminant), &#x27;Punctuator&#x27;, &#x27;{&#x27;);
            var prevToken = file.getPrevToken(openingBrace);

            if (hasMultiLineEx !== true) {
                assertSameLine(prevToken, openingBrace);
                return;
            }

            var openingRoundBrace = file.findNextToken(file.getFirstNodeToken(node), &#x27;Punctuator&#x27;, &#x27;(&#x27;);
            var closingRoundBrace = file.findPrevToken(openingBrace, &#x27;Punctuator&#x27;, &#x27;)&#x27;);

            if (!file.isOnTheSameLine(openingRoundBrace, closingRoundBrace)) {
                assertDifferentLine(prevToken, openingBrace);
            } else {
                assertSameLine(prevToken, openingBrace);
            }
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_newline_before_block_statements.prototype.configure" id="apidoc.element.jscs.disallow_newline_before_block_statements.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_newline_before_block_statements.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var settingValue;
    this._hasMultiLineEx = false;
    if (options.constructor === Object) {
        settingValue = options.value;
        if (options.allExcept) {
            assert(
                Array.isArray(options.allExcept) &#x26;&#x26; options.allExcept.length === 1 &#x26;&#x26;
                options.allExcept[0] === &#x27;multiLine&#x27;,
                &#x27;allExcept option must be an array whose values can be only `multiLine`&#x27;
            );
            this._hasMultiLineEx = true;
        }
    } else {
        settingValue = options;
    }
    assert(
        Array.isArray(settingValue) &#x26;&#x26; settingValue.length || settingValue === true,
        &#x27;disallowNewlineBeforeBlockStatements option requires non-empty array value or true value&#x27;
    );

    this._setting = settingValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_newline_before_block_statements.prototype.getOptionName" id="apidoc.element.jscs.disallow_newline_before_block_statements.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_newline_before_block_statements.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowNewlineBeforeBlockStatements&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_node_types" id="apidoc.module.jscs.disallow_node_types">module jscs.disallow_node_types</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_node_types.disallow_node_types" id="apidoc.element.jscs.disallow_node_types.disallow_node_types">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_node_types
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_node_types = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_node_types.prototype" id="apidoc.module.jscs.disallow_node_types.prototype">module jscs.disallow_node_types.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_node_types.prototype.check" id="apidoc.element.jscs.disallow_node_types.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_node_types.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var disallowedNodeTypes = this._nodeTypes;
    file.iterateNodesByType(disallowedNodeTypes, function(node) {
        errors.add(&#x27;Illegal use of disallowed node type: &#x27; + node.type, node);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_node_types.prototype.configure" id="apidoc.element.jscs.disallow_node_types.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_node_types.prototype.</span>configure
        <span class="apidocSignatureSpan">(nodeTypes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (nodeTypes) {
    assert(
        Array.isArray(nodeTypes),
        &#x27;disallowNodeTypes option requires an array&#x27;
    );

    this._nodeTypes = nodeTypes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_node_types.prototype.getOptionName" id="apidoc.element.jscs.disallow_node_types.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_node_types.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowNodeTypes&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_not_operators_in_conditionals" id="apidoc.module.jscs.disallow_not_operators_in_conditionals">module jscs.disallow_not_operators_in_conditionals</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_not_operators_in_conditionals.disallow_not_operators_in_conditionals" id="apidoc.element.jscs.disallow_not_operators_in_conditionals.disallow_not_operators_in_conditionals">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_not_operators_in_conditionals
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_not_operators_in_conditionals = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_not_operators_in_conditionals.prototype" id="apidoc.module.jscs.disallow_not_operators_in_conditionals.prototype">module jscs.disallow_not_operators_in_conditionals.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.check" id="apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_not_operators_in_conditionals.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    function hasNotOperator(test) {
        return test.type === &#x27;UnaryExpression&#x27; &#x26;&#x26; test.operator === &#x27;!&#x27;;
    }

    function hasNotEqualOperator(test) {
        return test.type === &#x27;BinaryExpression&#x27; &#x26;&#x26; test.operator === &#x27;!=&#x27;;
    }

    function hasStrictNotEqualOperator(test) {
        return test.type === &#x27;BinaryExpression&#x27; &#x26;&#x26; test.operator === &#x27;!==&#x27;;
    }

    file.iterateNodesByType([&#x27;IfStatement&#x27;, &#x27;ConditionalExpression&#x27;], function(node) {
        var alternate = node.alternate;

        // check if the if statement has an else block
        if (node.type === &#x27;IfStatement&#x27; &#x26;&#x26; (!alternate || alternate.type !== &#x27;BlockStatement&#x27;)) {
            return;
        }
        var test = node.test;
        if (hasNotOperator(test)) {
            errors.add(&#x27;Illegal use of not operator in if statement&#x27;, test);
        }
        if (hasNotEqualOperator(test)) {
            errors.add(&#x27;Illegal use of not equal operator in if statement&#x27;, test);
        }
        if (hasStrictNotEqualOperator(test)) {
            errors.add(&#x27;Illegal use of strict not equal operator in if statement&#x27;, test);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.configure" id="apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_not_operators_in_conditionals.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.getOptionName" id="apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_not_operators_in_conditionals.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowNotOperatorsInConditionals&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_object_keys_on_new_line" id="apidoc.module.jscs.disallow_object_keys_on_new_line">module jscs.disallow_object_keys_on_new_line</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_object_keys_on_new_line.disallow_object_keys_on_new_line" id="apidoc.element.jscs.disallow_object_keys_on_new_line.disallow_object_keys_on_new_line">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_object_keys_on_new_line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_object_keys_on_new_line = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_object_keys_on_new_line.prototype" id="apidoc.module.jscs.disallow_object_keys_on_new_line.prototype">module jscs.disallow_object_keys_on_new_line.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.check" id="apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_object_keys_on_new_line.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;ObjectExpression&#x27;, function(node) {
        var properties = node.properties;
        for (var i = 1; i &#x3c; properties.length; i++) {
            var propertyNode = properties[i];

            errors.assert.sameLine({
                token: propertyNode.getPreviousCodeToken(),
                nextToken: propertyNode.getFirstToken(),
                message: &#x27;Object keys should be on the same line&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.configure" id="apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_object_keys_on_new_line.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.getOptionName" id="apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_object_keys_on_new_line.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowObjectKeysOnNewLine&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_operator_before_line_break" id="apidoc.module.jscs.disallow_operator_before_line_break">module jscs.disallow_operator_before_line_break</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_operator_before_line_break.disallow_operator_before_line_break" id="apidoc.element.jscs.disallow_operator_before_line_break.disallow_operator_before_line_break">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_operator_before_line_break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_operator_before_line_break = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_operator_before_line_break.prototype" id="apidoc.module.jscs.disallow_operator_before_line_break.prototype">module jscs.disallow_operator_before_line_break.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_operator_before_line_break.prototype.check" id="apidoc.element.jscs.disallow_operator_before_line_break.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_operator_before_line_break.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, this._operators, function(token) {
        errors.assert.sameLine({
            token: token,
            nextToken: file.getNextToken(token),
            message: &#x27;Operator needs to either be on the same line or after a line break.&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_operator_before_line_break.prototype.configure" id="apidoc.element.jscs.disallow_operator_before_line_break.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_operator_before_line_break.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    assert(Array.isArray(operators) || operators === true,
        this.getOptionName() + &#x27; option requires array or true value&#x27;);

    if (operators === true) {
        operators = defaultOperators;
    }
    this._operators = operators;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_operator_before_line_break.prototype.getOptionName" id="apidoc.element.jscs.disallow_operator_before_line_break.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_operator_before_line_break.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowOperatorBeforeLineBreak&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_after_blocks" id="apidoc.module.jscs.disallow_padding_newlines_after_blocks">module jscs.disallow_padding_newlines_after_blocks</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks.disallow_padding_newlines_after_blocks" id="apidoc.element.jscs.disallow_padding_newlines_after_blocks.disallow_padding_newlines_after_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_after_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_after_blocks.prototype" id="apidoc.module.jscs.disallow_padding_newlines_after_blocks.prototype">module jscs.disallow_padding_newlines_after_blocks.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.check" id="apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_blocks.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;BlockStatement&#x27;, function(node) {
        var endToken = file.getLastNodeToken(node);
        var nextToken = file.getNextToken(endToken);

        while (nextToken.type !== &#x27;EOF&#x27;) {
            if (file.isOnTheSameLine(endToken, nextToken)) {
                endToken = nextToken;
                nextToken = file.getNextToken(nextToken);
                continue;
            }

            errors.assert.linesBetween({
                token: endToken,
                nextToken: nextToken,
                atMost: 1,
                message: &#x27;Extra newline after closing curly brace&#x27;
            });

            return;
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.configure" id="apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_blocks.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    assert(
        value === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.getOptionName" id="apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_blocks.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowPaddingNewLinesAfterBlocks&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_after_use_strict" id="apidoc.module.jscs.disallow_padding_newlines_after_use_strict">module jscs.disallow_padding_newlines_after_use_strict</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict.disallow_padding_newlines_after_use_strict" id="apidoc.element.jscs.disallow_padding_newlines_after_use_strict.disallow_padding_newlines_after_use_strict">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_use_strict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_after_use_strict = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_after_use_strict.prototype" id="apidoc.module.jscs.disallow_padding_newlines_after_use_strict.prototype">module jscs.disallow_padding_newlines_after_use_strict.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.check" id="apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_use_strict.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;Directive&#x27;, function(node) {
        var literal = node.value;

        if (literal.value !== &#x27;use strict&#x27;) {
            return;
        }

        var endOfNode = file.getLastNodeToken(node);
        var nextToken = file.getNextToken(endOfNode, {
            includeComments: true
        });

        errors.assert.linesBetween({
            atMost: 1,
            token: endOfNode,
            nextToken: nextToken
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.configure" id="apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_use_strict.prototype.</span>configure
        <span class="apidocSignatureSpan">(disallowPaddingNewLinesAfterUseStrict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (disallowPaddingNewLinesAfterUseStrict) {
    assert(
        disallowPaddingNewLinesAfterUseStrict === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.getOptionName" id="apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_use_strict.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowPaddingNewLinesAfterUseStrict&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_before_export" id="apidoc.module.jscs.disallow_padding_newlines_before_export">module jscs.disallow_padding_newlines_before_export</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_export.disallow_padding_newlines_before_export" id="apidoc.element.jscs.disallow_padding_newlines_before_export.disallow_padding_newlines_before_export">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_export
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_before_export = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_before_export.prototype" id="apidoc.module.jscs.disallow_padding_newlines_before_export.prototype">module jscs.disallow_padding_newlines_before_export.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.check" id="apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_export.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;AssignmentExpression&#x27;, function(node) {
        var left = node.left;

        if (!(
            left.object &#x26;&#x26;
            left.object.name === &#x27;module&#x27; &#x26;&#x26;
            left.property &#x26;&#x26;
            left.property.name === &#x27;exports&#x27;)) {
            return;
        }

        var firstToken = node.getFirstToken();
        var prevToken = file.getPrevToken(firstToken, {includeComments: true});

        errors.assert.linesBetween({
            atMost: 1,
            token: prevToken,
            nextToken: firstToken,
            message: &#x27;Unexpected extra newline before export&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.configure" id="apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_export.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    assert(
        value === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.getOptionName" id="apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_export.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowPaddingNewLinesBeforeExport&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_before_keywords" id="apidoc.module.jscs.disallow_padding_newlines_before_keywords">module jscs.disallow_padding_newlines_before_keywords</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords.disallow_padding_newlines_before_keywords" id="apidoc.element.jscs.disallow_padding_newlines_before_keywords.disallow_padding_newlines_before_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_before_keywords = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_before_keywords.prototype" id="apidoc.module.jscs.disallow_padding_newlines_before_keywords.prototype">module jscs.disallow_padding_newlines_before_keywords.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.check" id="apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_keywords.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue(&#x27;Keyword&#x27;, this._keywords, function(token) {
        errors.assert.linesBetween({
            token: file.getPrevToken(token, { includeComments: true }),
            nextToken: token,
            atMost: 1,
            message: &#x27;Keyword `&#x27; + token.value + &#x27;` should not have an empty line above it&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.configure" id="apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_keywords.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(Array.isArray(keywords) || keywords === true,
        this.getOptionName() + &#x27; option requires array or true value&#x27;);

    if (keywords === true) {
        keywords = defaultKeywords;
    }

    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.getOptionName" id="apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_keywords.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowPaddingNewlinesBeforeKeywords&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_before_line_comments" id="apidoc.module.jscs.disallow_padding_newlines_before_line_comments">module jscs.disallow_padding_newlines_before_line_comments</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments.disallow_padding_newlines_before_line_comments" id="apidoc.element.jscs.disallow_padding_newlines_before_line_comments.disallow_padding_newlines_before_line_comments">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_line_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_before_line_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_before_line_comments.prototype" id="apidoc.module.jscs.disallow_padding_newlines_before_line_comments.prototype">module jscs.disallow_padding_newlines_before_line_comments.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.check" id="apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_line_comments.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByType(&#x27;CommentLine&#x27;, function(comment) {
        if (comment.getLoc().start.line === 1) {
            return;
        }

        errors.assert.linesBetween({
            token: file.getPrevToken(comment, {includeComments: true}),
            nextToken: comment,
            atMost: 1,
            message: &#x27;Line comments must not be preceded with a blank line&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.configure" id="apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_line_comments.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    assert(
        value === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.getOptionName" id="apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_line_comments.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowPaddingNewLinesBeforeLineComments&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_in_blocks" id="apidoc.module.jscs.disallow_padding_newlines_in_blocks">module jscs.disallow_padding_newlines_in_blocks</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks.disallow_padding_newlines_in_blocks" id="apidoc.element.jscs.disallow_padding_newlines_in_blocks.disallow_padding_newlines_in_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_in_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_in_blocks.prototype" id="apidoc.module.jscs.disallow_padding_newlines_in_blocks.prototype">module jscs.disallow_padding_newlines_in_blocks.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.check" id="apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_blocks.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptConditionals = this._exceptConditionals;
    var exceptFunctions = this._exceptFunctions;
    var checkOpen = this._checkOpen;
    var checkClose = this._checkClose;

    file.iterateNodesByType(&#x27;BlockStatement&#x27;, function(node) {
        var openingBracket;
        var closingBracket;

        if (exceptConditionals &#x26;&#x26; node.parentElement.type === &#x27;IfStatement&#x27; ||
            exceptFunctions &#x26;&#x26; (node.parentElement.type === &#x27;FunctionExpression&#x27; ||
            node.parentElement.type === &#x27;FunctionDeclaration&#x27;)) {
            return;
        }

        if (checkOpen === true) {
            openingBracket = node.getFirstToken();

            errors.assert.linesBetween({
                token: openingBracket,
                nextToken: file.getNextToken(openingBracket, {includeComments: true}),
                atMost: 1,
                message: &#x27;Expected no padding newline after opening curly brace&#x27;
            });
        }

        if (checkClose === true) {
            closingBracket = file.getLastNodeToken(node);

            errors.assert.linesBetween({
                token: file.getPrevToken(closingBracket, {includeComments: true}),
                nextToken: closingBracket,
                atMost: 1,
                message: &#x27;Expected no padding newline before closing curly brace&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.configure" id="apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_blocks.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var optionName = this.getOptionName();

    this._checkOpen = true;
    this._checkClose = true;

    if (typeof options === &#x27;object&#x27;) {
        assert(options.allExcept || options.open || options.close,
        optionName + &#x27;option requires either &#x22;open&#x22;, &#x22;close&#x22;, &#x22;allExcept&#x22;&#x27;);

        if (options.allExcept) {
            assert(Array.isArray(options.allExcept), optionName + &#x27; option requires &#x22;allExcept&#x22; to be an array&#x27;);
            assert(options.allExcept.length &#x3e; 0, optionName + &#x27; option requires &#x22;allExcept&#x22; to have at least one &#x27; +
            &#x27;item or be set to `true`&#x27;);
            this._exceptConditionals = options.allExcept.indexOf(&#x27;conditionals&#x27;) &#x3e; -1;
            this._exceptFunctions = options.allExcept.indexOf(&#x27;functions&#x27;) &#x3e; -1;
        }

        if (options.open || options.close) {
            assert(typeof options.open === &#x27;boolean&#x27; &#x26;&#x26; typeof options.close === &#x27;boolean&#x27;,
              this.getOptionName() + &#x27; option requires the &#x22;open&#x22; and &#x22;close&#x22; &#x27; +
              &#x27;properties to be booleans&#x27;);

            this._checkOpen = options.open;
            this._checkClose = options.close;
        }
    } else {
        assert(options === true, this.getOptionName() + &#x27; option requires either a true value, or an object&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.getOptionName" id="apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_blocks.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowPaddingNewlinesInBlocks&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_in_objects" id="apidoc.module.jscs.disallow_padding_newlines_in_objects">module jscs.disallow_padding_newlines_in_objects</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_objects.disallow_padding_newlines_in_objects" id="apidoc.element.jscs.disallow_padding_newlines_in_objects.disallow_padding_newlines_in_objects">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_objects
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_in_objects = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_in_objects.prototype" id="apidoc.module.jscs.disallow_padding_newlines_in_objects.prototype">module jscs.disallow_padding_newlines_in_objects.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.check" id="apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_objects.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;ObjectExpression&#x27;, function(node) {
        var openingBracket = node.getFirstToken();
        var nextToken = file.getNextToken(openingBracket);

        if (nextToken.type === &#x27;Punctuator&#x27; &#x26;&#x26; nextToken.value === &#x27;}&#x27;) {
            return;
        }

        errors.assert.sameLine({
            token: openingBracket,
            nextToken: nextToken,
            message: &#x27;Illegal newline after opening curly brace&#x27;
        });

        var closingBracket = file.getLastNodeToken(node);

        errors.assert.sameLine({
            token: file.getPrevToken(closingBracket),
            nextToken: closingBracket,
            message: &#x27;Illegal newline before closing curly brace&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.configure" id="apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_objects.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    assert(
        value === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.getOptionName" id="apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_objects.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowPaddingNewLinesInObjects&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_parentheses_around_arrow_param" id="apidoc.module.jscs.disallow_parentheses_around_arrow_param">module jscs.disallow_parentheses_around_arrow_param</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param.disallow_parentheses_around_arrow_param" id="apidoc.element.jscs.disallow_parentheses_around_arrow_param.disallow_parentheses_around_arrow_param">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_parentheses_around_arrow_param
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_parentheses_around_arrow_param = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_parentheses_around_arrow_param.prototype" id="apidoc.module.jscs.disallow_parentheses_around_arrow_param.prototype">module jscs.disallow_parentheses_around_arrow_param.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.check" id="apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_parentheses_around_arrow_param.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    function isWrapped(node) {
        var openParensToken = file.getPrevToken(file.getFirstNodeToken(node));
        var closingParensToken = file.getNextToken(file.getLastNodeToken(node));
        var closingTokenValue = closingParensToken ? closingParensToken.value : &#x27;&#x27;;

        return openParensToken.value + closingTokenValue === &#x27;()&#x27;;
    }

    file.iterateNodesByType(&#x27;ArrowFunctionExpression&#x27;, function(node) {
        if (node.params.length !== 1) {
            return;
        }
        var firstParam = node.params[0];

        var hasDefaultParameter = firstParam.type === &#x27;AssignmentPattern&#x27;;
        var hasDestructuring = firstParam.type === &#x27;ObjectPattern&#x27; || firstParam.type === &#x27;ArrayPattern&#x27;;
        var hasRestElement = firstParam.type === &#x27;RestElement&#x27;;

        if (hasDefaultParameter ||
            hasDestructuring ||
            hasRestElement) {
            return;
        }

        if (isWrapped(firstParam)) {
            errors.add(&#x27;Illegal wrap of arrow function expressions in parentheses&#x27;, firstParam);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.configure" id="apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_parentheses_around_arrow_param.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.getOptionName" id="apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_parentheses_around_arrow_param.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowParenthesesAroundArrowParam&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_quoted_keys_in_objects" id="apidoc.module.jscs.disallow_quoted_keys_in_objects">module jscs.disallow_quoted_keys_in_objects</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.disallow_quoted_keys_in_objects" id="apidoc.element.jscs.disallow_quoted_keys_in_objects.disallow_quoted_keys_in_objects">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_quoted_keys_in_objects
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_quoted_keys_in_objects = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_quoted_keys_in_objects.prototype" id="apidoc.module.jscs.disallow_quoted_keys_in_objects.prototype">module jscs.disallow_quoted_keys_in_objects.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype._fix" id="apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.disallow_quoted_keys_in_objects.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var node = error.element;
    var key = node.key.childElements[0];

    var newKey = new cst.Token(key.type, key.getSourceCode().slice(1, -1));

    node.key.replaceChild(newKey, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &#x26;&#x26; instance._fix) {
        // &#x22;error.fixed = true&#x22; should go first, so rule can
        // decide for itself (with &#x22;error.fixed = false&#x22;)
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.check" id="apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_quoted_keys_in_objects.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var KEY_NAME_RE = /^(0|[1-9][0-9]*|[a-zA-Z_$]+[\w$]*)$/; // number or identifier
    var exceptReserved = this._exceptReserved;

    file.iterateNodesByType(&#x27;ObjectExpression&#x27;, function(node) {
        node.properties.forEach(function(prop) {
            var key = prop.key;

            // Spread properties
            if (!key) {
                return;
            }

            if (key.type !== &#x27;StringLiteral&#x27;) {
                return;
            }

            if (typeof key.value !== &#x27;string&#x27;) {
                return;
            }

            if (!KEY_NAME_RE.test(key.value)) {
                return;
            }

            if (exceptReserved &#x26;&#x26; reservedWords.check(key.value, file.getDialect(), true)) {
                return;
            }

            errors.cast({
                message: &#x27;Extra quotes for key&#x27;,
                element: prop
            });
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.configure" id="apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_quoted_keys_in_objects.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || options === &#x27;allButReserved&#x27; || typeof options === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option requires a true value or an object&#x27;
    );

    this._exceptReserved = options === &#x27;allButReserved&#x27;;
    if (Array.isArray(options.allExcept)) {
        this._exceptReserved = options.allExcept.indexOf(&#x27;reserved&#x27;) !== -1;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.getOptionName" id="apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_quoted_keys_in_objects.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowQuotedKeysInObjects&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_semicolons" id="apidoc.module.jscs.disallow_semicolons">module jscs.disallow_semicolons</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_semicolons.disallow_semicolons" id="apidoc.element.jscs.disallow_semicolons.disallow_semicolons">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_semicolons
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_semicolons = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_semicolons.prototype" id="apidoc.module.jscs.disallow_semicolons.prototype">module jscs.disallow_semicolons.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_semicolons.prototype._fix" id="apidoc.element.jscs.disallow_semicolons.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.disallow_semicolons.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    error.element.remove();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &#x26;&#x26; instance._fix) {
        // &#x22;error.fixed = true&#x22; should go first, so rule can
        // decide for itself (with &#x22;error.fixed = false&#x22;)
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_semicolons.prototype.check" id="apidoc.element.jscs.disallow_semicolons.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_semicolons.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;;&#x27;, function(token) {
        var nextToken = file.getNextToken(token);

        var node = token.parentElement;

        // Ignore node exceptions
        if (node.type in nodeExceptions) {
            return;
        }

        // Ignore next token exceptions
        if (nextToken.value in tokenExceptions) {
            return;
        }

        if (nextToken.type === &#x27;EOF&#x27; || !file.isOnTheSameLine(token, nextToken)) {
            errors.cast({
                message: &#x27;semicolons are disallowed at the end of a line.&#x27;,
                element: token
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_semicolons.prototype.configure" id="apidoc.element.jscs.disallow_semicolons.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_semicolons.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_semicolons.prototype.getOptionName" id="apidoc.element.jscs.disallow_semicolons.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_semicolons.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSemicolons&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_shorthand_arrow_functions" id="apidoc.module.jscs.disallow_shorthand_arrow_functions">module jscs.disallow_shorthand_arrow_functions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_shorthand_arrow_functions.disallow_shorthand_arrow_functions" id="apidoc.element.jscs.disallow_shorthand_arrow_functions.disallow_shorthand_arrow_functions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_shorthand_arrow_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_shorthand_arrow_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_shorthand_arrow_functions.prototype" id="apidoc.module.jscs.disallow_shorthand_arrow_functions.prototype">module jscs.disallow_shorthand_arrow_functions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.check" id="apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_shorthand_arrow_functions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;ArrowFunctionExpression&#x27;, function(node) {
        if (node.expression) {
            errors.add(&#x27;Use arrow function with explicit block and explicit return&#x27;, node.body);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.configure" id="apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_shorthand_arrow_functions.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.getOptionName" id="apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_shorthand_arrow_functions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowShorthandArrowFunctions&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_binary_operators" id="apidoc.module.jscs.disallow_space_after_binary_operators">module jscs.disallow_space_after_binary_operators</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_binary_operators.disallow_space_after_binary_operators" id="apidoc.element.jscs.disallow_space_after_binary_operators.disallow_space_after_binary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_binary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_binary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_binary_operators.prototype" id="apidoc.module.jscs.disallow_space_after_binary_operators.prototype">module jscs.disallow_space_after_binary_operators.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_binary_operators.prototype.check" id="apidoc.element.jscs.disallow_space_after_binary_operators.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_binary_operators.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operators = this._operatorIndex;

    // Comma
    if (operators[&#x27;,&#x27;]) {
        file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;,&#x27;, function(token) {
            if (file.getNextToken(token).value === &#x27;,&#x27;) {
                return;
            }
            errors.assert.noWhitespaceBetween({
                token: token,
                nextToken: file.getNextToken(token),
                message: &#x27;Operator , should stick to following expression&#x27;
            });
        });
    }

    // For everything else
    file.iterateNodesByType(
        [&#x27;BinaryExpression&#x27;, &#x27;AssignmentExpression&#x27;, &#x27;VariableDeclarator&#x27;, &#x27;LogicalExpression&#x27;],
        function(node) {
            var operator;
            var expression;

            if (node.type === &#x27;VariableDeclarator&#x27;) {
                expression = node.init;
                operator = &#x27;=&#x27;;
            } else {
                operator = node.operator;
                expression = node.right;
            }

            if (expression === null) {
                return;
            }

            var operatorToken = file.findPrevOperatorToken(
                file.getFirstNodeToken(expression),
                operator
            );

            var nextToken = file.getNextToken(operatorToken);

            if (operators[operator]) {
                errors.assert.noWhitespaceBetween({
                    token: operatorToken,
                    nextToken: nextToken,
                    message: &#x27;Operator &#x27; + operator + &#x27; should stick to following expression&#x27;
                });
            }
        }
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_binary_operators.prototype.configure" id="apidoc.element.jscs.disallow_space_after_binary_operators.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_binary_operators.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + &#x27; option requires array or true value&#x27;
    );

    if (isTrue) {
        operators = allOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &#x3c; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_binary_operators.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_after_binary_operators.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_binary_operators.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpaceAfterBinaryOperators&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_comma" id="apidoc.module.jscs.disallow_space_after_comma">module jscs.disallow_space_after_comma</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_comma.disallow_space_after_comma" id="apidoc.element.jscs.disallow_space_after_comma.disallow_space_after_comma">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_comma = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_comma.prototype" id="apidoc.module.jscs.disallow_space_after_comma.prototype">module jscs.disallow_space_after_comma.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_comma.prototype.check" id="apidoc.element.jscs.disallow_space_after_comma.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_comma.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptSparseArrays = this._exceptSparseArrays;
    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;,&#x27;, function(token) {
        var nextToken = file.getNextToken(token);

        if (exceptSparseArrays &#x26;&#x26; nextToken.value === &#x27;,&#x27;) {
            return;
        }
        errors.assert.noWhitespaceBetween({
            token: token,
            nextToken: nextToken,
            message: &#x27;Illegal space after comma&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_comma.prototype.configure" id="apidoc.element.jscs.disallow_space_after_comma.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_comma.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    if (typeof options !== &#x27;object&#x27;) {
        assert(
            options === true,
            this.getOptionName() + &#x27; option requires true value or an object&#x27;
        );
        var _options = {allExcept: []};
        return this.configure(_options);
    }

    assert(
        Array.isArray(options.allExcept),
        &#x27; property `allExcept` in &#x27; + this.getOptionName() + &#x27; should be an array of strings&#x27;
    );
    this._exceptSparseArrays = options.allExcept.indexOf(&#x27;sparseArrays&#x27;) &#x3e;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_comma.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_after_comma.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_comma.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpaceAfterComma&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_keywords" id="apidoc.module.jscs.disallow_space_after_keywords">module jscs.disallow_space_after_keywords</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_keywords.disallow_space_after_keywords" id="apidoc.element.jscs.disallow_space_after_keywords.disallow_space_after_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_keywords.prototype" id="apidoc.module.jscs.disallow_space_after_keywords.prototype">module jscs.disallow_space_after_keywords.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_keywords.prototype.check" id="apidoc.element.jscs.disallow_space_after_keywords.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_keywords.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue(&#x27;Keyword&#x27;, this._keywords, function(token) {
        var nextToken = file.getNextToken(token);

        // Make an exception if the next token is not a Punctuator such as a Keyword or Identifier
        if (nextToken.type !== &#x27;Punctuator&#x27;) {
            return;
        }
        errors.assert.noWhitespaceBetween({
            token: token,
            nextToken: nextToken
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_keywords.prototype.configure" id="apidoc.element.jscs.disallow_space_after_keywords.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_keywords.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(
        Array.isArray(keywords) || keywords === true,
        this.getOptionName() + &#x27; option requires array or true value&#x27;
    );

    if (keywords === true) {
        keywords = defaultKeywords;
    }

    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_keywords.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_after_keywords.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_keywords.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpaceAfterKeywords&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_line_comment" id="apidoc.module.jscs.disallow_space_after_line_comment">module jscs.disallow_space_after_line_comment</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_line_comment.disallow_space_after_line_comment" id="apidoc.element.jscs.disallow_space_after_line_comment.disallow_space_after_line_comment">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_line_comment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_line_comment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_line_comment.prototype" id="apidoc.module.jscs.disallow_space_after_line_comment.prototype">module jscs.disallow_space_after_line_comment.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_line_comment.prototype.check" id="apidoc.element.jscs.disallow_space_after_line_comment.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_line_comment.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByType(&#x27;CommentLine&#x27;, function(comment) {
        var value = comment.value;
        if (value.length &#x3e; 0 &#x26;&#x26; value[0] === &#x27; &#x27;) {
            errors.add(&#x27;Illegal space after line comment&#x27;, comment);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_line_comment.prototype.configure" id="apidoc.element.jscs.disallow_space_after_line_comment.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_line_comment.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_line_comment.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_after_line_comment.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_line_comment.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpaceAfterLineComment&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_object_keys" id="apidoc.module.jscs.disallow_space_after_object_keys">module jscs.disallow_space_after_object_keys</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_object_keys.disallow_space_after_object_keys" id="apidoc.element.jscs.disallow_space_after_object_keys.disallow_space_after_object_keys">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_object_keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_object_keys = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_object_keys.prototype" id="apidoc.module.jscs.disallow_space_after_object_keys.prototype">module jscs.disallow_space_after_object_keys.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_object_keys.prototype.check" id="apidoc.element.jscs.disallow_space_after_object_keys.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_object_keys.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptSingleline = this._exceptSingleline;
    var exceptMultiline = this._exceptMultiline;
    var exceptAligned = this._exceptAligned;
    var exceptMethod = this._exceptMethod;

    file.iterateNodesByType(&#x27;ObjectExpression&#x27;, function(node) {
        var multiline = node.getNewlineCount() &#x3e; 0;
        if (exceptSingleline &#x26;&#x26; !multiline) {
            return;
        }
        if (exceptMultiline &#x26;&#x26; multiline) {
            return;
        }

        var maxKeyEndPos = 0;
        var tokens = [];
        node.properties.forEach(function(property) {
            if (property.shorthand ||
                (exceptMethod &#x26;&#x26; property.method) ||
                property.type === &#x27;SpreadProperty&#x27;) {
                return;
            }

            var keyToken = file.getLastNodeToken(property.key);
            if (property.computed === true) {
                keyToken = file.getNextToken(keyToken);
            }

            if (exceptAligned) {
                maxKeyEndPos = Math.max(maxKeyEndPos, keyToken.getLoc().end.column);
            }
            tokens.push(keyToken);
        });

        var noSpace = true;
        if (exceptAligned) {
            var withoutSpace = 0;
            var alignedOnColon = 0;
            tokens.forEach(function(key) {
                var colon = file.getNextToken(key);
                var spaces = file.getDistanceBetween(key, colon);
                if (spaces === 0) {
                    withoutSpace++;
                } else if (spaces === maxKeyEndPos - key.getLoc().end.column) {
                    alignedOnColon++;
                }
            });

            noSpace = withoutSpace &#x3e; alignedOnColon;
        }

        tokens.forEach(function(key) {
            var colon = file.getNextToken(key);
            var spaces = (exceptAligned &#x26;&#x26; !noSpace) ? maxKeyEndPos - key.getLoc().end.column : 0;
            errors.assert.spacesBetween({
                token: key,
                nextToken: colon,
                exactly: spaces,
                message: &#x27;Illegal space after key&#x27;,
                disallowNewLine: true
            });
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_object_keys.prototype.configure" id="apidoc.element.jscs.disallow_space_after_object_keys.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_object_keys.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    if (typeof options !== &#x27;object&#x27;) {
        assert(
            options === true ||
            options === &#x27;ignoreSingleLine&#x27; ||
            options === &#x27;ignoreMultiLine&#x27;,
            this.getOptionName() +
            &#x27; option requires a true value, &#x22;ignoreSingleLine&#x22;, &#x22;ignoreMultiLine&#x22;, or an object&#x27;
        );

        var _options = {
            allExcept: []
        };

        if (options === &#x27;ignoreSingleLine&#x27;) {
            _options.allExcept.push(&#x27;singleline&#x27;);
        }
        if (options === &#x27;ignoreMultiLine&#x27;) {
            _options.allExcept.push(&#x27;multiline&#x27;);
        }

        return this.configure(_options);
    } else {
        assert(
            Array.isArray(options.allExcept),
            this.getOptionName() +
            &#x27; option object requires allExcept array property&#x27;
        );
    }

    this._exceptSingleline = options.allExcept.indexOf(&#x27;singleline&#x27;) &#x3e; -1;
    this._exceptMultiline = options.allExcept.indexOf(&#x27;multiline&#x27;) &#x3e; -1;
    this._exceptAligned = options.allExcept.indexOf(&#x27;aligned&#x27;) &#x3e; -1;
    this._exceptMethod = options.allExcept.indexOf(&#x27;method&#x27;) &#x3e; -1;
    assert(
        !this._exceptMultiline || !this._exceptAligned,
        this.getOptionName() +
        &#x27; option allExcept property cannot contain `aligned` and `multiline` at the same time&#x27;
    );
    assert(
        !this._exceptMultiline || !this._exceptSingleline,
        this.getOptionName() +
        &#x27; option allExcept property cannot contain `singleline` and `multiline` at the same time&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_object_keys.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_after_object_keys.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_object_keys.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpaceAfterObjectKeys&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_prefix_unary_operators" id="apidoc.module.jscs.disallow_space_after_prefix_unary_operators">module jscs.disallow_space_after_prefix_unary_operators</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators.disallow_space_after_prefix_unary_operators" id="apidoc.element.jscs.disallow_space_after_prefix_unary_operators.disallow_space_after_prefix_unary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_prefix_unary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_prefix_unary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_prefix_unary_operators.prototype" id="apidoc.module.jscs.disallow_space_after_prefix_unary_operators.prototype">module jscs.disallow_space_after_prefix_unary_operators.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.check" id="apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_prefix_unary_operators.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operatorIndex = this._operatorIndex;

    file.iterateNodesByType([&#x27;UnaryExpression&#x27;, &#x27;UpdateExpression&#x27;], function(node) {
        // Check &#x22;node.prefix&#x22; for prefix type of (inc|dec)rement
        if (node.prefix &#x26;&#x26; operatorIndex[node.operator]) {
            var operatorToken = node.getFirstToken();
            errors.assert.noWhitespaceBetween({
                token: operatorToken,
                nextToken: file.getNextToken(operatorToken),
                message: &#x27;Operator &#x27; + node.operator + &#x27; should stick to operand&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.configure" id="apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_prefix_unary_operators.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + &#x27; option requires array or true value&#x27;
    );

    if (isTrue) {
        operators = defaultOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &#x3c; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_prefix_unary_operators.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpaceAfterPrefixUnaryOperators&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_binary_operators" id="apidoc.module.jscs.disallow_space_before_binary_operators">module jscs.disallow_space_before_binary_operators</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_binary_operators.disallow_space_before_binary_operators" id="apidoc.element.jscs.disallow_space_before_binary_operators.disallow_space_before_binary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_binary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_binary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_binary_operators.prototype" id="apidoc.module.jscs.disallow_space_before_binary_operators.prototype">module jscs.disallow_space_before_binary_operators.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_binary_operators.prototype.check" id="apidoc.element.jscs.disallow_space_before_binary_operators.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_binary_operators.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operators = this._operatorIndex;

    // Comma
    if (operators[&#x27;,&#x27;]) {
        file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;,&#x27;, function(token) {
            if (file.getPrevToken(token).value === &#x27;,&#x27;) {
                return;
            }
            errors.assert.noWhitespaceBetween({
                token: file.getPrevToken(token, {includeComments: true}),
                nextToken: token,
                message: &#x27;Operator , should stick to previous expression&#x27;
            });
        });
    }

    // For everything else
    file.iterateNodesByType(
        [&#x27;BinaryExpression&#x27;, &#x27;AssignmentExpression&#x27;, &#x27;VariableDeclarator&#x27;, &#x27;LogicalExpression&#x27;],
        function(node) {
            var operator;
            var expression;

            if (node.type === &#x27;VariableDeclarator&#x27;) {
                expression = node.init;
                operator = &#x27;=&#x27;;
            } else {
                operator = node.operator;
                expression = node.right;
            }

            if (expression === null) {
                return;
            }

            var operatorToken = file.findPrevOperatorToken(
                file.getFirstNodeToken(expression),
                operator
            );

            var prevToken = file.getPrevToken(operatorToken, {includeComments: true});

            if (operators[operator]) {
                errors.assert.noWhitespaceBetween({
                    token: prevToken,
                    nextToken: operatorToken,
                    message: &#x27;Operator &#x27; + node.operator + &#x27; should stick to previous expression&#x27;
                });
            }
        }
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_binary_operators.prototype.configure" id="apidoc.element.jscs.disallow_space_before_binary_operators.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_binary_operators.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + &#x27; option requires array or true value&#x27;
    );

    if (isTrue) {
        operators = allOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &#x3c; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_binary_operators.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_before_binary_operators.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_binary_operators.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpaceBeforeBinaryOperators&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_block_statements" id="apidoc.module.jscs.disallow_space_before_block_statements">module jscs.disallow_space_before_block_statements</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_block_statements.disallow_space_before_block_statements" id="apidoc.element.jscs.disallow_space_before_block_statements.disallow_space_before_block_statements">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_block_statements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_block_statements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_block_statements.prototype" id="apidoc.module.jscs.disallow_space_before_block_statements.prototype">module jscs.disallow_space_before_block_statements.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_block_statements.prototype.check" id="apidoc.element.jscs.disallow_space_before_block_statements.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_block_statements.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;BlockStatement&#x27;, function(node) {
        if (isBareBlock(node)) {
            return;
        }
        var first = node.getFirstToken();

        errors.assert.noWhitespaceBetween({
            token: file.getPrevToken(first),
            nextToken: first,
            disallowNewLine: true,
            message: &#x27;Extra space before opening curly brace for block expressions&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_block_statements.prototype.configure" id="apidoc.element.jscs.disallow_space_before_block_statements.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_block_statements.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_block_statements.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_before_block_statements.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_block_statements.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpaceBeforeBlockStatements&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_comma" id="apidoc.module.jscs.disallow_space_before_comma">module jscs.disallow_space_before_comma</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_comma.disallow_space_before_comma" id="apidoc.element.jscs.disallow_space_before_comma.disallow_space_before_comma">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_comma = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_comma.prototype" id="apidoc.module.jscs.disallow_space_before_comma.prototype">module jscs.disallow_space_before_comma.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_comma.prototype.check" id="apidoc.element.jscs.disallow_space_before_comma.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_comma.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptSparseArrays = this._exceptSparseArrays;
    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;,&#x27;, function(token) {
        var prevToken = token.getPreviousCodeToken();

        if (exceptSparseArrays &#x26;&#x26; prevToken.value === &#x27;,&#x27;) {
            return;
        }
        errors.assert.noWhitespaceBetween({
            token: prevToken,
            nextToken: token,
            message: &#x27;Illegal space before comma&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_comma.prototype.configure" id="apidoc.element.jscs.disallow_space_before_comma.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_comma.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    if (typeof options !== &#x27;object&#x27;) {
        assert(
            options === true,
            this.getOptionName() + &#x27; option requires true value or an object&#x27;
        );
        var _options = {allExcept: []};
        return this.configure(_options);
    }

    assert(
        Array.isArray(options.allExcept),
        &#x27; property `allExcept` in &#x27; + this.getOptionName() + &#x27; should be an array of strings&#x27;
    );
    this._exceptSparseArrays = options.allExcept.indexOf(&#x27;sparseArrays&#x27;) &#x3e;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_comma.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_before_comma.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_comma.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpaceBeforeComma&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_keywords" id="apidoc.module.jscs.disallow_space_before_keywords">module jscs.disallow_space_before_keywords</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_keywords.disallow_space_before_keywords" id="apidoc.element.jscs.disallow_space_before_keywords.disallow_space_before_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_keywords.prototype" id="apidoc.module.jscs.disallow_space_before_keywords.prototype">module jscs.disallow_space_before_keywords.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_keywords.prototype.check" id="apidoc.element.jscs.disallow_space_before_keywords.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_keywords.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue(&#x27;Keyword&#x27;, this._keywords, function(token) {
        var prevToken = file.getPrevToken(token, {includeComments: true});
        if (!prevToken || prevToken.isComment) {
            return;
        }

        if (prevToken.type !== &#x27;Keyword&#x27; &#x26;&#x26; prevToken.value !== &#x27;;&#x27;) {
            errors.assert.noWhitespaceBetween({
                token: prevToken,
                nextToken: token,
                message: &#x27;Illegal space before &#x22;&#x27; + token.value + &#x27;&#x22; keyword&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_keywords.prototype.configure" id="apidoc.element.jscs.disallow_space_before_keywords.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_keywords.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(
        Array.isArray(keywords) || keywords === true,
        this.getOptionName() + &#x27; option requires array or true value&#x27;);

    if (keywords === true) {
        keywords = defaultKeywords;
    }

    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_keywords.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_before_keywords.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_keywords.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpaceBeforeKeywords&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_object_values" id="apidoc.module.jscs.disallow_space_before_object_values">module jscs.disallow_space_before_object_values</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_object_values.disallow_space_before_object_values" id="apidoc.element.jscs.disallow_space_before_object_values.disallow_space_before_object_values">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_object_values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_object_values = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_object_values.prototype" id="apidoc.module.jscs.disallow_space_before_object_values.prototype">module jscs.disallow_space_before_object_values.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_object_values.prototype.check" id="apidoc.element.jscs.disallow_space_before_object_values.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_object_values.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;ObjectExpression&#x27;, function(node) {
        node.properties.forEach(function(property) {
            if (property.shorthand ||
                property.type === &#x27;ObjectMethod&#x27; ||
                property.type === &#x27;SpreadProperty&#x27;) {
                return;
            }

            var keyToken = file.getFirstNodeToken(property.key);
            var colon = file.findNextToken(keyToken, &#x27;Punctuator&#x27;, &#x27;:&#x27;);

            errors.assert.noWhitespaceBetween({
                token: colon,
                nextToken: file.getNextToken(colon),
                message: &#x27;Illegal space after key colon&#x27;
            });
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_object_values.prototype.configure" id="apidoc.element.jscs.disallow_space_before_object_values.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_object_values.prototype.</span>configure
        <span class="apidocSignatureSpan">(disallow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (disallow) {
    assert(
        disallow === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_object_values.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_before_object_values.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_object_values.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpaceBeforeObjectValues&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_postfix_unary_operators" id="apidoc.module.jscs.disallow_space_before_postfix_unary_operators">module jscs.disallow_space_before_postfix_unary_operators</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators.disallow_space_before_postfix_unary_operators" id="apidoc.element.jscs.disallow_space_before_postfix_unary_operators.disallow_space_before_postfix_unary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_postfix_unary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_postfix_unary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_postfix_unary_operators.prototype" id="apidoc.module.jscs.disallow_space_before_postfix_unary_operators.prototype">module jscs.disallow_space_before_postfix_unary_operators.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.check" id="apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_postfix_unary_operators.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operatorIndex = this._operatorIndex;

    // &#x27;UpdateExpression&#x27; involve only ++ and -- operators
    file.iterateNodesByType(&#x27;UpdateExpression&#x27;, function(node) {
        // &#x22;!node.prefix&#x22; means postfix type of (inc|dec)rement
        if (!node.prefix &#x26;&#x26; operatorIndex[node.operator]) {
            var operatorToken = file.getLastNodeToken(node);
            errors.assert.noWhitespaceBetween({
                token: file.getPrevToken(operatorToken),
                nextToken: operatorToken,
                message: &#x27;Operator &#x27; + node.operator + &#x27; should stick to operand&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.configure" id="apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_postfix_unary_operators.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + &#x27; option requires array or true value&#x27;
    );

    if (isTrue) {
        operators = defaultOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &#x3c; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_postfix_unary_operators.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpaceBeforePostfixUnaryOperators&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_semicolon" id="apidoc.module.jscs.disallow_space_before_semicolon">module jscs.disallow_space_before_semicolon</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_semicolon.disallow_space_before_semicolon" id="apidoc.element.jscs.disallow_space_before_semicolon.disallow_space_before_semicolon">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_semicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_semicolon = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_semicolon.prototype" id="apidoc.module.jscs.disallow_space_before_semicolon.prototype">module jscs.disallow_space_before_semicolon.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_semicolon.prototype.check" id="apidoc.element.jscs.disallow_space_before_semicolon.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_semicolon.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;;&#x27;, function(token) {
        var prevToken = token.getPreviousCodeToken();

        if (!prevToken || prevToken.value in exceptions) {
            return;
        }

        errors.assert.noWhitespaceBetween({
            token: prevToken,
            nextToken: token,
            message: &#x27;Illegal space before semicolon&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_semicolon.prototype.configure" id="apidoc.element.jscs.disallow_space_before_semicolon.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_semicolon.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var isObject = typeof value === &#x27;object&#x27;;

    var error = this.getOptionName() + &#x27; rule requires string value true or object&#x27;;

    if (isObject) {
        assert(&#x27;allExcept&#x27; in value, error);
    } else {
        assert(value === true, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_semicolon.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_before_semicolon.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_semicolon.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpaceBeforeSemicolon&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_between_arguments" id="apidoc.module.jscs.disallow_space_between_arguments">module jscs.disallow_space_between_arguments</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_between_arguments.disallow_space_between_arguments" id="apidoc.element.jscs.disallow_space_between_arguments.disallow_space_between_arguments">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_between_arguments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_between_arguments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_between_arguments.prototype" id="apidoc.module.jscs.disallow_space_between_arguments.prototype">module jscs.disallow_space_between_arguments.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_between_arguments.prototype.check" id="apidoc.element.jscs.disallow_space_between_arguments.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_between_arguments.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType([&#x27;CallExpression&#x27;], function(node) {
        node.arguments.forEach(function(param) {
            var token = file.getFirstNodeToken(param);
            var punctuatorToken = file.getPrevToken(token);

            if (punctuatorToken.value === &#x27;,&#x27;) {
                errors.assert.noWhitespaceBetween({
                    token: punctuatorToken,
                    nextToken: file.getNextToken(punctuatorToken),
                    message: &#x27;Illegal space between arguments&#x27;
                });
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_between_arguments.prototype.configure" id="apidoc.element.jscs.disallow_space_between_arguments.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_between_arguments.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_between_arguments.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_between_arguments.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_between_arguments.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpaceBetweenArguments&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_anonymous_function_expression" id="apidoc.module.jscs.disallow_spaces_in_anonymous_function_expression">module jscs.disallow_spaces_in_anonymous_function_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.disallow_spaces_in_anonymous_function_expression" id="apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.disallow_spaces_in_anonymous_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_anonymous_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_anonymous_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_anonymous_function_expression.prototype" id="apidoc.module.jscs.disallow_spaces_in_anonymous_function_expression.prototype">module jscs.disallow_spaces_in_anonymous_function_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_anonymous_function_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType([&#x27;FunctionExpression&#x27;], function(node) {
        var functionNode = node;

        // anonymous function expressions only
        if (node.id) {
            return;
        }

        if (beforeOpeningRoundBrace) {
            var functionToken = file.getFirstNodeToken(functionNode);
            if (node.async &#x26;&#x26; functionToken.value === &#x27;async&#x27;) {
                functionToken = file.getNextToken(functionToken);
            }
            // if generator, set token to be * instead
            if (node.generator &#x26;&#x26; functionToken.value === &#x27;function&#x27;) {
                functionToken = file.getNextToken(functionToken);
            }

            errors.assert.noWhitespaceBetween({
                token: functionToken,
                nextToken: file.getNextToken(functionToken),
                message: &#x27;Illegal space before opening round brace&#x27;
            });
        }

        if (beforeOpeningCurlyBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            errors.assert.noWhitespaceBetween({
                token: file.getPrevToken(bodyToken),
                nextToken: bodyToken,
                message: &#x27;Illegal space before opening curly brace&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_anonymous_function_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option must be the object&#x27;
    );

    if (&#x27;beforeOpeningRoundBrace&#x27; in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningRoundBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    if (&#x27;beforeOpeningCurlyBrace&#x27; in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningCurlyBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + &#x27; must have beforeOpeningCurlyBrace &#x27; +
        &#x27; or beforeOpeningRoundBrace property&#x27;
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_anonymous_function_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpacesInAnonymousFunctionExpression&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_call_expression" id="apidoc.module.jscs.disallow_spaces_in_call_expression">module jscs.disallow_spaces_in_call_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_call_expression.disallow_spaces_in_call_expression" id="apidoc.element.jscs.disallow_spaces_in_call_expression.disallow_spaces_in_call_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_call_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_call_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_call_expression.prototype" id="apidoc.module.jscs.disallow_spaces_in_call_expression.prototype">module jscs.disallow_spaces_in_call_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_call_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType([&#x27;CallExpression&#x27;, &#x27;NewExpression&#x27;], function(node) {
        var lastCalleeToken = file.getLastNodeToken(node.callee);
        var roundBraceToken = file.findNextToken(lastCalleeToken, &#x27;Punctuator&#x27;, &#x27;(&#x27;);

        // CallExpressions can&#x27;t have missing parens, otherwise they&#x27;re identifiers
        if (node.type === &#x27;NewExpression&#x27;) {
            if (roundBraceToken === null || roundBraceToken.parentElement !== node) {
                return;
            }
        }

        errors.assert.noWhitespaceBetween({
            token: file.getPrevToken(roundBraceToken),
            nextToken: roundBraceToken,
            message: &#x27;Illegal space before opening round brace&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_call_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_call_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpacesInCallExpression&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_conditional_expression" id="apidoc.module.jscs.disallow_spaces_in_conditional_expression">module jscs.disallow_spaces_in_conditional_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression.disallow_spaces_in_conditional_expression" id="apidoc.element.jscs.disallow_spaces_in_conditional_expression.disallow_spaces_in_conditional_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_conditional_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_conditional_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_conditional_expression.prototype" id="apidoc.module.jscs.disallow_spaces_in_conditional_expression.prototype">module jscs.disallow_spaces_in_conditional_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_conditional_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType([&#x27;ConditionalExpression&#x27;], function(node) {

        var test = node.test;
        var consequent = node.consequent;
        var consequentToken = file.getFirstNodeToken(consequent);
        var alternate = node.alternate;
        var alternateToken = file.getFirstNodeToken(alternate);
        var questionMarkToken = file.findPrevOperatorToken(consequentToken, &#x27;?&#x27;);
        var colonToken = file.findPrevOperatorToken(alternateToken, &#x27;:&#x27;);
        var token;

        if (this._afterTest &#x26;&#x26; file.isOnTheSameLine(test, questionMarkToken)) {
            token = file.getPrevToken(questionMarkToken);

            errors.assert.noWhitespaceBetween({
                token: token,
                nextToken: questionMarkToken,
                message: &#x27;Illegal space after test&#x27;
            });
        }

        if (this._beforeConsequent &#x26;&#x26; file.isOnTheSameLine(questionMarkToken, consequent)) {
            token = file.getNextToken(questionMarkToken);

            errors.assert.noWhitespaceBetween({
                token: questionMarkToken,
                nextToken: token,
                message: &#x27;Illegal space before consequent&#x27;
            });
        }

        if (this._afterConsequent &#x26;&#x26; file.isOnTheSameLine(consequent, colonToken)) {
            token = file.getPrevToken(colonToken);

            errors.assert.noWhitespaceBetween({
                token: token,
                nextToken: colonToken,
                message: &#x27;Illegal space after consequent&#x27;
            });
        }

        if (this._beforeAlternate &#x26;&#x26; file.isOnTheSameLine(colonToken, alternate)) {
            token = file.getNextToken(colonToken);
            errors.assert.noWhitespaceBetween({
                token: colonToken,
                nextToken: token,
                message: &#x27;Illegal space before alternate&#x27;
            });
        }
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_conditional_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var validProperties = [
        &#x27;afterTest&#x27;,
        &#x27;beforeConsequent&#x27;,
        &#x27;afterConsequent&#x27;,
        &#x27;beforeAlternate&#x27;
    ];
    var optionName = this.getOptionName();

    if (options === true) {
        options = {
            &#x27;afterTest&#x27;: true,
            &#x27;beforeConsequent&#x27;: true,
            &#x27;afterConsequent&#x27;: true,
            &#x27;beforeAlternate&#x27;: true
        };
    }

    assert(
        typeof options === &#x27;object&#x27;,
        optionName + &#x27; option requires a true value or an object&#x27;
    );

    var isProperlyConfigured = validProperties.some(function(key) {
        var isPresent = key in options;

        if (isPresent) {
            assert(
                options[key] === true,
                optionName + &#x27;.&#x27; + key + &#x27; property requires true value or should be removed&#x27;
            );
        }

        return isPresent;
    });

    assert(
        isProperlyConfigured,
        optionName + &#x27; must have at least 1 of the following properties: &#x27; + validProperties.join(&#x27;, &#x27;)
    );

    validProperties.forEach(function(property) {
        this[&#x27;_&#x27; + property] = Boolean(options[property]);
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_conditional_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpacesInConditionalExpression&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_for_statement" id="apidoc.module.jscs.disallow_spaces_in_for_statement">module jscs.disallow_spaces_in_for_statement</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_for_statement.disallow_spaces_in_for_statement" id="apidoc.element.jscs.disallow_spaces_in_for_statement.disallow_spaces_in_for_statement">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_for_statement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_for_statement = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_for_statement.prototype" id="apidoc.module.jscs.disallow_spaces_in_for_statement.prototype">module jscs.disallow_spaces_in_for_statement.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_for_statement.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;ForStatement&#x27;, function(node) {
        if (node.test) {
            var testToken = file.getFirstNodeToken(node.test);
            errors.assert.noWhitespaceBetween({
                token: file.getPrevToken(testToken),
                nextToken: testToken,
                message: &#x27;Space found after semicolon&#x27;
            });
        }
        if (node.update) {
            var updateToken = file.getFirstNodeToken(node.update);
            errors.assert.noWhitespaceBetween({
                token: file.getPrevToken(updateToken),
                nextToken: updateToken,
                message: &#x27;Space found after semicolon&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_for_statement.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_for_statement.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpacesInForStatement&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_function" id="apidoc.module.jscs.disallow_spaces_in_function">module jscs.disallow_spaces_in_function</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function.disallow_spaces_in_function" id="apidoc.element.jscs.disallow_spaces_in_function.disallow_spaces_in_function">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_function = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_function.prototype" id="apidoc.module.jscs.disallow_spaces_in_function.prototype">module jscs.disallow_spaces_in_function.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_function.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType([&#x27;FunctionDeclaration&#x27;, &#x27;FunctionExpression&#x27;], function(node) {
        // for a named function, use node.id
        var functionNode = node.id || node;
        var parent = node.parentElement;

        // Ignore syntactic sugar for getters and setters.
        if (parent.type === &#x27;Property&#x27; &#x26;&#x26; (parent.kind === &#x27;get&#x27; || parent.kind === &#x27;set&#x27;)) {
            return;
        }

        // shorthand or constructor methods
        if (parent.method || parent.type === &#x27;MethodDefinition&#x27;) {
            functionNode = parent.key;
        }

        if (beforeOpeningRoundBrace) {
            var functionToken = file.getFirstNodeToken(functionNode);
            if (node.async &#x26;&#x26; functionToken.value === &#x27;async&#x27;) {
                functionToken = file.getNextToken(functionToken);
            }
            // if generator, set token to be * instead
            if (node.generator &#x26;&#x26; functionToken.value === &#x27;function&#x27;) {
                functionToken = file.getNextToken(functionToken);
            }
            errors.assert.noWhitespaceBetween({
                token: functionToken,
                nextToken: file.getNextToken(functionToken),
                message: &#x27;Illegal space before opening round brace&#x27;
            });
        }

        if (beforeOpeningCurlyBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            errors.assert.noWhitespaceBetween({
                token: file.getPrevToken(bodyToken),
                nextToken: bodyToken,
                message: &#x27;Illegal space before opening curly brace&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_function.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option must be the object&#x27;
    );

    if (&#x27;beforeOpeningRoundBrace&#x27; in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningRoundBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    if (&#x27;beforeOpeningCurlyBrace&#x27; in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningCurlyBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + &#x27; must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property&#x27;
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_function.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpacesInFunction&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_function_declaration" id="apidoc.module.jscs.disallow_spaces_in_function_declaration">module jscs.disallow_spaces_in_function_declaration</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_declaration.disallow_spaces_in_function_declaration" id="apidoc.element.jscs.disallow_spaces_in_function_declaration.disallow_spaces_in_function_declaration">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_declaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_function_declaration = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_function_declaration.prototype" id="apidoc.module.jscs.disallow_spaces_in_function_declaration.prototype">module jscs.disallow_spaces_in_function_declaration.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_declaration.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType([&#x27;FunctionDeclaration&#x27;], function(node) {
        // Exception for `export default function` #1376
        if (!node.id) {
            return;
        }

        if (beforeOpeningRoundBrace) {
            var functionToken = file.getFirstNodeToken(node.id);
            if (node.async &#x26;&#x26; functionToken.value === &#x27;async&#x27;) {
                functionToken = file.getNextToken(functionToken);
            }
            // if generator, set token to be * instead
            if (node.generator &#x26;&#x26; functionToken.value === &#x27;function&#x27;) {
                functionToken = file.getNextToken(functionToken);
            }
            errors.assert.noWhitespaceBetween({
                token: functionToken,
                nextToken: file.getNextToken(functionToken),
                message: &#x27;Illegal space before opening round brace&#x27;
            });
        }

        if (beforeOpeningCurlyBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            errors.assert.noWhitespaceBetween({
                token: file.getPrevToken(bodyToken),
                nextToken: bodyToken,
                message: &#x27;Illegal space before opening curly brace&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_declaration.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option must be the object&#x27;
    );

    if (&#x27;beforeOpeningRoundBrace&#x27; in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningRoundBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    if (&#x27;beforeOpeningCurlyBrace&#x27; in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningCurlyBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + &#x27; must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property&#x27;
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_declaration.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpacesInFunctionDeclaration&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_function_expression" id="apidoc.module.jscs.disallow_spaces_in_function_expression">module jscs.disallow_spaces_in_function_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_expression.disallow_spaces_in_function_expression" id="apidoc.element.jscs.disallow_spaces_in_function_expression.disallow_spaces_in_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_function_expression.prototype" id="apidoc.module.jscs.disallow_spaces_in_function_expression.prototype">module jscs.disallow_spaces_in_function_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType(&#x27;FunctionExpression&#x27;, function(node) {

        // for a named function, use node.id
        var functionNode = node.id || node;

        if (beforeOpeningRoundBrace) {
            var functionToken = file.getFirstNodeToken(functionNode);
            if (node.async &#x26;&#x26; functionToken.value === &#x27;async&#x27;) {
                functionToken = file.getNextToken(functionToken);
            }
            // if generator, set token to be * instead
            if (node.generator &#x26;&#x26; functionToken.value === &#x27;function&#x27;) {
                functionToken = file.getNextToken(functionToken);
            }
            errors.assert.noWhitespaceBetween({
                token: functionToken,
                nextToken: file.getNextToken(functionToken),
                message: &#x27;Illegal space before opening round brace&#x27;
            });
        }

        if (beforeOpeningCurlyBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            errors.assert.noWhitespaceBetween({
                token: file.getPrevToken(bodyToken),
                nextToken: bodyToken,
                message: &#x27;Illegal space before opening curly brace&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option must be the object&#x27;
    );

    if (&#x27;beforeOpeningRoundBrace&#x27; in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningRoundBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    if (&#x27;beforeOpeningCurlyBrace&#x27; in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningCurlyBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + &#x27; must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property&#x27;
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpacesInFunctionExpression&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_generator" id="apidoc.module.jscs.disallow_spaces_in_generator">module jscs.disallow_spaces_in_generator</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_generator.disallow_spaces_in_generator" id="apidoc.element.jscs.disallow_spaces_in_generator.disallow_spaces_in_generator">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_generator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_generator = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_generator.prototype" id="apidoc.module.jscs.disallow_spaces_in_generator.prototype">module jscs.disallow_spaces_in_generator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_generator.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_generator.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_generator.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeStar = this._beforeStar;
    var afterStar = this._afterStar;

    file.iterateNodesByType([&#x27;FunctionDeclaration&#x27;, &#x27;FunctionExpression&#x27;], function(node) {
        if (!node.generator) {
            return;
        }

        var parent = node.parentElement;
        var shorthand = node.shorthand;

        // shorthand or constructor methods
        if (parent.method || parent.type === &#x27;MethodDefinition&#x27;) {
            node = parent.key;
        }

        var currentToken = file.getFirstNodeToken(node);

        if (node.async &#x26;&#x26; currentToken.value === &#x27;async&#x27;) {
            currentToken = file.getNextToken(currentToken);
        }

        if (beforeStar &#x26;&#x26; !shorthand) {
            // currentToken assigned outside of function
            errors.assert.noWhitespaceBetween({
                token: currentToken,
                nextToken: file.getNextToken(currentToken),
                message: &#x27;Illegal space before star&#x27;
            });
        }

        if (afterStar) {
            if (shorthand) {
                currentToken = file.getPrevToken(currentToken);
            } else {
                // currentToken reassigned for star token
                currentToken = file.getNextToken(currentToken);
            }

            errors.assert.noWhitespaceBetween({
                token: currentToken,
                nextToken: file.getNextToken(currentToken),
                message: &#x27;Illegal space after star&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_generator.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_generator.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_generator.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option must be an object&#x27;
    );

    if (&#x27;beforeStar&#x27; in options) {
        assert(
            options.beforeStar === true,
            this.getOptionName() + &#x27;.beforeStar &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }
    if (&#x27;afterStar&#x27; in options) {
        assert(
            options.afterStar === true,
            this.getOptionName() + &#x27;.afterStar &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    assert(
        options.beforeStar || options.afterStar,
        this.getOptionName() + &#x27; must have beforeStar or afterStar property&#x27;
    );

    this._beforeStar = options.beforeStar;
    this._afterStar = options.afterStar;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_generator.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_generator.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_generator.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpacesInGenerator&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_named_function_expression" id="apidoc.module.jscs.disallow_spaces_in_named_function_expression">module jscs.disallow_spaces_in_named_function_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression.disallow_spaces_in_named_function_expression" id="apidoc.element.jscs.disallow_spaces_in_named_function_expression.disallow_spaces_in_named_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_named_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_named_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_named_function_expression.prototype" id="apidoc.module.jscs.disallow_spaces_in_named_function_expression.prototype">module jscs.disallow_spaces_in_named_function_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_named_function_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType([&#x27;FunctionExpression&#x27;], function(node) {
        var functionNode = node.id;
        var parent = node.parentElement;

        // Ignore syntactic sugar for getters and setters.
        if (parent.type === &#x27;Property&#x27; &#x26;&#x26; (parent.kind === &#x27;get&#x27; || parent.kind === &#x27;set&#x27;)) {
            return;
        }

        // shorthand or constructor methods
        if (parent.method || parent.type === &#x27;MethodDefinition&#x27;) {
            functionNode = parent.key;
        }

        // named function expressions only
        if (node.id) {
            if (beforeOpeningRoundBrace) {
                var functionToken = file.getFirstNodeToken(functionNode);
                if (node.async &#x26;&#x26; functionToken.value === &#x27;async&#x27;) {
                    functionToken = file.getNextToken(functionToken);
                }
                errors.assert.noWhitespaceBetween({
                    token: functionToken,
                    nextToken: file.getNextToken(functionToken),
                    message: &#x27;Illegal space before opening round brace&#x27;
                });
            }

            if (beforeOpeningCurlyBrace) {
                var bodyToken = file.getFirstNodeToken(node.body);
                errors.assert.noWhitespaceBetween({
                    token: file.getPrevToken(bodyToken),
                    nextToken: bodyToken,
                    message: &#x27;Illegal space before opening curly brace&#x27;
                });
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_named_function_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option must be the object&#x27;
    );

    if (&#x27;beforeOpeningRoundBrace&#x27; in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningRoundBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    if (&#x27;beforeOpeningCurlyBrace&#x27; in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningCurlyBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + &#x27; must have beforeOpeningCurlyBrace &#x27; +
        &#x27;or beforeOpeningRoundBrace property&#x27;
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_named_function_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpacesInNamedFunctionExpression&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_array_brackets" id="apidoc.module.jscs.disallow_spaces_inside_array_brackets">module jscs.disallow_spaces_inside_array_brackets</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets.disallow_spaces_inside_array_brackets" id="apidoc.element.jscs.disallow_spaces_inside_array_brackets.disallow_spaces_inside_array_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_array_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_array_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_array_brackets.prototype" id="apidoc.module.jscs.disallow_spaces_inside_array_brackets.prototype">module jscs.disallow_spaces_inside_array_brackets.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.check" id="apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_array_brackets.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateNodesByType(&#x27;ArrayExpression&#x27;, function(node) {
        var openBracket = node.getFirstToken();
        var afterOpen = file.getNextToken(openBracket, {includeComments: true});
        var closeBracket = file.getLastNodeToken(node);
        var beforeClose = file.getPrevToken(closeBracket, {includeComments: true});

        // Skip for empty array brackets
        if (afterOpen.value === &#x27;]&#x27;) {
            return;
        }

        if (!(afterOpen.value in exceptions)) {
            errors.assert.noWhitespaceBetween({
                token: openBracket,
                nextToken: afterOpen,
                message: &#x27;Illegal space after opening bracket&#x27;
            });
        }

        if (!(beforeClose.value in exceptions)) {
            errors.assert.noWhitespaceBetween({
                token: beforeClose,
                nextToken: closeBracket,
                message: &#x27;Illegal space before closing bracket&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.configure" id="apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_array_brackets.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var mode;
    var modes = {
        &#x27;all&#x27;: true,
        &#x27;nested&#x27;: true
    };
    var isObject = typeof value === &#x27;object&#x27;;

    var error = this.getOptionName() + &#x27; rule&#x27; +
    &#x27; requires string value &#x22;all&#x22; or &#x22;nested&#x22; or object&#x27;;

    if (typeof value === &#x27;string&#x27; || value === true) {
        assert(modes[value === true ? &#x27;all&#x27; : value], error);

    } else if (isObject) {
        assert(&#x27;allExcept&#x27; in value, error);
    } else {
        assert(false, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);

    } else {
        mode = value;
    }

    if (mode === &#x27;nested&#x27;) {
        this._exceptions[&#x27;[&#x27;] = this._exceptions[&#x27;]&#x27;] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_array_brackets.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpacesInsideArrayBrackets&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_brackets" id="apidoc.module.jscs.disallow_spaces_inside_brackets">module jscs.disallow_spaces_inside_brackets</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_brackets.disallow_spaces_inside_brackets" id="apidoc.element.jscs.disallow_spaces_inside_brackets.disallow_spaces_inside_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_brackets.prototype" id="apidoc.module.jscs.disallow_spaces_inside_brackets.prototype">module jscs.disallow_spaces_inside_brackets.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.check" id="apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_brackets.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;[&#x27;, function(token) {
        var nextToken = file.getNextToken(token, { includeComments: true });
        var value = nextToken.getSourceCode();

        if (value in exceptions) {
            return;
        }

        // Skip for empty array brackets
        if (value === &#x27;]&#x27;) {
            return;
        }

        errors.assert.noWhitespaceBetween({
            token: token,
            nextToken: nextToken,
            message: &#x27;Illegal space after opening bracket&#x27;
        });
    });

    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;]&#x27;, function(token) {
        var prevToken = file.getPrevToken(token, { includeComments: true });
        var value = prevToken.getSourceCode();

        if (value in exceptions) {
            return;
        }

        // Skip for empty array brackets
        if (value === &#x27;[&#x27;) {
            return;
        }

        errors.assert.noWhitespaceBetween({
            token: prevToken,
            nextToken: token,
            message: &#x27;Illegal space before closing bracket&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.configure" id="apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_brackets.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var isObject = typeof value === &#x27;object&#x27;;

    var error = this.getOptionName() + &#x27; rule requires string value true or object&#x27;;

    if (isObject) {
        assert(&#x27;allExcept&#x27; in value, error);
    } else {
        assert(value === true, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_brackets.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpacesInsideBrackets&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_imported_object_braces" id="apidoc.module.jscs.disallow_spaces_inside_imported_object_braces">module jscs.disallow_spaces_inside_imported_object_braces</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.disallow_spaces_inside_imported_object_braces" id="apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.disallow_spaces_inside_imported_object_braces">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_imported_object_braces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_imported_object_braces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_imported_object_braces.prototype" id="apidoc.module.jscs.disallow_spaces_inside_imported_object_braces.prototype">module jscs.disallow_spaces_inside_imported_object_braces.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.check" id="apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_imported_object_braces.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType([&#x27;ImportDeclaration&#x27;], function(node) {

        if (!node.specifiers) {
            return;
        }

        node.specifiers.forEach(function(specifier) {

            if (specifier.type !== &#x27;ImportSpecifier&#x27;) {
                return;
            }

            var maybeOpeningBrace = file.getPrevToken(specifier.getFirstToken());
            var maybeClosingBrace = file.getNextToken(specifier.getLastToken());

            if (maybeOpeningBrace.value === &#x27;{&#x27;) {
                errors.assert.noWhitespaceBetween({
                    token: maybeOpeningBrace,
                    nextToken: specifier.getFirstToken(),
                    message: &#x27;Illegal space after opening curly brace&#x27;
                });
            }

            if (maybeClosingBrace.value === &#x27;}&#x27;) {
                errors.assert.noWhitespaceBetween({
                    token: specifier.getLastToken(),
                    nextToken: maybeClosingBrace,
                    message: &#x27;Illegal space before closing curly brace&#x27;
                });
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.configure" id="apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_imported_object_braces.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_imported_object_braces.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpacesInsideImportedObjectBraces&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_object_brackets" id="apidoc.module.jscs.disallow_spaces_inside_object_brackets">module jscs.disallow_spaces_inside_object_brackets</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets.disallow_spaces_inside_object_brackets" id="apidoc.element.jscs.disallow_spaces_inside_object_brackets.disallow_spaces_inside_object_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_object_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_object_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_object_brackets.prototype" id="apidoc.module.jscs.disallow_spaces_inside_object_brackets.prototype">module jscs.disallow_spaces_inside_object_brackets.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.check" id="apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_object_brackets.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateNodesByType([&#x27;ObjectExpression&#x27;, &#x27;ObjectPattern&#x27;], function(node) {
        var openingBracket = node.getFirstToken();
        var nextToken = file.getNextToken(openingBracket);

        errors.assert.noWhitespaceBetween({
            token: openingBracket,
            nextToken: nextToken,
            message: &#x27;Illegal space after opening curly brace&#x27;
        });

        var closingBracket = file.getLastNodeToken(node);
        var prevToken = file.getPrevToken(closingBracket);

        if (prevToken.value in exceptions) {
            return;
        }

        errors.assert.noWhitespaceBetween({
            token: prevToken,
            nextToken: closingBracket,
            message: &#x27;Illegal space before closing curly brace&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.configure" id="apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_object_brackets.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var mode;
    var modes = {
        &#x27;all&#x27;: true,
        &#x27;nested&#x27;: true
    };
    var isObject = typeof value === &#x27;object&#x27;;

    var error = this.getOptionName() + &#x27; rule&#x27; +
    &#x27; requires string &#x22;all&#x22; or &#x22;nested&#x22;, true value or object&#x27;;

    if (typeof value === &#x27;string&#x27; || value === true) {
        assert(modes[value === true ? &#x27;all&#x27; : value], error);

    } else if (isObject) {
        assert(&#x27;allExcept&#x27; in value, error);
    } else {
        assert(false, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);

    } else {
        mode = value;
    }

    if (mode === &#x27;nested&#x27;) {
        this._exceptions[&#x27;}&#x27;] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_object_brackets.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpacesInsideObjectBrackets&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_parentheses" id="apidoc.module.jscs.disallow_spaces_inside_parentheses">module jscs.disallow_spaces_inside_parentheses</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parentheses.disallow_spaces_inside_parentheses" id="apidoc.element.jscs.disallow_spaces_inside_parentheses.disallow_spaces_inside_parentheses">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parentheses
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_parentheses = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_parentheses.prototype" id="apidoc.module.jscs.disallow_spaces_inside_parentheses.prototype">module jscs.disallow_spaces_inside_parentheses.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.check" id="apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parentheses.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var only = this._only;
    var singleQuote = this._onlySingleQuote;
    var doubleQuote = this._onlyDoubleQuote;
    var alreadyAdded = [];

    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;(&#x27;, function(token) {
        var nextToken = file.getNextToken(token, {includeComments: true});
        var value = nextToken.getSourceCode();
        var shouldReturn = true;

        if (doubleQuote &#x26;&#x26; nextToken.type === &#x27;String&#x27; &#x26;&#x26; value[0] === &#x27;&#x22;&#x27;) {
            shouldReturn = false;
        }

        if (singleQuote &#x26;&#x26; nextToken.type === &#x27;String&#x27; &#x26;&#x26; value[0] === &#x27;\&#x27;&#x27;) {
            shouldReturn = false;
        }

        if (only &#x26;&#x26; value in only) {
            shouldReturn = false;
        }

        if (!only) {
            shouldReturn = false;
        }

        if (shouldReturn) {
            return;
        }

        var isAdded = errors.assert.noWhitespaceBetween({
            token: token,
            nextToken: nextToken,
            message: &#x27;Illegal space after opening round bracket&#x27;
        });

        if (isAdded) {
            alreadyAdded.push(token);
        }
    });

    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;)&#x27;, function(token) {
        var prevToken = file.getPrevToken(token, {includeComments: true});
        var value = prevToken.getSourceCode();
        var shouldReturn = true;

        // Do not check already found errors, like &#x22;function ( ) { ...&#x22;
        if (alreadyAdded.indexOf(prevToken) &#x3e; -1) {
            return;
        }

        if (doubleQuote &#x26;&#x26; prevToken.type === &#x27;String&#x27; &#x26;&#x26; value[value.length - 1] === &#x27;&#x22;&#x27;) {
            shouldReturn = false;
        }

        if (singleQuote &#x26;&#x26; prevToken.type === &#x27;String&#x27; &#x26;&#x26; value[value.length - 1] === &#x27;\&#x27;&#x27;) {
            shouldReturn = false;
        }

        if (only) {
            if (value in only) {
                shouldReturn = false;
            }

            if (
                value === &#x27;]&#x27; &#x26;&#x26;
                prevToken.parentElement.type === &#x27;MemberExpression&#x27;
            ) {
                shouldReturn = true;
            }
        } else {
            shouldReturn = false;
        }

        if (shouldReturn) {
            return;
        }

        errors.assert.noWhitespaceBetween({
            token: prevToken,
            nextToken: token,
            message: &#x27;Illegal space before closing round bracket&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.configure" id="apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parentheses.prototype.</span>configure
        <span class="apidocSignatureSpan">(option)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (option) {
    var isObject = typeof option === &#x27;object&#x27;;

    var error = this.getOptionName() + &#x27; option requires&#x27; +
        &#x27; true or object value with &#x22;only&#x22; properties &#x27;;

    // backcompat for 1.10: {all: true} #1027
    if (isObject &#x26;&#x26; option.all === true) {
        option = true;
    }

    if (typeof option === &#x27;boolean&#x27;) {
        assert(option === true, error);
    } else if (isObject) {
        assert(&#x27;only&#x27; in option, error);
    } else {
        assert(false, error);
    }

    this._onlySingleQuote = false;
    this._onlyDoubleQuote = false;
    this._only = null;

    if (option.only) {
        this._only = {};

        (option.only).forEach(function(value) {
            if (value === &#x27;\&#x27;&#x27;) {
                this._onlySingleQuote = true;
            }

            if (value === &#x27;&#x22;&#x27;) {
                this._onlyDoubleQuote = true;
            }

            this._only[value] = true;
        }, this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parentheses.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpacesInsideParentheses&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_parenthesized_expression" id="apidoc.module.jscs.disallow_spaces_inside_parenthesized_expression">module jscs.disallow_spaces_inside_parenthesized_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.disallow_spaces_inside_parenthesized_expression" id="apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.disallow_spaces_inside_parenthesized_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parenthesized_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_parenthesized_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_parenthesized_expression.prototype" id="apidoc.module.jscs.disallow_spaces_inside_parenthesized_expression.prototype">module jscs.disallow_spaces_inside_parenthesized_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.check" id="apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parenthesized_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;(&#x27;, function(token) {
        var nextToken = file.getNextToken(token, {includeComments: true});
        var value = nextToken.isComment ?
            nextToken.type === &#x27;CommentBlock&#x27; ? &#x27;/*&#x27; : &#x27;//&#x27; :
            nextToken.value;

        // Skip empty parentheses and explicit exceptions
        if (value === &#x27;)&#x27; || value in exceptions) {
            return;
        }

        // Skip non-expression parentheses
        var type = TokenCategorizer.categorizeOpenParen(token);
        if (type !== &#x27;ParenthesizedExpression&#x27;) {
            return;
        }

        errors.assert.noWhitespaceBetween({
            token: token,
            nextToken: nextToken,
            message: &#x27;Illegal space after opening grouping parenthesis&#x27;
        });
    });

    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;)&#x27;, function(token) {
        var prevToken = file.getPrevToken(token, {includeComments: true});
        var value = prevToken.isComment ?
            prevToken.type === &#x27;CommentBlock&#x27; ? &#x27;*/&#x27; : &#x27;&#x27; :
            prevToken.value;

        // Skip empty parentheses and explicit exceptions
        if (value === &#x27;(&#x27; || value in exceptions) {
            return;
        }

        // Skip non-expression parentheses
        var type = TokenCategorizer.categorizeCloseParen(token);
        if (type !== &#x27;ParenthesizedExpression&#x27;) {
            return;
        }

        errors.assert.noWhitespaceBetween({
            token: prevToken,
            nextToken: token,
            message: &#x27;Illegal space before closing grouping parenthesis&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.configure" id="apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parenthesized_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var isObject = typeof value === &#x27;object&#x27;;

    var error = this.getOptionName() + &#x27; rule requires string value true or object&#x27;;

    if (isObject) {
        assert(&#x27;allExcept&#x27; in value, error);
    } else {
        assert(value === true, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parenthesized_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpacesInsideParenthesizedExpression&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_template_string_placeholders" id="apidoc.module.jscs.disallow_spaces_inside_template_string_placeholders">module jscs.disallow_spaces_inside_template_string_placeholders</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.disallow_spaces_inside_template_string_placeholders" id="apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.disallow_spaces_inside_template_string_placeholders">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_template_string_placeholders
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_template_string_placeholders = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_template_string_placeholders.prototype" id="apidoc.module.jscs.disallow_spaces_inside_template_string_placeholders.prototype">module jscs.disallow_spaces_inside_template_string_placeholders.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.check" id="apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_template_string_placeholders.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;TemplateLiteral&#x27;, function(node) {
        node.childElements
            .filter(function(element) {
                return element.isToken &#x26;&#x26; element.type === &#x27;Punctuator&#x27;;
            })
            .forEach(function(element) {
                if (element.value === &#x27;${&#x27; &#x26;&#x26; element.nextSibling.isWhitespace) {
                    errors.assert.noWhitespaceBetween({
                        token: element,
                        nextToken: element.getNextCodeToken(),
                        message: &#x27;Illegal space after &#x22;${&#x22;&#x27;
                    });
                }
                if (element.value === &#x27;}&#x27; &#x26;&#x26; element.previousSibling.isWhitespace) {
                    errors.assert.noWhitespaceBetween({
                        token: element.getPreviousCodeToken(),
                        nextToken: element,
                        message: &#x27;Illegal space before &#x22;}&#x22;&#x27;
                    });
                }
            });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.configure" id="apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_template_string_placeholders.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_template_string_placeholders.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowSpacesInsideTemplateStringPlaceholders&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_tabs" id="apidoc.module.jscs.disallow_tabs">module jscs.disallow_tabs</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_tabs.disallow_tabs" id="apidoc.element.jscs.disallow_tabs.disallow_tabs">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_tabs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_tabs = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_tabs.prototype" id="apidoc.module.jscs.disallow_tabs.prototype">module jscs.disallow_tabs.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_tabs.prototype.check" id="apidoc.element.jscs.disallow_tabs.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_tabs.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByType(&#x27;Whitespace&#x27;, function(whitespace) {
        var match = whitespace.value.match(/\t/);
        if (match) {
            errors.add(&#x27;Tab found&#x27;, whitespace, match.index);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_tabs.prototype.configure" id="apidoc.element.jscs.disallow_tabs.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_tabs.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_tabs.prototype.getOptionName" id="apidoc.element.jscs.disallow_tabs.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_tabs.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowTabs&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_trailing_comma" id="apidoc.module.jscs.disallow_trailing_comma">module jscs.disallow_trailing_comma</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_comma.disallow_trailing_comma" id="apidoc.element.jscs.disallow_trailing_comma.disallow_trailing_comma">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_trailing_comma = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_trailing_comma.prototype" id="apidoc.module.jscs.disallow_trailing_comma.prototype">module jscs.disallow_trailing_comma.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_comma.prototype._fix" id="apidoc.element.jscs.disallow_trailing_comma.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.disallow_trailing_comma.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    error.element.remove();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &#x26;&#x26; instance._fix) {
        // &#x22;error.fixed = true&#x22; should go first, so rule can
        // decide for itself (with &#x22;error.fixed = false&#x22;)
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_comma.prototype.check" id="apidoc.element.jscs.disallow_trailing_comma.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_trailing_comma.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType([
        &#x27;ObjectExpression&#x27;, &#x27;ArrayExpression&#x27;,
        &#x27;ObjectPattern&#x27;, &#x27;ArrayPattern&#x27;
    ], function(node) {
        var closingToken = file.getLastNodeToken(node);
        var comma = closingToken.getPreviousCodeToken();

        if (comma.type === &#x27;Punctuator&#x27; &#x26;&#x26; comma.value === &#x27;,&#x27;) {
            errors.add(
                &#x27;Extra comma following the final element of an array or object literal&#x27;,
                comma
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_comma.prototype.configure" id="apidoc.element.jscs.disallow_trailing_comma.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_trailing_comma.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_comma.prototype.getOptionName" id="apidoc.element.jscs.disallow_trailing_comma.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_trailing_comma.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowTrailingComma&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_trailing_whitespace" id="apidoc.module.jscs.disallow_trailing_whitespace">module jscs.disallow_trailing_whitespace</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_whitespace.disallow_trailing_whitespace" id="apidoc.element.jscs.disallow_trailing_whitespace.disallow_trailing_whitespace">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_whitespace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_trailing_whitespace = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_trailing_whitespace.prototype" id="apidoc.module.jscs.disallow_trailing_whitespace.prototype">module jscs.disallow_trailing_whitespace.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_whitespace.prototype._fix" id="apidoc.element.jscs.disallow_trailing_whitespace.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.disallow_trailing_whitespace.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var element = error.element;
    var newValue;
    var lines = element.getValueLineInfo();
    var line = lines[error.additional.lineNumber];
    if (element.isWhitespace) {
        line.text = &#x27;&#x27;;
    }
    if (element.isComment) {
        line.text = line.text.replace(/\s+$/, &#x27;&#x27;);
    }

    newValue = lines.map(function(line) {
        return line.text + (line.lineBreak || &#x27;&#x27;);
    }).join(&#x27;&#x27;);

    var newElement = new Token(element.type, newValue);
    element.parentElement.replaceChild(newElement, element);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &#x26;&#x26; instance._fix) {
        // &#x22;error.fixed = true&#x22; should go first, so rule can
        // decide for itself (with &#x22;error.fixed = false&#x22;)
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_whitespace.prototype.check" id="apidoc.element.jscs.disallow_trailing_whitespace.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_trailing_whitespace.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var program = file.getProgram();

    if (!program) {
        return;
    }

    var lastToken = program.getLastToken();
    if (lastToken &#x26;&#x26; lastToken.type === &#x27;EOF&#x27;) {
        lastToken = lastToken.getPreviousToken();
    }
    program.selectTokensByType(&#x27;Whitespace&#x27;).forEach(function(whitespace) {
        whitespace.getValueLineInfo().some(function(line, i) {
            if (this._ignoreEmptyLines &#x26;&#x26; i &#x3e; 0) {
                return true;
            }
            if (line.text &#x26;&#x26; (line.lineBreak || whitespace === lastToken)) {
                errors.cast({
                    message: &#x27;Illegal trailing whitespace&#x27;,
                    element: whitespace,
                    offset: line.offset,
                    additional: {
                        lineNumber: i
                    }
                });
            }
        }, this);
    }, this);
    program.selectTokensByType(&#x27;CommentBlock&#x27;).concat(program.selectTokensByType(&#x27;CommentLine&#x27;))
        .forEach(function(comment) {
            var lines = comment.getValueLineInfo();
            lines.forEach(function(line, i) {
                if (i &#x3e; 0 &#x26;&#x26; this._ignoreEmptyLines &#x26;&#x26; line.text.trim() === &#x27;&#x27;) {
                    return;
                }
                if (comment.type === &#x27;CommentBlock&#x27; &#x26;&#x26; i === lines.length - 1) {
                    return;
                }
                if (line.text.match(/\s$/)) {
                    errors.cast({
                        message: &#x27;Illegal trailing comment&#x27;,
                        element: comment,
                        offset: line.offset,
                        additional: {
                            lineNumber: i
                        }
                    });
                }
            }, this);
        }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_whitespace.prototype.configure" id="apidoc.element.jscs.disallow_trailing_whitespace.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_trailing_whitespace.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || options === &#x27;ignoreEmptyLines&#x27;,
        this.getOptionName() + &#x27; option requires a true value or &#x22;ignoreEmptyLines&#x22;&#x27;
    );
    this._ignoreEmptyLines = options === &#x27;ignoreEmptyLines&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_whitespace.prototype.getOptionName" id="apidoc.element.jscs.disallow_trailing_whitespace.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_trailing_whitespace.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowTrailingWhitespace&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_unused_params" id="apidoc.module.jscs.disallow_unused_params">module jscs.disallow_unused_params</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_params.disallow_unused_params" id="apidoc.element.jscs.disallow_unused_params.disallow_unused_params">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_unused_params
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_unused_params = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_unused_params.prototype" id="apidoc.module.jscs.disallow_unused_params.prototype">module jscs.disallow_unused_params.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_params.prototype._fix" id="apidoc.element.jscs.disallow_unused_params.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.disallow_unused_params.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var node = error.element;

    var parentElement = node.parentElement;
    if (!parentElement) {
        return;
    }

    if (
        parentElement.type === &#x27;FunctionExpression&#x27; ||
        parentElement.type === &#x27;FunctionDeclaration&#x27; ||
        parentElement.type === &#x27;ArrowFunctionExpression&#x27;
    ) {
        removeWithCommaIfNecessary(node, false);
        return;
    }

    if (parentElement.type === &#x27;ObjectProperty&#x27;) {
        removeWithCommaIfNecessary(parentElement, true);
        return;
    }

    if (parentElement.type === &#x27;ArrayPattern&#x27;) {
        removeWithCommaIfNecessary(node, false);
        if (
            parentElement.elements.length &#x3e; 0 &#x26;&#x26;
            parentElement.elements.every(function(element) {
                return !element;
            })
        ) {
            parentElement.removeChildren(
                parentElement.firstChild.nextSibling,
                parentElement.lastChild.previousSibling
            );
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &#x26;&#x26; instance._fix) {
        // &#x22;error.fixed = true&#x22; should go first, so rule can
        // decide for itself (with &#x22;error.fixed = false&#x22;)
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_params.prototype.check" id="apidoc.element.jscs.disallow_unused_params.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_unused_params.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {

    function reportError(node) {
        if (node.type === &#x27;Identifier&#x27;) {
            errors.add(&#x27;Param `&#x27; + node.name + &#x27;` is not used&#x27;, node);
        } else {
            errors.add(&#x27;Pattern is not used&#x27;, node);
        }
    }

    file.iterateNodesByType(
        [&#x27;FunctionDeclaration&#x27;, &#x27;FunctionExpression&#x27;, &#x27;ArrowFunctionExpression&#x27;],
        function(node) {
            var variableMap = file.getScopes().acquire(node).getVariables()
                .filter(function(variable) {
                    return variable.type === &#x27;Parameter&#x27;;
                })
                .reduce(function(obj, variable) {
                    obj[variable.name] = variable;
                    return obj;
                }, {});

            var params = node.params;
            var reportUnusedDirectParams = true;

            for (var i = params.length - 1; i &#x3e;= 0; i--) {
                var param = params[i];

                if (!reportUnusedDirectParams &#x26;&#x26; param.type === &#x27;Identifier&#x27;) {
                    continue;
                }

                var unusedNodes = getUnusedNodes(param, variableMap, reportUnusedDirectParams);

                unusedNodes.forEach(reportError);

                if (unusedNodes.length !== 1 || unusedNodes[0] !== param) {
                    reportUnusedDirectParams = false;
                }
            }
        }
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_params.prototype.configure" id="apidoc.element.jscs.disallow_unused_params.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_unused_params.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_params.prototype.getOptionName" id="apidoc.element.jscs.disallow_unused_params.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_unused_params.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowUnusedParams&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_unused_variables" id="apidoc.module.jscs.disallow_unused_variables">module jscs.disallow_unused_variables</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_variables.disallow_unused_variables" id="apidoc.element.jscs.disallow_unused_variables.disallow_unused_variables">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_unused_variables
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_unused_variables = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_unused_variables.prototype" id="apidoc.module.jscs.disallow_unused_variables.prototype">module jscs.disallow_unused_variables.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_variables.prototype._fix" id="apidoc.element.jscs.disallow_unused_variables.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.disallow_unused_variables.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var node = error.element;

    while (node.type !== &#x27;VariableDeclaration&#x27;) {
        node = node.parentElement;
    }

    node.parentElement.removeChild(node);
    error.fixed = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &#x26;&#x26; instance._fix) {
        // &#x22;error.fixed = true&#x22; should go first, so rule can
        // decide for itself (with &#x22;error.fixed = false&#x22;)
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_variables.prototype.check" id="apidoc.element.jscs.disallow_unused_variables.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_unused_variables.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var program = file.getProgram();
    var variableList = [];
    var nodesToCheck = [];
    var unusedNodes = [];

    function reportError(node) {
        errors.add(&#x27;Variable `&#x27; + node.name + &#x27;` is not used&#x27;, node);
    }

    function isVariableGood(variable) {
        var parentCheck = function(node) {
            if (node.parentElement) {
                if (node.parentElement.type === &#x27;VariableDeclaration&#x27;) {
                    var grandparentElement = node.parentElement.parentElement;

                    return grandparentElement.type !== &#x27;ExportNamedDeclaration&#x27;;
                } else if (
                    node.parentElement.type === &#x27;VariableDeclarator&#x27; ||
                    node.parentElement.type === &#x27;ObjectProperty&#x27; ||
                    node.parentElement.isPattern
                ) {
                    return parentCheck(node.parentElement);
                }
            } else {
                return false;
            }
        };

        var useVariable = variable.getDefinitions().some(function checkVariableDefinition(definition) {
            return parentCheck(definition.node);
        });

        return useVariable;
    }

    function getVariablesInAllScopes(scope) {
        var variableList = [];

        var iterateChildScopes = function(scope) {
            scope.getVariables().forEach(function(variable) {
                variableList.push(variable);
            });

            scope.childScopes.forEach(function(childScope) {
                return iterateChildScopes(childScope);
            });
        };

        iterateChildScopes(scope);

        return variableList;
    }

    // Get all variables in all scopes.
    variableList = getVariablesInAllScopes(file.getScopes().acquire(program));

    // Check if variables are what we want to check..
    variableList.reduce(function(acc, variable) {
        if (isVariableGood(variable)) {
            acc.push(variable);
        }

        return acc;
    }, nodesToCheck);

    // Check if variables are used.
    nodesToCheck.reduce(function checkVariableReferences(acc, variable) {
        if (variable.getReferences().length === 1) {
            variable.getDefinitions().forEach(function addUnusedVariable(definition) {
                acc.push(definition.node);
            });
        }

        return acc;
    }, unusedNodes);

    unusedNodes.forEach(reportError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_variables.prototype.configure" id="apidoc.element.jscs.disallow_unused_variables.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_unused_variables.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_variables.prototype.getOptionName" id="apidoc.element.jscs.disallow_unused_variables.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_unused_variables.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowUnusedVariables&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_var" id="apidoc.module.jscs.disallow_var">module jscs.disallow_var</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_var.disallow_var" id="apidoc.element.jscs.disallow_var.disallow_var">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_var
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_var = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_var.prototype" id="apidoc.module.jscs.disallow_var.prototype">module jscs.disallow_var.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_var.prototype.check" id="apidoc.element.jscs.disallow_var.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_var.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;VariableDeclaration&#x27;, function(node) {
        for (var i = 0; i &#x3c; node.declarations.length; i++) {
            var thisDeclaration = node.declarations[i];

            if (thisDeclaration.parentElement.kind === &#x27;var&#x27;) {
                errors.add(&#x27;Variable declarations should use `let` or `const` not `var`&#x27;, node);
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_var.prototype.configure" id="apidoc.element.jscs.disallow_var.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_var.prototype.</span>configure
        <span class="apidocSignatureSpan">(option)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (option) {
    assert(option === true, this.getOptionName() + &#x27; requires a true value&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_var.prototype.getOptionName" id="apidoc.element.jscs.disallow_var.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_var.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowVar&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_yoda_conditions" id="apidoc.module.jscs.disallow_yoda_conditions">module jscs.disallow_yoda_conditions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_yoda_conditions.disallow_yoda_conditions" id="apidoc.element.jscs.disallow_yoda_conditions.disallow_yoda_conditions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_yoda_conditions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_yoda_conditions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_yoda_conditions.prototype" id="apidoc.module.jscs.disallow_yoda_conditions.prototype">module jscs.disallow_yoda_conditions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_yoda_conditions.prototype.check" id="apidoc.element.jscs.disallow_yoda_conditions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_yoda_conditions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operators = this._operatorIndex;
    file.iterateNodesByType(&#x27;BinaryExpression&#x27;, function(node) {
        if (operators[node.operator]) {
            if (
                node.left.type.indexOf(&#x27;Literal&#x27;) &#x3e; -1 ||
                (node.left.type === &#x27;Identifier&#x27; &#x26;&#x26; node.left.name === &#x27;undefined&#x27;)
            ) {
                errors.add(&#x27;Yoda condition&#x27;, node.left);
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_yoda_conditions.prototype.configure" id="apidoc.element.jscs.disallow_yoda_conditions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_yoda_conditions.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + &#x27; option requires array or true value&#x27;
    );

    if (isTrue) {
        operators = [&#x27;==&#x27;, &#x27;===&#x27;, &#x27;!=&#x27;, &#x27;!==&#x27;];
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &#x3c; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_yoda_conditions.prototype.getOptionName" id="apidoc.element.jscs.disallow_yoda_conditions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_yoda_conditions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;disallowYodaConditions&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.errors" id="apidoc.module.jscs.errors">module jscs.errors</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.errors.errors" id="apidoc.element.jscs.errors.errors">
        function <span class="apidocSignatureSpan">jscs.</span>errors
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errors = function (file) {
    this._errorList = [];
    this._file = file;
    this._currentRule = &#x27;&#x27;;

<span class="apidocCodeCommentSpan">    /**
     * @type {TokenAssert}
     * @public
     */
</span>    this.assert = new TokenAssert(file);
    this.assert.on(&#x27;error&#x27;, this._addError.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.getPosition" id="apidoc.element.jscs.errors.getPosition">
        function <span class="apidocSignatureSpan">jscs.errors.</span>getPosition
        <span class="apidocSignatureSpan">(error, tokenIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPosition = function (error, tokenIndex) {
    var element = error.element;
    var offset = error.offset;
    var rule = error.rule;

    if (!element) {
        return EMPTY_POS;
    }

    if (offset === undefined) {
        // TODO: probably should be generalized
        if (rule === &#x27;validateQuoteMarks&#x27;) {
            offset = 0;
        } else if (element.getSourceCodeLength() === 1) {
            offset = 0;
        } else {
            offset = (element.getNewlineCount() === 0 &#x26;&#x26; Math.ceil(element.getSourceCodeLength() / 2)) || 0;
        }
    }

    var pos = tokenIndex ? tokenIndex.getElementLoc(element) : element.getLoc().start;
    if (!pos) {
        return EMPTY_POS;
    }

    if (offset === 0) {
        return pos;
    }

    var newlineCount = element.getNewlineCount();
    if (newlineCount &#x3e; 0) {
        var code = element.getSourceCode();
        LINE_SEPARATOR.lastIndex = 0;
        var lineOffset = 0;
        var match;
        var previousOffset = 0;
        var firstLineColumnOffset = pos.column;
        while ((match = LINE_SEPARATOR.exec(code)) !== null) {
            var currentOffset = match.index;
            if (offset &#x3c;= currentOffset) {
                return {
                    line: pos.line + lineOffset,
                    column: firstLineColumnOffset + offset - previousOffset
                };
            }
            previousOffset = currentOffset + match[0].length;
            firstLineColumnOffset = 0;
            lineOffset++;
        }
        return {
            line: pos.line + newlineCount,
            column: offset - previousOffset
        };
    } else {
        return {
            line: pos.line,
            column: pos.column + offset
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

/**
 * @param {TokenIndex} tokenIndex
 */
calculateErrorLocations: function(tokenIndex) {
    this._errorList.forEach(function(error) {
        var pos = Errors.<span class="apidocCodeKeywordSpan">getPosition</span>(error, tokenIndex);
        error.line = pos.line;
        error.column = pos.column;
    });
},

/**
 * Formats error for further output.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.errors.prototype" id="apidoc.module.jscs.errors.prototype">module jscs.errors.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.errors.prototype._addError" id="apidoc.element.jscs.errors.prototype._addError">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>_addError
        <span class="apidocSignatureSpan">(errorInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addError = function (errorInfo) {
    this._errorList.push({
        filename: this._file.getFilename(),
        rule: this._currentRule,
        message: this._prepareMessage(errorInfo),
        element: errorInfo.element,
        offset: errorInfo.offset,
        additional: errorInfo.additional,
        fixed: false,
        fix: errorInfo.fix
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
add: function(message, element, offset) {
    if (message instanceof Error) {
        this._addParseError(message);
        return;
    }

    this.<span class="apidocCodeKeywordSpan">_addError</span>({
        message: message,
        element: element,
        offset: offset
    });
},

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype._addParseError" id="apidoc.element.jscs.errors.prototype._addParseError">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>_addParseError
        <span class="apidocSignatureSpan">(errorInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addParseError = function (errorInfo) {
    this._errorList.push({
        filename: this._file.getFilename(),
        rule: &#x27;parseError&#x27;,
        message: errorInfo.message,
        line: errorInfo.loc ? errorInfo.loc.line : 1,
        column: errorInfo.loc ? errorInfo.loc.column : 0
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     *
     * @param {String | Error} message
     * @param {cst.types.Element} element
     * @param {Number} [offset] relative offset
     */
    add: function(message, element, offset) {
if (message instanceof Error) {
    this.<span class="apidocCodeKeywordSpan">_addParseError</span>(message);
    return;
}

this._addError({
    message: message,
    element: element,
    offset: offset
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype._prepareMessage" id="apidoc.element.jscs.errors.prototype._prepareMessage">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>_prepareMessage
        <span class="apidocSignatureSpan">(errorInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_prepareMessage = function (errorInfo) {
    var rule = errorInfo instanceof Error ? &#x27;parseError&#x27; : this._currentRule;

    if (rule) {
        return rule + &#x27;: &#x27; + errorInfo.message;
    }

    return errorInfo.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} errorInfo
 * @private
 */
_addError: function(errorInfo) {
    this._errorList.push({
        filename: this._file.getFilename(),
        rule: this._currentRule,
        message: this.<span class="apidocCodeKeywordSpan">_prepareMessage</span>(errorInfo),
        element: errorInfo.element,
        offset: errorInfo.offset,
        additional: errorInfo.additional,
        fixed: false,
        fix: errorInfo.fix
    });
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.add" id="apidoc.element.jscs.errors.prototype.add">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>add
        <span class="apidocSignatureSpan">(message, element, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (message, element, offset) {
    if (message instanceof Error) {
        this._addParseError(message);
        return;
    }

    this._addError({
        message: message,
        element: element,
        offset: offset
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

            // Apply specific fix
            if (!isFixed) {
                this._fixSpecificError(file, error);
            }
        } catch (e) {
            error.fixed = false;
            errors.<span class="apidocCodeKeywordSpan">add</span>(
                getInternalErrorMessage(error.rule, e),
                file.getProgram()
            );
        }
    }, this);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.calculateErrorLocations" id="apidoc.element.jscs.errors.prototype.calculateErrorLocations">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>calculateErrorLocations
        <span class="apidocSignatureSpan">(tokenIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculateErrorLocations = function (tokenIndex) {
    this._errorList.forEach(function(error) {
        var pos = Errors.getPosition(error, tokenIndex);
        error.line = pos.line;
        error.column = pos.column;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
    errors.add(&#x27;Unsupported rule: &#x27; + rulename, file.getProgram());
});

var program = file.getProgram();
var tokenIndex = new TokenIndex(program.getFirstToken());
errors.<span class="apidocCodeKeywordSpan">calculateErrorLocations</span>(tokenIndex);
errors.filter(function(error) {
    if (error.element) {
        return tokenIndex.isRuleEnabled(error.rule, error.element);
    } else {
        return true;
    }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.cast" id="apidoc.element.jscs.errors.prototype.cast">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>cast
        <span class="apidocSignatureSpan">(errorInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cast = function (errorInfo) {
    this._addError(errorInfo);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                return;
            }

            if (exceptReserved &#x26;&#x26; reservedWords.check(key.value, file.getDialect(), true)) {
                return;
            }

            errors.<span class="apidocCodeKeywordSpan">cast</span>({
                message: &#x27;Extra quotes for key&#x27;,
                element: prop
            });
        });
    });
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.explainError" id="apidoc.element.jscs.errors.prototype.explainError">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>explainError
        <span class="apidocSignatureSpan">(error, colorize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">explainError = function (error, colorize) {
    var lineNumber = error.line - 1;
    var lines = this._file.getLines();
    var result = [
        renderLine(lineNumber, lines[lineNumber], colorize),
        renderPointer(error.column, colorize)
    ];
    var i = lineNumber - 1;
    var linesAround = 2;
    while (i &#x3e;= 0 &#x26;&#x26; i &#x3e;= (lineNumber - linesAround)) {
        result.unshift(renderLine(i, lines[i], colorize));
        i--;
    }
    i = lineNumber + 1;
    while (i &#x3c; lines.length &#x26;&#x26; i &#x3c;= (lineNumber + linesAround)) {
        result.push(renderLine(i, lines[i], colorize));
        i++;
    }
    result.unshift(formatErrorMessage(error.message, this.getFilename(), colorize));
    return result.join(&#x27;\n&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
errorsCollection.forEach(function(errors) {
    if (!errors.isEmpty()) {
        /**
         * Formatting every single error.
         */
        errors.getErrorList().forEach(function(error) {
            errorCount++;
            console.log(errors.<span class="apidocCodeKeywordSpan">explainError</span>(error, true) + &#x27;\n&#x27;);
        });
    }
});
if (errorCount) {
    /**
     * Printing summary.
     */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.filter" id="apidoc.element.jscs.errors.prototype.filter">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>filter
        <span class="apidocSignatureSpan">(filter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (filter) {
    this._errorList = this._errorList.filter(filter);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var file;

    options = Object.create(options);
    options.maxDepth = 1;
    options.cwd = path.resolve(options.cwd);

    do {
file = patterns.<span class="apidocCodeKeywordSpan">filter</span>(function(pattern) {
    var configPath = glob.sync(pattern, options)[0];

    if (configPath) {
        return fn(path.join(options.cwd, configPath));
    }
})[0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.getErrorCount" id="apidoc.element.jscs.errors.prototype.getErrorCount">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>getErrorCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getErrorCount = function () {
    return this._errorList.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    if (this.maxErrorsEnabled()) {
        if (this._maxErrors === -1 || this._maxErrors === null) {
            this._maxErrorsExceeded = false;

        } else {
            this._maxErrorsExceeded = this._errorsFound + errors.<span class="apidocCodeKeywordSpan">getErrorCount</span>() &#x3e
; this._maxErrors;
            errors.stripErrorList(Math.max(0, this._maxErrors - this._errorsFound));
        }
    }

    this._errorsFound += errors.getErrorCount();
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.getErrorList" id="apidoc.element.jscs.errors.prototype.getErrorList">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>getErrorList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getErrorList = function () {
    return this._errorList;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return Vow.resolve(null);
    }

    return vowFs.read(path, &#x27;utf8&#x27;).then(function(data) {
var result = extractJs(path, data);

result.sources.forEach(function(script) {
    this.checkString(script.source, path).<span class="apidocCodeKeywordSpan">getErrorList</span>().forEach(function(error) {
        error.line += script.line;
        error.column += script.offset;
        result.addError(error);
    });
}, this);

return result.errors;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.getFilename" id="apidoc.element.jscs.errors.prototype.getFilename">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>getFilename
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFilename = function () {
    return this._file.getFilename();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Adds parser error to error list.
 *
 * @param {Object} errorInfo
 * @private
 */
_addParseError: function(errorInfo) {
    this._errorList.push({
        filename: this._file.<span class="apidocCodeKeywordSpan">getFilename</span>(),
        rule: &#x27;parseError&#x27;,
        message: errorInfo.message,
        line: errorInfo.loc ? errorInfo.loc.line : 1,
        column: errorInfo.loc ? errorInfo.loc.column : 0
    });
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.getValidationErrorCount" id="apidoc.element.jscs.errors.prototype.getValidationErrorCount">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>getValidationErrorCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getValidationErrorCount = function () {
    return this._errorList.filter(function(error) {
        return error.rule !== &#x27;parseError&#x27; &#x26;&#x26; error.rule !== &#x27;internalError&#x27;;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.isEmpty" id="apidoc.element.jscs.errors.prototype.isEmpty">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function () {
    return this._errorList.length === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

checkerPromise.then(function(errorsCollection) {
    reporter.writer(errorsCollection);
    handleMaxErrors();

    errorsCollection.forEach(function(errors) {
        if (!errors.<span class="apidocCodeKeywordSpan">isEmpty</span>()) {
            defer.reject(2);
        }
    });

    defer.resolve(0);
}).fail(function(e) {
    console.error(e.stack);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.setCurrentRule" id="apidoc.element.jscs.errors.prototype.setCurrentRule">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>setCurrentRule
        <span class="apidocSignatureSpan">(rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setCurrentRule = function (rule) {
    this._currentRule = rule;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (this._maxErrorsExceeded) {
return;
        }

        var errorFilter = this._configuration.getErrorFilter();

        this._configuredRules.forEach(function(rule) {
errors.<span class="apidocCodeKeywordSpan">setCurrentRule</span>(rule.getOptionName());

try {
    rule.check(file, errors);
} catch (e) {
    errors.setCurrentRule(&#x27;internalError&#x27;);
    errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.stripErrorList" id="apidoc.element.jscs.errors.prototype.stripErrorList">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>stripErrorList
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripErrorList = function (length) {
    this._errorList.splice(length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (this.maxErrorsEnabled()) {
        if (this._maxErrors === -1 || this._maxErrors === null) {
            this._maxErrorsExceeded = false;

        } else {
            this._maxErrorsExceeded = this._errorsFound + errors.getErrorCount() &#x3e; this._maxErrors;
            errors.<span class="apidocCodeKeywordSpan">stripErrorList</span>(Math.max(0, this._maxErrors - this._errorsFound));
        }
    }

    this._errorsFound += errors.getErrorCount();
},

/**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.generator" id="apidoc.module.jscs.generator">module jscs.generator</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.generator.generator" id="apidoc.element.jscs.generator.generator">
        function <span class="apidocSignatureSpan">jscs.</span>generator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Generator() {
    this._config = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.generator.prototype" id="apidoc.module.jscs.generator.prototype">module jscs.generator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.generator.prototype._checkAgainstPreset" id="apidoc.element.jscs.generator.prototype._checkAgainstPreset">
        function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_checkAgainstPreset
        <span class="apidocSignatureSpan">(path, presetName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkAgainstPreset = function (path, presetName) {
    var checker = getChecker();

    checker.configure({preset: presetName, maxErrors: Infinity});

    return checker.checkPath(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.generator.prototype._generateStatsForPresets" id="apidoc.element.jscs.generator.prototype._generateStatsForPresets">
        function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_generateStatsForPresets
        <span class="apidocSignatureSpan">(resultsPerPreset, presetNames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_generateStatsForPresets = function (resultsPerPreset, presetNames) {
    return resultsPerPreset.map(function(presetResults, idx) {
        var errorCollection = [].concat.apply([], presetResults);

        var presetStats = {
            name: presetNames[idx],
            sum: 0,
            errors: []
        };

        errorCollection.forEach(function(error) {
            presetStats.sum += error.getErrorCount();
            presetStats.errors = presetStats.errors.concat(error.getErrorList());
        });

        return presetStats;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var statsForPresets;

console.log(&#x27;Checking&#x27;, _path, &#x27;against the presets&#x27;);

return Vow
.all(presetNames.map(this._checkAgainstPreset.bind(this, _path)))
.then(function(resultsPerPreset) {
    statsForPresets = this.<span class="apidocCodeKeywordSpan">_generateStatsForPresets</span>(resultsPerPreset, presetNames);
    return statsForPresets;
}.bind(this))
.then(this._showErrorCounts.bind(this))
.then(this._getUserPresetChoice.bind(this, prompts[0]))
.then(function showViolatedRules(choiceObj) {
    var presetIndex = choiceObj[prompts[0].name] - 1;
    var presetName = statsForPresets[presetIndex].name;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.generator.prototype._getUserPresetChoice" id="apidoc.element.jscs.generator.prototype._getUserPresetChoice">
        function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_getUserPresetChoice
        <span class="apidocSignatureSpan">(prompt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getUserPresetChoice = function (prompt) {
    return this._showPrompt(prompt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.generator.prototype._getUserViolationChoices" id="apidoc.element.jscs.generator.prototype._getUserViolationChoices">
        function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_getUserViolationChoices
        <span class="apidocSignatureSpan">(errorPrompts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getUserViolationChoices = function (errorPrompts) {
    return this._showPrompt(errorPrompts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (!violatedRuleCount) { return this._config; }

    console.log(_path + &#x27; violates &#x27; + violatedRuleCount + &#x27; rule&#x27; + (violatedRuleCount &#x3e; 1 ? &#x27;s&#
x27; : &#x27;&#x27;));

    var errorPrompts = generateRuleHandlingPrompts(errorStats);

    return this.<span class="apidocCodeKeywordSpan">_getUserViolationChoices</span>(errorPrompts)
    .then(this._handleViolatedRules.bind(this, errorPrompts))
    .then(function() {
        return this._config;
    }.bind(this));
}.bind(this))
.then(function flushConfig() {
    fs.writeFileSync(process.cwd() + &#x27;/.jscsrc&#x27;, JSON.stringify(this._config, null, &#x27;\t&#x27;));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.generator.prototype._handleViolatedRules" id="apidoc.element.jscs.generator.prototype._handleViolatedRules">
        function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_handleViolatedRules
        <span class="apidocSignatureSpan">(errorPrompts, choices)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handleViolatedRules = function (errorPrompts, choices) {
    errorPrompts.forEach(function(errorPrompt) {
        var userChoice = choices[errorPrompt.name];

        if (userChoice &#x26;&#x26; userChoice.toLowerCase() === &#x27;e&#x27;) {
            this._config[errorPrompt.associatedRuleName] = null;
        }
    }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.generator.prototype._showErrorCounts" id="apidoc.element.jscs.generator.prototype._showErrorCounts">
        function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_showErrorCounts
        <span class="apidocSignatureSpan">(statsForPresets)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_showErrorCounts = function (statsForPresets) {
    var table = getTable();

    statsForPresets.forEach(function(presetStats, idx) {
        table.push([idx + 1, presetStats.name, presetStats.sum, getUniqueErrorNames(presetStats.errors).length]);
    });

    console.log(table.toString());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.generator.prototype._showPrompt" id="apidoc.element.jscs.generator.prototype._showPrompt">
        function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_showPrompt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_showPrompt = function () {
    var deferred = Vow.defer();
    var args = [].slice.call(arguments);

    args.push(function(err, result) {
        if (err) {
            deferred.reject(err);
        } else {
            deferred.resolve(result);
        }
    });

    fn.apply(null, args);

    return deferred.promise();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Prompts the user to choose a preset
*
* @private
* @param {Object} prompt
* @return {Promise}
*/
Generator.prototype._getUserPresetChoice = function(prompt) {
   return this.<span class="apidocCodeKeywordSpan">_showPrompt</span>(prompt);
};

/**
* Prompts the user to nullify rules or fix violations themselves
*
* @private
* @param  {Object[]} errorPrompts
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.generator.prototype.generate" id="apidoc.element.jscs.generator.prototype.generate">
        function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>generate
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (path) {
    var checker = getChecker();
    var _path = utils.normalizePath(path, checker.getConfiguration().getBasePath());
    var presetNames = Object.keys(checker.getConfiguration().getRegisteredPresets());
    var statsForPresets;

    console.log(&#x27;Checking&#x27;, _path, &#x27;against the presets&#x27;);

    return Vow
    .all(presetNames.map(this._checkAgainstPreset.bind(this, _path)))
    .then(function(resultsPerPreset) {
        statsForPresets = this._generateStatsForPresets(resultsPerPreset, presetNames);
        return statsForPresets;
    }.bind(this))
    .then(this._showErrorCounts.bind(this))
    .then(this._getUserPresetChoice.bind(this, prompts[0]))
    .then(function showViolatedRules(choiceObj) {
        var presetIndex = choiceObj[prompts[0].name] - 1;
        var presetName = statsForPresets[presetIndex].name;

        console.log(&#x27;You chose the &#x27; + presetName + &#x27; preset&#x27;);

        this._config.preset = presetName;

        var errorStats = getErrorsByRuleName(statsForPresets[presetIndex].errors);

        var violatedRuleCount = Object.keys(errorStats).length;

        if (!violatedRuleCount) { return this._config; }

        console.log(_path + &#x27; violates &#x27; + violatedRuleCount + &#x27; rule&#x27; + (violatedRuleCount &#x3e; 1 ? &#x27;s&#x27; : &#x27;&#x27;));

        var errorPrompts = generateRuleHandlingPrompts(errorStats);

        return this._getUserViolationChoices(errorPrompts)
        .then(this._handleViolatedRules.bind(this, errorPrompts))
        .then(function() {
            return this._config;
        }.bind(this));
    }.bind(this))
    .then(function flushConfig() {
        fs.writeFileSync(process.cwd() + &#x27;/.jscsrc&#x27;, JSON.stringify(this._config, null, &#x27;\t&#x27;));
        console.log(&#x27;Generated a .jscsrc configuration file in &#x27; + process.cwd());
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

return returnArgs;
    }
    if (program.autoConfigure) {
var generator = new ConfigGenerator();

generator
.<span class="apidocCodeKeywordSpan">generate</span>(program.autoConfigure)
.then(function() {
    defer.resolve(0);
}, function(error) {
    console.error(&#x27;Configuration generation failed due to &#x27;, error);
    defer.reject(7);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.js_file" id="apidoc.module.jscs.js_file">module jscs.js_file</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.js_file.js_file" id="apidoc.element.jscs.js_file.js_file">
        function <span class="apidocSignatureSpan">jscs.</span>js_file
        <span class="apidocSignatureSpan">(params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">js_file = function (params) {
    params = params || {};
    this._parseErrors = [];
    this._filename = params.filename;
    this._source = params.source;

    this._es3 = params.es3 || false;

    this._lineBreaks = null;
    this._lines = this._source.split(/\r\n|\r|\n/);

    var parser = new Parser({
        strictMode: false,
        languageExtensions: {
            gritDirectives: true,
            appleInstrumentationDirectives: true
        }
    });

    try {
        this._program = parser.parse(this._source);
    } catch (e) {
        this._parseErrors.push(e);
        this._program = new Program([
            new Token(&#x27;EOF&#x27;, &#x27;&#x27;)
        ]);
    }

    // Lazy initialization
    this._scopes = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.js_file.prototype" id="apidoc.module.jscs.js_file.prototype">module jscs.js_file.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype._setTokenBefore" id="apidoc.element.jscs.js_file.prototype._setTokenBefore">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>_setTokenBefore
        <span class="apidocSignatureSpan">(token, fragment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setTokenBefore = function (token, fragment) {
    var parent = token;
    var grandpa = parent.parentElement;

    while (grandpa) {
        try {
            grandpa.insertChildBefore(fragment, parent);
            break;
        } catch (e) {}

        parent = grandpa;
        grandpa = parent.parentElement;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return;
    }

    prevToken.parentElement.replaceChild(fragment, prevToken);
    return;
}

this.<span class="apidocCodeKeywordSpan">_setTokenBefore</span>(token, fragment);
    },

    _setTokenBefore: function(token, fragment) {
var parent = token;
var grandpa = parent.parentElement;

while (grandpa) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.findNextOperatorToken" id="apidoc.element.jscs.js_file.prototype.findNextOperatorToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>findNextOperatorToken
        <span class="apidocSignatureSpan">(token, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findNextOperatorToken = function (token, value) {
    return this.findNextToken(token, value in KEYWORD_OPERATORS ? &#x27;Keyword&#x27; : &#x27;Punctuator&#x27;, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.findNextToken" id="apidoc.element.jscs.js_file.prototype.findNextToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>findNextToken
        <span class="apidocSignatureSpan">(token, type, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findNextToken = function (token, type, value) {
    var nextToken = token.getNextToken();

    while (nextToken) {
        if (nextToken.type === type &#x26;&#x26; (value === undefined || nextToken.value === value)) {
            return nextToken;
        }

        nextToken = nextToken.getNextToken();
    }
    return nextToken;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Returns the first token after the given which matches type (and value).
 *
 * @param {Object} token
 * @param {String} value
 * @returns {Object|null}
 */
findNextOperatorToken: function(token, value) {
    return this.<span class="apidocCodeKeywordSpan">findNextToken</span>(token, value in KEYWORD_OPERATORS ? &#x27;Keyword&#x27; : &#
x27;Punctuator&#x27;, value);
},

/**
 * Iterates through the token tree using tree iterator.
 * Calls passed function for every token.
 *
 * @param {Function} cb
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.findPrevOperatorToken" id="apidoc.element.jscs.js_file.prototype.findPrevOperatorToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>findPrevOperatorToken
        <span class="apidocSignatureSpan">(token, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findPrevOperatorToken = function (token, value) {
    return this.findPrevToken(token, value in KEYWORD_OPERATORS ? &#x27;Keyword&#x27; : &#x27;Punctuator&#x27;, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    expression = node.right;
}

if (expression === null) {
    return;
}

var operatorToken = file.<span class="apidocCodeKeywordSpan">findPrevOperatorToken</span>(
    file.getFirstNodeToken(expression),
    operator
);

var nextToken = file.getNextToken(operatorToken);

if (operators[operator]) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.findPrevToken" id="apidoc.element.jscs.js_file.prototype.findPrevToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>findPrevToken
        <span class="apidocSignatureSpan">(token, type, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findPrevToken = function (token, type, value) {
    var prevToken = this.getPrevToken(token);
    while (prevToken) {
        if (prevToken.type === type &#x26;&#x26; (value === undefined || prevToken.value === value)) {
            return prevToken;
        }

        prevToken = this.getPrevToken(prevToken);
    }
    return prevToken;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Returns the first token before the given which matches type (and value).
 *
 * @param {Object} token
 * @param {String} value
 * @returns {Object|null}
 */
findPrevOperatorToken: function(token, value) {
    return this.<span class="apidocCodeKeywordSpan">findPrevToken</span>(token, value in KEYWORD_OPERATORS ? &#x27;Keyword&#x27; : &#
x27;Punctuator&#x27;, value);
},

/**
 * Returns the first token after the given which matches type (and value).
 *
 * @param {Object} token
 * @param {String} value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getComments" id="apidoc.element.jscs.js_file.prototype.getComments">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getComments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComments = function () {
    var comments = [];
    var token = this._program.getFirstToken();
    while (token) {
        if (token.isComment) {
            comments[comments.length] = token;
        }
        token = token.getNextToken();
    }
    return comments;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * Returns array of source lines for the file with comments removed.
     *
     * @returns {Array}
     */
    getLinesWithCommentsRemoved: function() {
var lines = this.getLines().concat();

this.<span class="apidocCodeKeywordSpan">getComments</span>().concat().reverse().forEach(function(comment) {
    var loc = comment.getLoc();
    var startLine = loc.start.line;
    var startCol = loc.start.column;
    var endLine = loc.end.line;
    var endCol = loc.end.column;
    var i = startLine - 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getDialect" id="apidoc.element.jscs.js_file.prototype.getDialect">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getDialect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDialect = function () {
    if (this._es3) {
        return &#x27;es3&#x27;;
    }

    return &#x27;es6&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
}

if (!KEY_NAME_RE.test(key.value)) {
    return;
}

if (exceptReserved &#x26;&#x26; reservedWords.check(key.value, file.<span class="apidocCodeKeywordSpan">getDialect</span>(), true
)) {
    return;
}

errors.cast({
    message: &#x27;Extra quotes for key&#x27;,
    element: prop
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getDistanceBetween" id="apidoc.element.jscs.js_file.prototype.getDistanceBetween">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getDistanceBetween
        <span class="apidocSignatureSpan">(tokenBefore, tokenAfter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDistanceBetween = function (tokenBefore, tokenAfter) {
    if (tokenBefore === tokenAfter) {
        return 0;
    }
    tokenBefore = tokenBefore instanceof Token ? tokenBefore : tokenBefore.getLastToken();
    tokenAfter = tokenAfter instanceof Token ? tokenAfter : tokenAfter.getFirstToken();
    var currentToken = tokenBefore.getNextToken();
    var distance = 0;
    while (currentToken) {
        if (currentToken === tokenAfter) {
            break;
        }

        distance += currentToken.getSourceCodeLength();
        currentToken = currentToken.getNextToken();
    }
    return distance;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        message: options.message,
        element: token,
        offset: token.getSourceCodeLength(),
        fix: fixed ? fix : undefined
    });
}.bind(this);

var spacesBetween = this._file.<span class="apidocCodeKeywordSpan">getDistanceBetween</span>(token, nextToken);

if (atLeast !== undefined &#x26;&#x26; spacesBetween &#x3c; atLeast) {
    emitError(&#x27;at least&#x27;, atLeast);
    return true;
}

if (atMost !== undefined &#x26;&#x26; spacesBetween &#x3e; atMost) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getFilename" id="apidoc.element.jscs.js_file.prototype.getFilename">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getFilename
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFilename = function () {
    return this._filename;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Adds parser error to error list.
 *
 * @param {Object} errorInfo
 * @private
 */
_addParseError: function(errorInfo) {
    this._errorList.push({
        filename: this._file.<span class="apidocCodeKeywordSpan">getFilename</span>(),
        rule: &#x27;parseError&#x27;,
        message: errorInfo.message,
        line: errorInfo.loc ? errorInfo.loc.line : 1,
        column: errorInfo.loc ? errorInfo.loc.column : 0
    });
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getFirstNodeToken" id="apidoc.element.jscs.js_file.prototype.getFirstNodeToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getFirstNodeToken
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFirstNodeToken = function (node) {
    return node.getFirstToken();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//     // different lines:
//     for (var i = 0;
//          i &#x3c; length;
//          i++)
//     {
//     }
var parentElement = node.parentElement;
var parentNextToken = file.<span class="apidocCodeKeywordSpan">getFirstNodeToken</span>(parentElement);
var openingRoundBrace = file.findNextToken(parentNextToken, &#x27;Punctuator&#x27;, &#x27;(&#x27;);
var closingRoundBrace = file.findPrevToken(openingBrace, &#x27;Punctuator&#x27;, &#x27;)&#x27;);

// Not always the conditions are there: to check look for the presence of round braces.
// For example:
//     try {
//     } ...
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getFirstToken" id="apidoc.element.jscs.js_file.prototype.getFirstToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getFirstToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFirstToken = function () {
    return this._program.getFirstToken();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Returns the first token for the node from the AST.
 *
 * @param {Object} node
 * @returns {Object}
 */
getFirstNodeToken: function(node) {
    return node.<span class="apidocCodeKeywordSpan">getFirstToken</span>();
},

/**
 * Returns the last token for the node from the AST.
 *
 * @param {Object} node
 * @returns {Object}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getFirstTokenOnLineWith" id="apidoc.element.jscs.js_file.prototype.getFirstTokenOnLineWith">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getFirstTokenOnLineWith
        <span class="apidocSignatureSpan">(element, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFirstTokenOnLineWith = function (element, options) {
    options = options || {};
    var firstToken = element;

    if (element.isComment &#x26;&#x26; !options.includeComments) {
        firstToken = null;
    }

    if (element.isWhitespace &#x26;&#x26; !options.includeWhitespace) {
        firstToken = null;
    }

    var currentToken = element.getPreviousToken();
    while (currentToken) {
        if (currentToken.isWhitespace) {
            if (currentToken.getNewlineCount() &#x3e; 0 || !currentToken.getPreviousToken()) {
                if (options.includeWhitespace) {
                    firstToken = currentToken;
                }
                break;
            }
        } else if (currentToken.isComment) {
            if (options.includeComments) {
                firstToken = currentToken;
                break;
            }
            if (currentToken.getNewlineCount() &#x3e; 0) {
                break;
            }
        } else {
            firstToken = currentToken;
        }

        currentToken = currentToken.getPreviousToken();
    }

    if (firstToken) {
        return firstToken;
    }

    currentToken = element.getNextToken();
    while (currentToken) {
        if (currentToken.isWhitespace) {
            if (currentToken.getNewlineCount() &#x3e; 0 || !currentToken.getNextToken()) {
                if (options.includeWhitespace) {
                    firstToken = currentToken;
                }
                break;
            }
        } else if (currentToken.isComment) {
            if (options.includeComments) {
                firstToken = currentToken;
                break;
            }
            if (currentToken.getNewlineCount() &#x3e; 0) {
                break;
            }
        } else {
            firstToken = currentToken;
        }

        currentToken = currentToken.getNextToken();
    }

    return firstToken;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var allowFirstAfterCurly = this._allowFirstAfterCurly;

        file.iterateTokensByType(&#x27;CommentLine&#x27;, function(comment) {
if (comment.getLoc().start.line === 1) {
    return;
}

var firstToken = file.<span class="apidocCodeKeywordSpan">getFirstTokenOnLineWith</span>(comment);

// Should not consider code and comment on the same line (#1194)
if (firstToken !== null &#x26;&#x26; firstToken.type !== &#x27;EOF&#x27;) {
    return;
}

var prevToken = file.getPrevToken(comment, {includeComments: true});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getLastNodeToken" id="apidoc.element.jscs.js_file.prototype.getLastNodeToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLastNodeToken
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLastNodeToken = function (node) {
    return node.getLastToken();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    assertSameLine(prevToken, openingBrace);
}
            }
        });

        if (setting === true || setting.indexOf(&#x27;switch&#x27;) !== -1) {
            file.iterateNodesByType([&#x27;SwitchStatement&#x27;], function(node) {
var openingBrace = file.findNextToken(file.<span class="apidocCodeKeywordSpan">getLastNodeToken</span>(node.discriminant), &#x27
;Punctuator&#x27;, &#x27;{&#x27;);
var prevToken = file.getPrevToken(openingBrace);

if (hasMultiLineEx !== true) {
    assertSameLine(prevToken, openingBrace);
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getLastToken" id="apidoc.element.jscs.js_file.prototype.getLastToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLastToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLastToken = function () {
    return this._program.getLastToken();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Returns the last token for the node from the AST.
 *
 * @param {Object} node
 * @returns {Object}
 */
getLastNodeToken: function(node) {
    return node.<span class="apidocCodeKeywordSpan">getLastToken</span>();
},

/**
 * Returns the first token for the file.
 *
 * @param {Option} [options]
 * @param {Boolean} [options.includeComments=false]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getLastTokenOnLine" id="apidoc.element.jscs.js_file.prototype.getLastTokenOnLine">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLastTokenOnLine
        <span class="apidocSignatureSpan">(lineNumber, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLastTokenOnLine = function (lineNumber, options) {
    options = options || {};

    var loc;
    var token = this._program.getLastToken();
    var currentToken;

    while (token) {
        loc = token.getLoc();
        currentToken = token;
        token = token.getPreviousToken();

        if (loc.start.line &#x3c;= lineNumber &#x26;&#x26; loc.end.line &#x3e;= lineNumber) {

            // Since whitespace tokens can contain newlines we need to check
            // if position is in the range, not exact match
            if (currentToken.isWhitespace &#x26;&#x26; !options.includeWhitespace) {
                continue;
            }
        }

        if (loc.start.line === lineNumber || loc.end.line === lineNumber) {
            if (currentToken.isComment &#x26;&#x26; !options.includeComments) {
                continue;
            }

            return currentToken;
        }
    }

    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        for (var i = 0, l = lines.length; i &#x3c; l; i++) {
            line = this._tabSize ? lines[i].replace(/\t/g, this._tabSize) : lines[i];

            if (line.length &#x3e; maximumLineLength) {
                errors.add(
                    &#x27;Line must be at most &#x27; + maximumLineLength + &#x27; characters&#x27;,
                    file.<span class="apidocCodeKeywordSpan">getLastTokenOnLine</span>(i + 1, { includeComments: true })
                );
            }
        }
    }

};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getLineBreakStyle" id="apidoc.element.jscs.js_file.prototype.getLineBreakStyle">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLineBreakStyle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLineBreakStyle = function () {
    var lineBreaks = this.getLineBreaks();
    return lineBreaks.length ? lineBreaks[0] : &#x27;\n&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Updates the whitespace of a line by passing split lines to a callback function
 * for editing.
 *
 * @param {Object} token
 * @param {Function} callback
 */
TokenAssert.prototype._updateWhitespaceByLine = function(token, callback) {
    var lineBreak = this._file.<span class="apidocCodeKeywordSpan">getLineBreakStyle</span>();
    var lines = this._file.getWhitespaceBefore(token).split(/\r\n|\r|\n/);

    lines = callback(lines);
    this._file.setWhitespaceBefore(token, lines.join(lineBreak));
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getLineBreaks" id="apidoc.element.jscs.js_file.prototype.getLineBreaks">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLineBreaks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLineBreaks = function () {
    if (this._lineBreaks === null) {
        this._lineBreaks = this._source.match(/\r\n|\r|\n/g) || [];
    }
    return this._lineBreaks;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Returns the first line break character encountered in the file.
 * Assumes LF if the file is only one line.
 *
 * @returns {String}
 */
getLineBreakStyle: function() {
    var lineBreaks = this.<span class="apidocCodeKeywordSpan">getLineBreaks</span>();
    return lineBreaks.length ? lineBreaks[0] : &#x27;\n&#x27;;
},

/**
 * Returns all line break characters from the file.
 *
 * @returns {String[]}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getLineCountBetween" id="apidoc.element.jscs.js_file.prototype.getLineCountBetween">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLineCountBetween
        <span class="apidocSignatureSpan">(tokenBefore, tokenAfter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLineCountBetween = function (tokenBefore, tokenAfter) {
    if (tokenBefore === tokenAfter) {
        return 0;
    }
    tokenBefore = tokenBefore instanceof Token ? tokenBefore : tokenBefore.getLastToken();
    tokenAfter = tokenAfter instanceof Token ? tokenAfter : tokenAfter.getFirstToken();

    var currentToken = tokenBefore.getNextToken();
    var lineCount = 0;
    while (currentToken) {
        if (currentToken === tokenAfter) {
            break;
        }

        lineCount += currentToken.getNewlineCount();
        currentToken = currentToken.getNextToken();
    }
    return lineCount;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    this._validateOptions(options);

    // Only attempt to remove or add lines if there are no comments between the two nodes
    // as this prevents accidentally moving a valid token onto a line comment ed line
    var fixed = !options.token.getNextNonWhitespaceToken().isComment;

    var linesBetween = this._file.<span class="apidocCodeKeywordSpan">getLineCountBetween</span>(token, nextToken);

    var emitError = function(countPrefix, lineCount) {
var msgPrefix = token.value + &#x27; and &#x27; + nextToken.value;

var fix = function() {
    this._augmentLineCount(options, lineCount);
}.bind(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getLines" id="apidoc.element.jscs.js_file.prototype.getLines">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLines
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLines = function () {
    return this._lines;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Object} error
 * @param {Boolean} [colorize = false]
 * @returns {String}
 */
explainError: function(error, colorize) {
    var lineNumber = error.line - 1;
    var lines = this._file.<span class="apidocCodeKeywordSpan">getLines</span>();
    var result = [
        renderLine(lineNumber, lines[lineNumber], colorize),
        renderPointer(error.column, colorize)
    ];
    var i = lineNumber - 1;
    var linesAround = 2;
    while (i &#x3e;= 0 &#x26;&#x26; i &#x3e;= (lineNumber - linesAround)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getLinesWithCommentsRemoved" id="apidoc.element.jscs.js_file.prototype.getLinesWithCommentsRemoved">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLinesWithCommentsRemoved
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLinesWithCommentsRemoved = function () {
    var lines = this.getLines().concat();

    this.getComments().concat().reverse().forEach(function(comment) {
        var loc = comment.getLoc();
        var startLine = loc.start.line;
        var startCol = loc.start.column;
        var endLine = loc.end.line;
        var endCol = loc.end.column;
        var i = startLine - 1;

        if (startLine === endLine) {
            // Remove tralling spaces (see gh-1968)
            lines[i] = lines[i].replace(/\*\/\s+/, &#x27;\*\/&#x27;);
            lines[i] = lines[i].substring(0, startCol) + lines[i].substring(endCol);
        } else {
            lines[i] = lines[i].substring(0, startCol);
            for (var x = i + 1; x &#x3c; endLine - 1; x++) {
                lines[x] = &#x27;&#x27;;
            }

            lines[x] = lines[x].substring(endCol);
        }
    });

    return lines;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },

    check: function(file, errors) {
        var maximumLineLength = this._maximumLineLength;

        var line;
        var lines = this._allowComments ?
file.<span class="apidocCodeKeywordSpan">getLinesWithCommentsRemoved</span>() : file.getLines();

        // This check should not be destructive
        lines = lines.slice();

        var removeLoc = function(tokenOrNode) {

// Just in case (See #2107 for example)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getNextToken" id="apidoc.element.jscs.js_file.prototype.getNextToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getNextToken
        <span class="apidocSignatureSpan">(token, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNextToken = function (token, options) {
    if (options &#x26;&#x26; options.includeComments) {
        return token.getNextNonWhitespaceToken();
    } else {
        return token.getNextCodeToken();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     *
     * @param {Object} token
     * @param {String} type
     * @param {String} [value]
     * @returns {Object|null}
     */
    findNextToken: function(token, type, value) {
        var nextToken = token.<span class="apidocCodeKeywordSpan">getNextToken</span>();

        while (nextToken) {
if (nextToken.type === type &#x26;&#x26; (value === undefined || nextToken.value === value)) {
    return nextToken;
}

nextToken = nextToken.getNextToken();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getNodesByType" id="apidoc.element.jscs.js_file.prototype.getNodesByType">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getNodesByType
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNodesByType = function (type) {
    type = Array.isArray(type) ? type : [type];
    var result = [];

    for (var i = 0, l = type.length; i &#x3c; l; i++) {
        var nodes = this._program.selectNodesByType(type[i]);

        if (nodes) {
            result = result.concat(nodes);
        }
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Calls passed function for every matched node.
 *
 * @param {String|String[]} type
 * @param {Function} cb
 * @param {Object} context
 */
iterateNodesByType: function(type, cb, context) {
    return this.<span class="apidocCodeKeywordSpan">getNodesByType</span>(type).forEach(cb, context || this);
},

/**
 * Iterates tokens by type(s) from the token array.
 * Calls passed function for every matched token.
 *
 * @param {String|String[]} type
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getParseErrors" id="apidoc.element.jscs.js_file.prototype.getParseErrors">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getParseErrors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParseErrors = function () {
    return this._parseErrors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    checkString: function(source, filename) {
filename = filename || &#x27;input&#x27;;

var file = this._createJsFileInstance(filename, source);

var errors = new Errors(file);

file.<span class="apidocCodeKeywordSpan">getParseErrors</span>().forEach(function(parseError) {
    if (!this._maxErrorsExceeded) {
        this._addParseError(errors, parseError, file);
    }
}, this);

if (!file._program || file._program.firstChild.type === &#x27;EOF&#x27;) {
    return errors;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getPrevToken" id="apidoc.element.jscs.js_file.prototype.getPrevToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getPrevToken
        <span class="apidocSignatureSpan">(token, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPrevToken = function (token, options) {
    if (options &#x26;&#x26; options.includeComments) {
        return token.getPreviousNonWhitespaceToken();
    }

    return token.getPreviousCodeToken();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     *
     * @param {Object} token
     * @param {String} type
     * @param {String} [value]
     * @returns {Object|null}
     */
    findPrevToken: function(token, type, value) {
var prevToken = this.<span class="apidocCodeKeywordSpan">getPrevToken</span>(token);
while (prevToken) {
    if (prevToken.type === type &#x26;&#x26; (value === undefined || prevToken.value === value)) {
        return prevToken;
    }

    prevToken = this.getPrevToken(prevToken);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getProgram" id="apidoc.element.jscs.js_file.prototype.getProgram">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getProgram
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getProgram = function () {
    return this._program;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if (!isFixed) {
                this._fixSpecificError(file, error);
            }
        } catch (e) {
            error.fixed = false;
            errors.add(
                getInternalErrorMessage(error.rule, e),
                file.<span class="apidocCodeKeywordSpan">getProgram</span>()
            );
        }
    }, this);
},

/**
 * Checks a file specified using JsFile instance.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getScopes" id="apidoc.element.jscs.js_file.prototype.getScopes">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getScopes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getScopes = function () {
    if (!this._scopes) {
        this._scopes = new ScopesApi(this._program);
    }

    return this._scopes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        errors.add(&#x27;Pattern is not used&#x27;, node);
    }
}

file.iterateNodesByType(
    [&#x27;FunctionDeclaration&#x27;, &#x27;FunctionExpression&#x27;, &#x27;ArrowFunctionExpression&#x27;],
    function(node) {
        var variableMap = file.<span class="apidocCodeKeywordSpan">getScopes</span>().acquire(node).getVariables()
            .filter(function(variable) {
                return variable.type === &#x27;Parameter&#x27;;
            })
            .reduce(function(obj, variable) {
                obj[variable.name] = variable;
                return obj;
            }, {});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getSource" id="apidoc.element.jscs.js_file.prototype.getSource">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSource = function () {
    return this._source;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }

            file = this._createJsFileInstance(filename, file.render());
            errors = new Errors(file);
            attempt++;
        } while (attempt &#x3c; MAX_FIX_ATTEMPTS);

        return {output: file.<span class="apidocCodeKeywordSpan">getSource</span>(), errors: errors};
    }
},

/**
 * Returns `true` if max erros limit is enabled.
 *
 * @returns {Boolean}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getTree" id="apidoc.element.jscs.js_file.prototype.getTree">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getTree
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTree = function () {
    return this._program || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getWhitespaceBefore" id="apidoc.element.jscs.js_file.prototype.getWhitespaceBefore">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getWhitespaceBefore
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getWhitespaceBefore = function (token) {
    if (!token.getPreviousToken) {
        console.log(token);
    }
    var prev = token.getPreviousToken();

    if (prev &#x26;&#x26; prev.isWhitespace) {
        return prev.getSourceCode();
    }

    return &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* for editing.
*
* @param {Object} token
* @param {Function} callback
*/
TokenAssert.prototype._updateWhitespaceByLine = function(token, callback) {
   var lineBreak = this._file.getLineBreakStyle();
   var lines = this._file.<span class="apidocCodeKeywordSpan">getWhitespaceBefore</span>(token).split(/\r\n|\r|\n/);

   lines = callback(lines);
   this._file.setWhitespaceBefore(token, lines.join(lineBreak));
};

/**
* Updates the whitespace of a line by passing split lines to a callback function
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.isOnTheSameLine" id="apidoc.element.jscs.js_file.prototype.isOnTheSameLine">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>isOnTheSameLine
        <span class="apidocSignatureSpan">(tokenBefore, tokenAfter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isOnTheSameLine = function (tokenBefore, tokenAfter) {
    if (tokenBefore === tokenAfter) {
        return true;
    }
    tokenBefore = tokenBefore instanceof Token ? tokenBefore : tokenBefore.getLastToken();
    tokenAfter = tokenAfter instanceof Token ? tokenAfter : tokenAfter.getFirstToken();
    var currentToken = tokenBefore;
    while (currentToken) {
        if (currentToken === tokenAfter) {
            return true;
        }
        if (currentToken !== tokenBefore &#x26;&#x26; currentToken.getNewlineCount() &#x3e; 0) {
            return false;
        }
        currentToken = currentToken.getNextToken();
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (!token || !nextToken) {
    return false;
}

this._validateOptions(options);

if (!options.disallowNewLine &#x26;&#x26; !this._file.<span class="apidocCodeKeywordSpan">isOnTheSameLine</span>(token, nextToken
)) {
    return false;
}

// Only attempt to remove or add lines if there are no comments between the two nodes
// as this prevents accidentally moving a valid token onto a line comment ed line
var fixed = !options.token.getNextNonWhitespaceToken().isComment;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.iterate" id="apidoc.element.jscs.js_file.prototype.iterate">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>iterate
        <span class="apidocSignatureSpan">(cb, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">iterate = function (cb, tree) {
    return treeIterator.iterate(tree || this._program, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Iterates through the token tree using tree iterator.
 * Calls passed function for every token.
 *
 * @param {Function} cb
 * @param {Object} [tree]
 */
iterate: function(cb, tree) {
    return treeIterator.<span class="apidocCodeKeywordSpan">iterate</span>(tree || this._program, cb);
},

/**
 * Returns nodes by type(s) from earlier built index.
 *
 * @param {String|String[]} type
 * @returns {Object[]}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.iterateNodesByType" id="apidoc.element.jscs.js_file.prototype.iterateNodesByType">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>iterateNodesByType
        <span class="apidocSignatureSpan">(type, cb, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">iterateNodesByType = function (type, cb, context) {
    return this.getNodesByType(type).forEach(cb, context || this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },

    getOptionName: function() {
        return &#x27;disallowAnonymousFunctions&#x27;;
    },

    check: function(file, errors) {
        file.<span class="apidocCodeKeywordSpan">iterateNodesByType</span>([&#x27;FunctionExpression&#x27;, &#x27;FunctionDeclaration
&#x27;], function(node) {
            if (node.id === null) {
                errors.add(&#x27;Anonymous functions need to be named&#x27;, node);
            }
        });
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.iterateTokensByType" id="apidoc.element.jscs.js_file.prototype.iterateTokensByType">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>iterateTokensByType
        <span class="apidocSignatureSpan">(type, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">iterateTokensByType = function (type, cb) {
    var tokens;

    if (Array.isArray(type)) {
        tokens = [];
        for (var i = 0; i &#x3c; type.length; i++) {
            var items = this._program.selectTokensByType(type[i]);
            tokens = tokens.concat(items);
        }
    } else {
        tokens = this._program.selectTokensByType(type);
    }

    tokens.forEach(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
iterateTokensByTypeAndValue: function(type, value, cb) {
    var values = (typeof value === &#x27;string&#x27;) ? [value] : value;
    var valueIndex = {};
    values.forEach(function(type) {
        valueIndex[type] = true;
    });

    this.<span class="apidocCodeKeywordSpan">iterateTokensByType</span>(type, function(token) {
        if (valueIndex[token.value]) {
            cb(token);
        }
    });
},

getFirstTokenOnLineWith: function(element, options) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.iterateTokensByTypeAndValue" id="apidoc.element.jscs.js_file.prototype.iterateTokensByTypeAndValue">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>iterateTokensByTypeAndValue
        <span class="apidocSignatureSpan">(type, value, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">iterateTokensByTypeAndValue = function (type, value, cb) {
    var values = (typeof value === &#x27;string&#x27;) ? [value] : value;
    var valueIndex = {};
    values.forEach(function(type) {
        valueIndex[type] = true;
    });

    this.iterateTokensByType(type, function(token) {
        if (valueIndex[token.value]) {
            cb(token);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

return node.properties.some(function(property) {
    return property.value.type === &#x27;FunctionExpression&#x27;;
});
        }

        file.<span class="apidocCodeKeywordSpan">iterateTokensByTypeAndValue</span>(&#x27;Punctuator&#x27;, &#x27;,&#x27;, function
(token) {
var nextToken = token.getNextCodeToken();

if (canSkip(token) || nextToken.value === &#x27;,&#x27;) {
    return;
}

errors.assert.sameLine({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.render" id="apidoc.element.jscs.js_file.prototype.render">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>render
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function () {
    return this._program.getSourceCode();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                return err.fixed;
            });

            if (!hasFixes) {
                break;
            }

            file = this._createJsFileInstance(filename, file.<span class="apidocCodeKeywordSpan">render</span>());
            errors = new Errors(file);
            attempt++;
        } while (attempt &#x3c; MAX_FIX_ATTEMPTS);

        return {output: file.getSource(), errors: errors};
    }
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.setWhitespaceBefore" id="apidoc.element.jscs.js_file.prototype.setWhitespaceBefore">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>setWhitespaceBefore
        <span class="apidocSignatureSpan">(token, whitespace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setWhitespaceBefore = function (token, whitespace) {
    var prevToken = token.getPreviousToken();
    var ws = new Token(&#x27;Whitespace&#x27;, whitespace);
    var fragment = new Fragment(ws);

    if (prevToken &#x26;&#x26; prevToken.isWhitespace) {
        if (whitespace === &#x27;&#x27;) {
            prevToken.remove();
            return;
        }

        prevToken.parentElement.replaceChild(fragment, prevToken);
        return;
    }

    this._setTokenBefore(token, fragment);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    // Only attempt to remove or add lines if there are no comments between the two nodes
    // as this prevents accidentally moving a valid token onto a line comment ed line
    var fixed = !options.token.getNextNonWhitespaceToken().isComment;

    var emitError = function(countPrefix, spaceCount) {
var fix = function() {
    this._file.<span class="apidocCodeKeywordSpan">setWhitespaceBefore</span>(nextToken, new Array(spaceCount + 1).join(&#x27; &#
x27;));
}.bind(this);

var msgPostfix = token.value + &#x27; and &#x27; + nextToken.value;

if (!options.message) {
    if (exactly === 0) {
        // support noWhitespaceBetween
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.jsdoc" id="apidoc.module.jscs.jsdoc">module jscs.jsdoc</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.jsdoc.jsdoc" id="apidoc.element.jscs.jsdoc.jsdoc">
        function <span class="apidocSignatureSpan">jscs.</span>jsdoc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsdoc = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.jsdoc.prototype" id="apidoc.module.jscs.jsdoc.prototype">module jscs.jsdoc.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.jsdoc.prototype._getReturnStatementsForNode" id="apidoc.element.jscs.jsdoc.prototype._getReturnStatementsForNode">
        function <span class="apidocSignatureSpan">jscs.jsdoc.prototype.</span>_getReturnStatementsForNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getReturnStatementsForNode = function (node) {
    if (node.jsdoc.returnStatements) {
        return node.jsdoc.returnStatements;
    }

    var statements = [];
    this._iterate(function(n) {
        if (n &#x26;&#x26; n.type === &#x27;ReturnStatement&#x27; &#x26;&#x26; n.argument) {
            if (node === esprimaHelpers.closestScopeNode(n)) {
                statements.push(n.argument);
            }
        }
    }, node);

    node.jsdoc.returnStatements = statements;
    return statements;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.jsdoc.prototype.check" id="apidoc.element.jscs.jsdoc.prototype.check">
        function <span class="apidocSignatureSpan">jscs.jsdoc.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    patchNodesInFile(file);
    this._iterate = file.iterate;

    var _this = this;
    var scopes = {
        &#x27;function&#x27;: functionNodeTypes,
    };

    // classic checker
    if (_this._rulesForNodes.file) {
        // call file checkers
        var validators = _this._rulesForNodes.file;
        if (validators) {
            validators.forEach(function(v) {
                v.call(_this, file, errors);
            });
        }
    }

    // iterate over scopes
    Object.keys(scopes).forEach(function(scope) {

        // skip unused
        if (!_this._rulesForNodes[scope] &#x26;&#x26; !_this._rulesForTags[scope]) {
            return;
        }

        // traverse ast tree and search scope node types
        file.iterateNodesByType(scopes[scope], function(node) {
            // init
            var validators;

            // call node checkers
            validators = _this._rulesForNodes[scope];
            if (validators) {
                validators.forEach(function(v) {
                    v.call(_this, node, addError);
                });
            }

            validators = _this._rulesForTags[scope];
            if (!validators || !node.jsdoc || !node.jsdoc.valid) {
                return;
            }

            // call rule checkers
            node.jsdoc.iterate(function(tag) {
                if (!validators[&#x27;@&#x27; + tag.id]) {
                    return;
                }
                // call tag validator
                validators[&#x27;@&#x27; + tag.id].forEach(function(v) {
                    v.call(_this, node, tag, fixErrLocation(addError, tag));
                });
            });

<span class="apidocCodeCommentSpan">            /**
             * Send error to jscs
             *
             * @param {string} text
             * @param {number|DocLocation} offset
             */
</span>            function addError(text, offset) {
                if (typeof offset === &#x27;object&#x27;) {
                    if (offset.type) {
                        errors.add(text, offset, 0);
                        return;
                    } else {
                        offset = offset.offset;
                    }
                }
                errors.add(text, node.jsdoc.node, offset);
            }

            /**
             * Generates function with location fixing logic to send error to jscs
             *
             * @param {function(string, number|Object)} err
             * @param {DocTag} tag
             * @returns {function(string, number|Object)}
             */
            function fixErrLocation(err, tag) {
                return function(text, offset) {
                    err(text, offset || tag.loc.offset);
                };
            }
        });

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.jsdoc.prototype.configure" id="apidoc.element.jscs.jsdoc.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.jsdoc.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(typeof options === &#x27;object&#x27;, &#x27;jsDoc option requires object value&#x27;);

    // rules structured by scopes-tags for jsdoc-tags
    var rulesForTags = this._rulesForTags = {};
    // rules structured by scopes for nodes
    var rulesForNodes = this._rulesForNodes = {};

    this._options = options;
    this._optionsList = Object.keys(options);

    // load validators
    this._validators = validators.load(this._optionsList);
    assert(this._validators.length, &#x27;jsDoc plugin was not configured properly&#x27;);

    // registering validators
    this._validators.forEach(function(v) {
        // check options
        if (v.options) {
            validators.checkOptions(v, options);
        }
        // configure
        if (v.configure) {
            v.configure.call(this, options);
        }
        // index rules by tags and scopes
        (v.scopes || [&#x27;&#x27;]).forEach(function(scope) {
            if (!v.tags) {
                assert(v.length === 2, &#x27;jsDoc rules: Wrong arity in &#x27; + v._name + &#x27; validator&#x27;);
                rulesForNodes[scope] = rulesForNodes[scope] || [];
                rulesForNodes[scope].push(v);
                return;
            }
            assert(v.length === 3, &#x27;jsDoc rules: Wrong arity in &#x27; + v._name + &#x27; validator&#x27;);
            rulesForTags[scope] = rulesForTags[scope] || {};
            v.tags.forEach(function(tag) {
                var dtag = &#x27;@&#x27; + tag;
                rulesForTags[scope][dtag] = rulesForTags[scope][dtag] || [];
                rulesForTags[scope][dtag].push(v);
            });
        });
    }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.jsdoc.prototype.getOptionName" id="apidoc.element.jscs.jsdoc.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.jsdoc.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;jsDoc&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.maximum_line_length" id="apidoc.module.jscs.maximum_line_length">module jscs.maximum_line_length</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.maximum_line_length.maximum_line_length" id="apidoc.element.jscs.maximum_line_length.maximum_line_length">
        function <span class="apidocSignatureSpan">jscs.</span>maximum_line_length
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maximum_line_length = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.maximum_line_length.prototype" id="apidoc.module.jscs.maximum_line_length.prototype">module jscs.maximum_line_length.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.maximum_line_length.prototype.check" id="apidoc.element.jscs.maximum_line_length.prototype.check">
        function <span class="apidocSignatureSpan">jscs.maximum_line_length.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var maximumLineLength = this._maximumLineLength;

    var line;
    var lines = this._allowComments ?
        file.getLinesWithCommentsRemoved() : file.getLines();

    // This check should not be destructive
    lines = lines.slice();

    var removeLoc = function(tokenOrNode) {

        // Just in case (See #2107 for example)
        if (!tokenOrNode) {
            return;
        }

        for (var i = tokenOrNode.getLoc().start.line; i &#x3c;= tokenOrNode.getLoc().end.line; i++) {
            lines[i - 1] = &#x27;&#x27;;
        }
    };

    if (this._allowRegex) {
        file.iterateTokensByType(&#x27;RegularExpression&#x27;, function(token) {
            removeLoc(token);
        });
    }

    if (this._allowUrlComments) {
        file.iterateTokensByType([&#x27;CommentLine&#x27;, &#x27;CommentBlock&#x27;], function(comment) {
            for (var i = comment.getLoc().start.line; i &#x3c;= comment.getLoc().end.line; i++) {
                lines[i - 1] = lines[i - 1].replace(/(http|https|ftp):\/\/[^\s$]+/, &#x27;&#x27;);
            }
        });
    }

    if (this._allowFunctionSignature) {
        file.iterateNodesByType(&#x27;FunctionDeclaration&#x27;, function(node) {

            // Need to remove the first line, because we can&#x27;t be sure there&#x27;s any id or params
            lines[node.getLoc().start.line - 1] = &#x27;&#x27;;
            removeLoc(node.id);
            node.params.forEach(removeLoc);
        });

        file.iterateNodesByType(&#x27;ClassMethod&#x27;, function(node) {
            removeLoc(node.key);
        });

        file.iterateNodesByType([&#x27;ArrowFunctionExpression&#x27;, &#x27;FunctionExpression&#x27;], function(node) {

            // Need to remove the first line, because we can&#x27;t be sure there&#x27;s any id or params
            lines[node.getLoc().start.line - 1] = &#x27;&#x27;;
            removeLoc(node.id);
            node.params.forEach(removeLoc);
        });
    }

    if (this._allowRequire) {
        file.iterateNodesByType(&#x27;CallExpression&#x27;, function(node) {
            if (node.callee.name === &#x27;require&#x27;) {
                removeLoc(node);
            }
        });
    }

    for (var i = 0, l = lines.length; i &#x3c; l; i++) {
        line = this._tabSize ? lines[i].replace(/\t/g, this._tabSize) : lines[i];

        if (line.length &#x3e; maximumLineLength) {
            errors.add(
                &#x27;Line must be at most &#x27; + maximumLineLength + &#x27; characters&#x27;,
                file.getLastTokenOnLine(i + 1, { includeComments: true })
            );
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.maximum_line_length.prototype.configure" id="apidoc.element.jscs.maximum_line_length.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.maximum_line_length.prototype.</span>configure
        <span class="apidocSignatureSpan">(maximumLineLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (maximumLineLength) {
    this._tabSize = &#x27;&#x27;;
    this._allowRegex = false;
    this._allowComments = false;
    this._allowUrlComments = false;
    this._allowRequire = false;

    if (typeof maximumLineLength === &#x27;object&#x27;) {
        assert(
            typeof maximumLineLength.value === &#x27;number&#x27;,
            this.getOptionName() + &#x27; option requires the &#x22;value&#x22; property to be defined&#x27;
        );

        this._maximumLineLength = maximumLineLength.value;
        var tabSize = maximumLineLength.tabSize || 0;

        while (tabSize--) {
            this._tabSize += &#x27; &#x27;;
        }

        var exceptions = maximumLineLength.allExcept || [];
        this._allowRegex = (exceptions.indexOf(&#x27;regex&#x27;) !== -1);
        this._allowComments = (exceptions.indexOf(&#x27;comments&#x27;) !== -1);
        this._allowUrlComments = (exceptions.indexOf(&#x27;urlComments&#x27;) !== -1);
        this._allowFunctionSignature = (exceptions.indexOf(&#x27;functionSignature&#x27;) !== -1);
        this._allowRequire = (exceptions.indexOf(&#x27;require&#x27;) !== -1);

        if (maximumLineLength.hasOwnProperty(&#x27;allowRegex&#x27;)) {
            this._allowRegex = (maximumLineLength.allowRegex === true);
        }
        if (maximumLineLength.hasOwnProperty(&#x27;allowComments&#x27;)) {
            this._allowComments = (maximumLineLength.allowComments === true);
        }
        if (maximumLineLength.hasOwnProperty(&#x27;allowUrlComments&#x27;)) {
            this._allowUrlComments = (maximumLineLength.allowUrlComments === true);
        }

    } else {
        assert(
            typeof maximumLineLength === &#x27;number&#x27;,
            this.getOptionName() + &#x27; option requires number value or options object&#x27;
        );

        this._maximumLineLength = maximumLineLength;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.maximum_line_length.prototype.getOptionName" id="apidoc.element.jscs.maximum_line_length.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.maximum_line_length.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;maximumLineLength&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.maximum_number_of_lines" id="apidoc.module.jscs.maximum_number_of_lines">module jscs.maximum_number_of_lines</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.maximum_number_of_lines.maximum_number_of_lines" id="apidoc.element.jscs.maximum_number_of_lines.maximum_number_of_lines">
        function <span class="apidocSignatureSpan">jscs.</span>maximum_number_of_lines
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maximum_number_of_lines = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.maximum_number_of_lines.prototype" id="apidoc.module.jscs.maximum_number_of_lines.prototype">module jscs.maximum_number_of_lines.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.maximum_number_of_lines.prototype.check" id="apidoc.element.jscs.maximum_number_of_lines.prototype.check">
        function <span class="apidocSignatureSpan">jscs.maximum_number_of_lines.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var firstToken = file.getFirstToken({includeComments: true});
    var lines = this._allowComments ?
         file.getLines() : file.getLinesWithCommentsRemoved();

    lines = lines.filter(function(line) {return line !== &#x27;&#x27;;});

    if (lines.length &#x3e; this._maximumNumberOfLines) {
        errors.add(
            &#x27;File must be at most &#x27; + this._maximumNumberOfLines + &#x27; lines long&#x27;,
            firstToken,
            firstToken.value.length
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.maximum_number_of_lines.prototype.configure" id="apidoc.element.jscs.maximum_number_of_lines.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.maximum_number_of_lines.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    this._allowComments = true;

    if (typeof options === &#x27;number&#x27;) {
        assert(
            typeof options === &#x27;number&#x27;,
            this.getOptionName() + &#x27; option requires number value or options object&#x27;
        );
        this._maximumNumberOfLines = options;
    } else {
        assert(
            typeof options.value === &#x27;number&#x27;,
            this.getOptionName() + &#x27; option requires the &#x22;value&#x22; property to be defined&#x27;
        );
        this._maximumNumberOfLines = options.value;

        var exceptions = options.allExcept || [];
        this._allowComments = (exceptions.indexOf(&#x27;comments&#x27;) === -1);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.maximum_number_of_lines.prototype.getOptionName" id="apidoc.element.jscs.maximum_number_of_lines.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.maximum_number_of_lines.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;maximumNumberOfLines&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.node_configuration" id="apidoc.module.jscs.node_configuration">module jscs.node_configuration</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.node_configuration.node_configuration" id="apidoc.element.jscs.node_configuration.node_configuration">
        function <span class="apidocSignatureSpan">jscs.</span>node_configuration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodeConfiguration() {
    Configuration.call(this);
    this._basePath = process.cwd();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.node_configuration.super_" id="apidoc.element.jscs.node_configuration.super_">
        function <span class="apidocSignatureSpan">jscs.node_configuration.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Configuration() {
<span class="apidocCodeCommentSpan">    /**
     * List of the registered (not used) presets.
     *
     * @protected
     * @type {Object}
     */
</span>    this._presets = {};

    /**
     * Name of the preset (if used).
     *
     * @protected
     * @type {String|null}
     */
    this._presetName = null;

    /**
     * List of loaded presets.
     *
     * @protected
     * @type {String|null}
     */
    this._loadedPresets = [];

    /**
     * List of rules instances.
     *
     * @protected
     * @type {Object}
     */
    this._rules = {};

    /**
     * List of configurated rule instances.
     *
     * @protected
     * @type {Object}
     */
    this._ruleSettings = {};

    /**
     * List of configured rules.
     *
     * @protected
     * @type {Array}
     */
    this._configuredRules = [];

    /**
     * List of unsupported rules.
     *
     * @protected
     * @type {Array}
     */
    this._unsupportedRuleNames = [];

    /**
     * File extensions that would be checked.
     *
     * @protected
     * @type {Array}
     */
    this._fileExtensions = [];

    /**
     * List of defined options (not complete).
     *
     * @protected
     * @type {Array}
     */
    this._definedOptions = [];

    /**
     * Default file extensions that would be checked.
     *
     * @protected
     * @type {Array}
     */
    this._defaultFileExtensions = [&#x27;.js&#x27;];

    /**
     * Exclusion masks.
     *
     * @protected
     * @type {Array}
     */
    this._excludedFileMasks = [];

    /**
     * Default exclusion masks, will be rewritten if user has their own masks.
     *
     * @protected
     * @type {Array}
     */
    this._defaultExcludedFileMasks = [&#x27;.git/**&#x27;, &#x27;node_modules/**&#x27;];

    /**
     * List of existing files that falls under exclusion masks.
     *
     * @protected
     * @type {Array}
     */
    this._excludedFileMatchers = [];

    /**
     * Extraction masks.
     *
     * @protected
     * @type {Array}
     */
    this._extractFileMasks = [];

    /**
     * Default extractions masks.
     *
     * @protected
     * @type {Array}
     */
    this._defaultExtractFileMasks = [&#x27;**/*.+(htm|html|xhtml)&#x27;];

    /**
     * List of file matchers from which to extract JavaScript.
     *
     * @protected
     * @type {Array}
     */
    this._extractFileMatchers = [];

    /**
     * Maxixum amount of error that would be reportered.
     *
     * @protected
     * @type {Number}
     */
    this._maxErrors = defaults.maxErrors;

    /**
     * JSCS CWD.
     *
     * @protected
     * @type {String}
     */
    this._basePath = defaults.cwd;

    /**
     * List of overrided options (usually from CLI).
     *
     * @protected
     * @type {Object}
     */
    this._overrides = {};

    /**
     * Is &#x22;ES3&#x22; mode enabled?.
     *
     * @protected
     * @type {Boolean}
     */
    this._es3Enabled = false;

    /**
     * A filter function that determines whether or not to report an error.
     *
     * @protected
     * @type {Function|null}
     */
    this._errorFilter = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.node_configuration.prototype" id="apidoc.module.jscs.node_configuration.prototype">module jscs.node_configuration.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.node_configuration.prototype._loadAdditionalRule" id="apidoc.element.jscs.node_configuration.prototype._loadAdditionalRule">
        function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>_loadAdditionalRule
        <span class="apidocSignatureSpan">(additionalRule, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadAdditionalRule = function (additionalRule, config) {
    config = config || this._basePath;

    if (typeof additionalRule === &#x27;string&#x27;) {
        if (glob.hasMagic(additionalRule)) {

            // In some cases there might not be a config
            // like if options are defined through direct initialization (grunt plugin case)
            config = fs.statSync(config).isDirectory() ? config : path.dirname(config);

            glob.sync(path.resolve(config, additionalRule)).forEach(function(p) {
                var Rule = require(p);
                Configuration.prototype._loadAdditionalRule.call(this, new Rule());
            }, this);
        } else {
            var Rule = this.loadExternal(additionalRule, &#x27;rule&#x27;, config);
            Configuration.prototype._loadAdditionalRule.call(this, new Rule());
        }
    } else {
        Configuration.prototype._loadAdditionalRule.call(this, additionalRule);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this._definedOptions.push(&#x27;plugins&#x27;);
    }
}

if (options.hasOwnProperty(&#x27;additionalRules&#x27;)) {
    assert(Array.isArray(options.additionalRules), &#x27;`additionalRules` option requires array value&#x27;);
    options.additionalRules.forEach(function(rule) {
        this.<span class="apidocCodeKeywordSpan">_loadAdditionalRule</span>(rule, options.configPath);
    }, this);

    if (!this._isDefined(&#x27;additionalRules&#x27;)) {
        this._definedOptions.push(&#x27;additionalRules&#x27;);
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.node_configuration.prototype._loadErrorFilter" id="apidoc.element.jscs.node_configuration.prototype._loadErrorFilter">
        function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>_loadErrorFilter
        <span class="apidocSignatureSpan">(filter, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadErrorFilter = function (filter, config) {
    Configuration.prototype._loadErrorFilter.call(
        this,
        this.loadExternal(filter, &#x27;errorFilter&#x27;, config)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._loadMaxError(options);

if (options.hasOwnProperty(&#x27;es3&#x27;)) {
    this._loadES3(options.es3);
}

if (options.hasOwnProperty(&#x27;errorFilter&#x27;)) {
    this.<span class="apidocCodeKeywordSpan">_loadErrorFilter</span>(options.errorFilter, options.configPath);
}

// Apply presets
if (options.hasOwnProperty(&#x27;preset&#x27;)) {
    this._loadPreset(options.preset, options.configPath);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.node_configuration.prototype._loadPlugin" id="apidoc.element.jscs.node_configuration.prototype._loadPlugin">
        function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>_loadPlugin
        <span class="apidocSignatureSpan">(plugin, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadPlugin = function (plugin, config) {
    if (typeof plugin !== &#x27;function&#x27;) {
        plugin = this.loadExternal(plugin, &#x27;plugin&#x27;, config);
    }

    return Configuration.prototype._loadPlugin.call(this, plugin);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    );
    this._basePath = path.dirname(options.configPath);
}

if (options.hasOwnProperty(&#x27;plugins&#x27;)) {
    assert(Array.isArray(options.plugins), &#x27;`plugins` option requires array value&#x27;);
    options.plugins.forEach(function(plugin) {
        this.<span class="apidocCodeKeywordSpan">_loadPlugin</span>(plugin, options.configPath);
    }, this);

    if (!this._isDefined(&#x27;plugins&#x27;)) {
        this._definedOptions.push(&#x27;plugins&#x27;);
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.node_configuration.prototype._loadPreset" id="apidoc.element.jscs.node_configuration.prototype._loadPreset">
        function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>_loadPreset
        <span class="apidocSignatureSpan">(preset, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadPreset = function (preset, config) {
    var name = path.basename(preset).split(&#x27;.&#x27;)[0];

    try {
        this.registerPreset(name, this.loadExternal(preset, &#x27;preset&#x27;, config));
    } catch (e) {
        var registeredPresets = this.getRegisteredPresets();

        if (preset in registeredPresets) {
            Configuration.prototype._loadPreset.call(this, preset);
            return;
        }
    }

    // If preset is an external module, error will be thrown by the caller
    Configuration.prototype._loadPreset.call(this, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   if (options.hasOwnProperty(&#x27;errorFilter&#x27;)) {
       this._loadErrorFilter(options.errorFilter, options.configPath);
   }

   // Apply presets
   if (options.hasOwnProperty(&#x27;preset&#x27;)) {
       this.<span class="apidocCodeKeywordSpan">_loadPreset</span>(options.preset, options.configPath);
   }

   this._loadRules(currentConfig);
};

/**
* Loads plugin data.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.node_configuration.prototype.loadExternal" id="apidoc.element.jscs.node_configuration.prototype.loadExternal">
        function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>loadExternal
        <span class="apidocSignatureSpan">(external, type, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadExternal = function (external, type, config) {
    assert(
        typeof external === &#x27;string&#x27; || external === null,
        &#x27;&#x22;&#x27; + type + &#x27;&#x22; option requires a string or null value&#x27;
    );

    if (external === null) {
        return null;
    }

    var dir = config ? path.dirname(config) : this._basePath;
    var get = function(prefix, postfix) {
        prefix = prefix || &#x27;&#x27;;
        postfix = postfix || &#x27;&#x27;;

        try {
            return finder(
                utils.normalizePath(prefix + external + postfix, dir),
                dir
            );
        } catch (e) {}

        return null;
    }.bind(this);

    var finder;
    if (type === &#x27;preset&#x27;) {
        finder = configFinder.getContent;

    } else {
        finder = req;
    }

    var content;

    if (external.indexOf(&#x27;jscs-&#x27;) !== 0) {
        content = get(&#x27;jscs-&#x27;);

        if (!content &#x26;&#x26; type === &#x27;preset&#x27;) {
            content = get(&#x27;jscs-preset-&#x27;) || get(&#x27;jscs-config-&#x27;);

            if (!content &#x26;&#x26; external.indexOf(&#x27;/&#x27;) !== -1 &#x26;&#x26; !external.split(&#x27;.&#x27;)[1]) {
                content = get(&#x27;jscs-&#x27;, &#x27;.json&#x27;) ||
                    get(&#x27;jscs-&#x27;, &#x27;.js&#x27;) ||
                    get(&#x27;jscs-preset-&#x27;, &#x27;.json&#x27;) ||
                    get(&#x27;jscs-config-&#x27;, &#x27;.json&#x27;) ||
                    get(&#x27;jscs-preset-&#x27;, &#x27;.js&#x27;) ||
                    get(&#x27;jscs-config-&#x27;, &#x27;.js&#x27;);
            }
        }
    }

    return content || get();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @param {String|function(Configuration)} plugin
* @param {String} [config] - path to config relative to which plugin will be loaded
* @protected
*/
NodeConfiguration.prototype._loadPlugin = function(plugin, config) {
   if (typeof plugin !== &#x27;function&#x27;) {
       plugin = this.<span class="apidocCodeKeywordSpan">loadExternal</span>(plugin, &#x27;plugin&#x27;, config);
   }

   return Configuration.prototype._loadPlugin.call(this, plugin);
};

/**
* Loads preset.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.node_configuration.prototype.overrideFromCLI" id="apidoc.element.jscs.node_configuration.prototype.overrideFromCLI">
        function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>overrideFromCLI
        <span class="apidocSignatureSpan">(program)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">overrideFromCLI = function (program) {
    var overrides = {};

    OVERRIDE_OPTIONS.forEach(function(option) {
        if (option in program) {
            overrides[option] = program[option];
        }
    });

    this.override(overrides);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// To run autoconfigure over all errors in the path
if (program.autoConfigure) {
    program.maxErrors = Infinity;
}

checker.getConfiguration().<span class="apidocCodeKeywordSpan">overrideFromCLI</span>(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.configure(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_aligned_multiline_params" id="apidoc.module.jscs.require_aligned_multiline_params">module jscs.require_aligned_multiline_params</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_aligned_multiline_params.require_aligned_multiline_params" id="apidoc.element.jscs.require_aligned_multiline_params.require_aligned_multiline_params">
        function <span class="apidocSignatureSpan">jscs.</span>require_aligned_multiline_params
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_aligned_multiline_params = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_aligned_multiline_params.prototype" id="apidoc.module.jscs.require_aligned_multiline_params.prototype">module jscs.require_aligned_multiline_params.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_aligned_multiline_params.prototype.check" id="apidoc.element.jscs.require_aligned_multiline_params.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_aligned_multiline_params.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var _this = this;
    file.iterateNodesByType([&#x27;FunctionDeclaration&#x27;, &#x27;FunctionExpression&#x27;], function(node) {
        var params = node.params;

        // We can pass the check if there&#x27;s no params
        if (params.length === 0) {
            return;
        }

        var firstParam = params[0];
        var referenceColumn;
        var body;

        if (_this._alignWithFirstParam) {
            referenceColumn = getNodeColumn(firstParam);
        } else {

            body = node.body.body[0];

            // If function doesn&#x27;t have a body just bail out (#1988)
            if (!body) {
                return;
            }

            referenceColumn = body.getLoc().start.column + _this._indentationLevel;
        }

        var previousParam = firstParam;
        params.slice(1).forEach(function(param) {
            if (!file.isOnTheSameLine(previousParam, param)) {
                var paramColumn = getNodeColumn(param);
                if (paramColumn !== referenceColumn) {
                    errors.assert.indentation({
                        token: param.getFirstToken(),
                        actual: paramColumn,
                        expected: referenceColumn,
                        indentChar: &#x27; &#x27;
                    });
                }

                previousParam = param;
            }
        });

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_aligned_multiline_params.prototype.configure" id="apidoc.element.jscs.require_aligned_multiline_params.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_aligned_multiline_params.prototype.</span>configure
        <span class="apidocSignatureSpan">(option)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (option) {
    if (typeof option === &#x27;number&#x27;) {
        this._indentationLevel = option;
    } else if (typeof option === &#x27;string&#x27;) {
        assert(
            option === &#x27;firstParam&#x27;,
            this.getOptionName() + &#x27; option requires string value to be &#x22;firstParam&#x22;&#x27;
        );

        this._alignWithFirstParam = true;
    } else if (option === true) {
        this._indentationLevel = 0;
    } else {
        assert(
            false,
            this.getOptionName() + &#x27; option requires a valid option&#x27;
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_aligned_multiline_params.prototype.getOptionName" id="apidoc.element.jscs.require_aligned_multiline_params.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_aligned_multiline_params.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireAlignedMultilineParams&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_aligned_object_values" id="apidoc.module.jscs.require_aligned_object_values">module jscs.require_aligned_object_values</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_aligned_object_values.require_aligned_object_values" id="apidoc.element.jscs.require_aligned_object_values.require_aligned_object_values">
        function <span class="apidocSignatureSpan">jscs.</span>require_aligned_object_values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_aligned_object_values = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_aligned_object_values.prototype" id="apidoc.module.jscs.require_aligned_object_values.prototype">module jscs.require_aligned_object_values.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_aligned_object_values.prototype.check" id="apidoc.element.jscs.require_aligned_object_values.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_aligned_object_values.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var mode = this._mode;

    file.iterateNodesByType(&#x27;ObjectExpression&#x27;, function(node) {
        if (node.getNewlineCount() === 0 || node.properties &#x3c; 2) {
            return;
        }

        var maxKeyEndPos = 0;
        var prevKeyEndPos = 0;
        var minColonPos = 0;
        var tokens = [];
        var skip = node.properties.some(function(property, index) {
            if (property.shorthand || property.method ||
                property.type === &#x27;SpreadProperty&#x27;) {
                return true;
            }

            if (mode === &#x27;ignoreFunction&#x27; &#x26;&#x26; property.value.type === &#x27;FunctionExpression&#x27;) {
                return true;
            }

            if (mode === &#x27;ignoreLineBreak&#x27; &#x26;&#x26; index &#x3e; 0 &#x26;&#x26;
                 node.properties[index - 1].getLoc().end.line !== property.getLoc().start.line - 1) {
                return true;
            }

            prevKeyEndPos = maxKeyEndPos;
            maxKeyEndPos = Math.max(maxKeyEndPos, property.key.getLoc().end.column);
            var keyToken = file.getFirstNodeToken(property.key);
            if (property.computed === true) {
                while (keyToken.value !== &#x27;]&#x27;) {
                    keyToken = file.getNextToken(keyToken);
                }
            }
            var colon = file.getNextToken(keyToken);
            if (prevKeyEndPos &#x3c; maxKeyEndPos) {
                minColonPos = colon.getLoc().start.column;
            }
            tokens.push({key: keyToken, colon: colon});
        });

        if (skip) {
            return;
        }

        var space = minColonPos - maxKeyEndPos;
        tokens.forEach(function(pair) {
            errors.assert.spacesBetween({
                token: pair.key,
                nextToken: pair.colon,
                exactly: maxKeyEndPos - pair.key.getLoc().end.column + space,
                message: &#x27;Alignment required&#x27;
            });
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_aligned_object_values.prototype.configure" id="apidoc.element.jscs.require_aligned_object_values.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_aligned_object_values.prototype.</span>configure
        <span class="apidocSignatureSpan">(mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (mode) {
    var modes = {
        &#x27;all&#x27;: &#x27;all&#x27;,
        &#x27;ignoreFunction&#x27;: &#x27;ignoreFunction&#x27;,
        &#x27;ignoreLineBreak&#x27;: &#x27;ignoreLineBreak&#x27;,
        &#x27;skipWithFunction&#x27;: &#x27;ignoreFunction&#x27;,
        &#x27;skipWithLineBreak&#x27;: &#x27;ignoreLineBreak&#x27;
    };
    assert(
        typeof mode === &#x27;string&#x27; &#x26;&#x26; modes[mode],
        this.getOptionName() + &#x27; requires one of the following values: &#x27; + Object.keys(modes).join(&#x27;, &#x27;)
    );
    this._mode = modes[mode];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_aligned_object_values.prototype.getOptionName" id="apidoc.element.jscs.require_aligned_object_values.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_aligned_object_values.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireAlignedObjectValues&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_anonymous_functions" id="apidoc.module.jscs.require_anonymous_functions">module jscs.require_anonymous_functions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_anonymous_functions.require_anonymous_functions" id="apidoc.element.jscs.require_anonymous_functions.require_anonymous_functions">
        function <span class="apidocSignatureSpan">jscs.</span>require_anonymous_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_anonymous_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_anonymous_functions.prototype" id="apidoc.module.jscs.require_anonymous_functions.prototype">module jscs.require_anonymous_functions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_anonymous_functions.prototype.check" id="apidoc.element.jscs.require_anonymous_functions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_anonymous_functions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptDeclarations = this._exceptDeclarations;

    file.iterateNodesByType([&#x27;FunctionExpression&#x27;, &#x27;FunctionDeclaration&#x27;], function(node) {
        if (exceptDeclarations &#x26;&#x26; node.type === &#x27;FunctionDeclaration&#x27;) {
            return;
        }
        if (node.id !== null) {
            errors.add(&#x27;Functions must not be named&#x27;, node);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_anonymous_functions.prototype.configure" id="apidoc.element.jscs.require_anonymous_functions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_anonymous_functions.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var optionName = this.getOptionName();

    if (typeof options === &#x27;object&#x27;) {
        assert(Array.isArray(options.allExcept), optionName + &#x27; option requires &#x22;allExcept&#x22; to be an array&#x27;);
        assert(options.allExcept.length &#x3e; 0, optionName + &#x27; option requires &#x22;allExcept&#x22; to have at least one &#x27; +
        &#x27; item or be set to `true`&#x27;);
        this._exceptDeclarations = options.allExcept.indexOf(&#x27;declarations&#x27;) &#x3e; -1;
    } else {
        assert(options === true, this.getOptionName() + &#x27; option requires either a true value or an object&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_anonymous_functions.prototype.getOptionName" id="apidoc.element.jscs.require_anonymous_functions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_anonymous_functions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireAnonymousFunctions&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_array_destructuring" id="apidoc.module.jscs.require_array_destructuring">module jscs.require_array_destructuring</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_array_destructuring.require_array_destructuring" id="apidoc.element.jscs.require_array_destructuring.require_array_destructuring">
        function <span class="apidocSignatureSpan">jscs.</span>require_array_destructuring
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_array_destructuring = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_array_destructuring.prototype" id="apidoc.module.jscs.require_array_destructuring.prototype">module jscs.require_array_destructuring.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_array_destructuring.prototype.check" id="apidoc.element.jscs.require_array_destructuring.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_array_destructuring.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;VariableDeclaration&#x27;, function(node) {

        node.declarations.forEach(function(declaration) {
            if (!declaration.init || declaration.init.type !== &#x27;MemberExpression&#x27;) {
                return;
            }

            var property = declaration.init.property || {};
            if (property.type.indexOf(&#x27;Literal&#x27;) &#x3e; -1 &#x26;&#x26; /^\d+$/.test(property.value)) {
                errors.add(&#x27;Use array destructuring&#x27;, property);
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_array_destructuring.prototype.configure" id="apidoc.element.jscs.require_array_destructuring.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_array_destructuring.prototype.</span>configure
        <span class="apidocSignatureSpan">(option)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (option) {
    assert(option === true, this.getOptionName() + &#x27; requires a true value&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_array_destructuring.prototype.getOptionName" id="apidoc.element.jscs.require_array_destructuring.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_array_destructuring.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireArrayDestructuring&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_arrow_functions" id="apidoc.module.jscs.require_arrow_functions">module jscs.require_arrow_functions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_arrow_functions.require_arrow_functions" id="apidoc.element.jscs.require_arrow_functions.require_arrow_functions">
        function <span class="apidocSignatureSpan">jscs.</span>require_arrow_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_arrow_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_arrow_functions.prototype" id="apidoc.module.jscs.require_arrow_functions.prototype">module jscs.require_arrow_functions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_arrow_functions.prototype.check" id="apidoc.element.jscs.require_arrow_functions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_arrow_functions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {

    function isCallback(node) {
        return node.type === &#x27;FunctionExpression&#x27; &#x26;&#x26; node.parentElement.type === &#x27;CallExpression&#x27;;
    }

    function isFunctionBindWithThis(node) {
        return node.callee &#x26;&#x26;
        node.callee.type === &#x27;MemberExpression&#x27; &#x26;&#x26;
        node.callee.object.type === &#x27;FunctionExpression&#x27; &#x26;&#x26;
        node.callee.property.type === &#x27;Identifier&#x27; &#x26;&#x26;
        node.callee.property.name === &#x27;bind&#x27; &#x26;&#x26;
        node.arguments &#x26;&#x26;
        node.arguments.length === 1 &#x26;&#x26; node.arguments[0].type === &#x27;ThisExpression&#x27;;
    }

    file.iterateNodesByType([&#x27;FunctionExpression&#x27;, &#x27;CallExpression&#x27;], function(node) {
        if (isCallback(node) || isFunctionBindWithThis(node)) {
            errors.add(&#x27;Use arrow functions instead of function expressions&#x27;, node);
        }

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_arrow_functions.prototype.configure" id="apidoc.element.jscs.require_arrow_functions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_arrow_functions.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_arrow_functions.prototype.getOptionName" id="apidoc.element.jscs.require_arrow_functions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_arrow_functions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireArrowFunctions&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_blocks_on_newline" id="apidoc.module.jscs.require_blocks_on_newline">module jscs.require_blocks_on_newline</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_blocks_on_newline.require_blocks_on_newline" id="apidoc.element.jscs.require_blocks_on_newline.require_blocks_on_newline">
        function <span class="apidocSignatureSpan">jscs.</span>require_blocks_on_newline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_blocks_on_newline = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_blocks_on_newline.prototype" id="apidoc.module.jscs.require_blocks_on_newline.prototype">module jscs.require_blocks_on_newline.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_blocks_on_newline.prototype.check" id="apidoc.element.jscs.require_blocks_on_newline.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_blocks_on_newline.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var minLines = this._minLines;
    var includeComments = this._includeComments;

    file.iterateNodesByType(&#x27;BlockStatement&#x27;, function(node) {
        var hasComment = false;
        if (includeComments === true) {
            hasComment = hasCommentInBlock(node);
        }

        if (hasComment === false &#x26;&#x26; node.body.length &#x3c;= minLines) {
            return;
        }

        var openingBracket = node.getFirstToken();
        var nextToken = file.getNextToken(openingBracket, { includeComments: includeComments });

        errors.assert.differentLine({
            token: openingBracket,
            nextToken: nextToken,
            message: &#x27;Missing newline after opening curly brace&#x27;
        });

        var closingBracket = file.getLastNodeToken(node);
        var prevToken = file.getPrevToken(closingBracket, { includeComments: includeComments });

        errors.assert.differentLine({
            token: prevToken,
            nextToken: closingBracket,
            message: &#x27;Missing newline before closing curly brace&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_blocks_on_newline.prototype.configure" id="apidoc.element.jscs.require_blocks_on_newline.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_blocks_on_newline.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var optionType = typeof options;
    assert(
        options === true || optionType === &#x27;number&#x27; || optionType === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option requires the value true, an Integer or an object&#x27;
    );

    this._minLines = 0;
    this._includeComments = false;
    if (optionType === &#x27;number&#x27;) {
        this._minLines = options;
    } else if (optionType === &#x27;object&#x27;) {
        assert(
            options.includeComments === true,
            this.getOptionName() + &#x27; option requires includeComments property to be true for object&#x27;
        );
        this._includeComments = options.includeComments;

        if (options.hasOwnProperty(&#x27;minLines&#x27;)) {
            assert(
                typeof options.minLines === &#x27;number&#x27;,
                this.getOptionName() + &#x27; option requires minLines property to be an integer for object&#x27;
            );
            this._minLines = options.minLines;
        }
    }

    assert(
        this._minLines &#x3e;= 0,
        this.getOptionName() + &#x27; option requires minimum statements setting to be &#x3e;= 0&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_blocks_on_newline.prototype.getOptionName" id="apidoc.element.jscs.require_blocks_on_newline.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_blocks_on_newline.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireBlocksOnNewline&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_camelcase_or_uppercase_identifiers" id="apidoc.module.jscs.require_camelcase_or_uppercase_identifiers">module jscs.require_camelcase_or_uppercase_identifiers</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.require_camelcase_or_uppercase_identifiers" id="apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.require_camelcase_or_uppercase_identifiers">
        function <span class="apidocSignatureSpan">jscs.</span>require_camelcase_or_uppercase_identifiers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_camelcase_or_uppercase_identifiers = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_camelcase_or_uppercase_identifiers.prototype" id="apidoc.module.jscs.require_camelcase_or_uppercase_identifiers.prototype">module jscs.require_camelcase_or_uppercase_identifiers.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.check" id="apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_camelcase_or_uppercase_identifiers.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByType(&#x27;Identifier&#x27;, function(token) {
        var value = token.value;

        // Leading and trailing underscores signify visibility/scope and do not affect
        // validation of the rule.  Remove them to simplify the checks.
        var isPrivate = (value[0] === &#x27;_&#x27;);
        value = value.replace(/^_+|_+$/g, &#x27;&#x27;);

        // Detect exceptions before stripping prefixes/suffixes.
        if (this._allExcept) {
            for (i = 0, len = this._allExcept.length; i &#x3c; len; ++i) {
                if (matchException(value, this._allExcept[i])) {
                    return;
                }
            }
        }

        // Strip at most one prefix permitted text from the identifier.  This transformation
        // cannot change an acceptable identifier into an unacceptable identifier so we can
        // continue with the normal verification of whatever it produces.
        var i;
        var len;
        if (this._allowedPrefixes) {
            for (i = 0, len = this._allowedPrefixes.length; i &#x3c; len; ++i) {
                var prefix = this._allowedPrefixes[i];
                var start;
                if (typeof prefix === &#x27;string&#x27;) {
                    start = startAfterStringPrefix(value, prefix);
                } else {
                    start = startAfterRegExpPrefix(value, prefix);
                }
                if (start !== undefined) {
                    value = value.substr(start);
                    break;
                }
            }
        }

        // As with prefix but for one suffix permitted text.
        if (this._allowedSuffixes) {
            for (i = 0, len = this._allowedSuffixes.length; i &#x3c; len; ++i) {
                var suffix = this._allowedSuffixes[i];
                var ends;
                if (typeof suffix === &#x27;string&#x27;) {
                    ends = endBeforeStringSuffix(value, suffix);
                } else {
                    ends = endBeforeRegExpSuffix(value, suffix);
                }
                if (ends !== undefined) {
                    value = value.substr(0, ends);
                    break;
                }
            }
        }

        if (value.indexOf(&#x27;_&#x27;) === -1 || value.toUpperCase() === value) {
            if (!this._strict) {return;}
            if (value.length === 0 || value[0].toUpperCase() !== value[0] || isPrivate) {
                return;
            }
        }
        if (this._ignoreProperties) {
            var nextToken = file.getNextToken(token);
            var prevToken = token.getPreviousCodeToken();

            if (nextToken &#x26;&#x26; nextToken.value === &#x27;:&#x27;) {
                return;
            }

<span class="apidocCodeCommentSpan">            /* This enables an identifier to be snake cased via the object
             * destructuring pattern. We must check to see if the identifier
             * is being used to set values into an object to determine if
             * this is a legal assignment.
             * Example: ({camelCase: snake_case}) =&#x3e; camelCase.length
             */
</span>            if (prevToken &#x26;&#x26; prevToken.value === &#x27;:&#x27;) {
                var node = token.parentElement;
                var parentElement = node.parentElement;
                if (parentElement &#x26;&#x26; parentElement.type === &#x27;ObjectProperty&#x27;) {
                    var grandpa = parentElement.parentElement;
                    if (grandpa &#x26;&#x26; grandpa.type === &#x27;ObjectPattern&#x27;) {
                        return;
                    }
                }
            }

            if (prevToken &#x26;&#x26; (prevToken.value === &#x27;.&#x27; ||
                prevToken.value === &#x27;get&#x27; || prevToken.value === &#x27;set&#x27;)) {
                return;
            }
        }
        errors.add(
            &#x27;All identifiers must be camelCase or UPPER_CASE&#x27;,
            token
        );
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.configure" id="apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_camelcase_or_uppercase_identifiers.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    if (typeof options !== &#x27;object&#x27;) {
        assert(
          options === true || options === &#x27;ignoreProperties&#x27;,
          this.getOptionName() + &#x27; option requires a true value or `ignoreProperties`&#x27;
        );
        var _options = {
            ignoreProperties: options === &#x27;ignoreProperties&#x27; ? true : false,
            strict: false
        };
        return this.configure(_options);
    }

    assert(
      !options.hasOwnProperty(&#x27;ignoreProperties&#x27;) || typeof options.ignoreProperties === &#x27;boolean&#x27;,
      this.getOptionName() + &#x27; option should have boolean value for ignoreProperties&#x27;
    );
    this._ignoreProperties = options.ignoreProperties;

    assert(
      !options.hasOwnProperty(&#x27;strict&#x27;) || typeof options.strict === &#x27;boolean&#x27;,
      this.getOptionName() + &#x27; option should have boolean value for strict&#x27;
    );
    this._strict = options.strict;

    var asre = processArrayOfStringOrRegExp(options.allowedPrefixes);
    assert(
      !options.hasOwnProperty(&#x27;allowedPrefixes&#x27;) || asre,
      this.getOptionName() + &#x27; option should have array of string or RegExp for allowedPrefixes&#x27;
    );
    if (asre) {
        this._allowedPrefixes = asre;
    }

    asre = processArrayOfStringOrRegExp(options.allowedSuffixes);
    assert(
      !options.hasOwnProperty(&#x27;allowedSuffixes&#x27;) || asre,
      this.getOptionName() + &#x27; option should have array of string or RegExp for allowedSuffixes&#x27;
    );
    if (asre) {
        this._allowedSuffixes = asre;
    }

    asre = processArrayOfStringOrRegExp(options.allExcept);
    assert(
      !options.hasOwnProperty(&#x27;allExcept&#x27;) || asre,
      this.getOptionName() + &#x27; option should have array of string or RegExp for allExcept&#x27;
    );
    if (asre) {
        this._allExcept = asre;
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.getOptionName" id="apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_camelcase_or_uppercase_identifiers.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireCamelCaseOrUpperCaseIdentifiers&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_capitalized_comments" id="apidoc.module.jscs.require_capitalized_comments">module jscs.require_capitalized_comments</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.require_capitalized_comments" id="apidoc.element.jscs.require_capitalized_comments.require_capitalized_comments">
        function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_capitalized_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_capitalized_comments.prototype" id="apidoc.module.jscs.require_capitalized_comments.prototype">module jscs.require_capitalized_comments.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype._fix" id="apidoc.element.jscs.require_capitalized_comments.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var comment = error.additional;
    var first = this._getFirstChar(comment);

    var newValue = comment.value.replace(first, first.toUpperCase());
    var newComment = new cst.Token(comment.type, newValue);

    comment.parentElement.replaceChild(newComment, comment);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &#x26;&#x26; instance._fix) {
        // &#x22;error.fixed = true&#x22; should go first, so rule can
        // decide for itself (with &#x22;error.fixed = false&#x22;)
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype._getFirstChar" id="apidoc.element.jscs.require_capitalized_comments.prototype._getFirstChar">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_getFirstChar
        <span class="apidocSignatureSpan">(comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getFirstChar = function (comment) {
    return comment.value.replace(/[\n\s\*]/g, &#x27;&#x27;)[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

_isException: function(comment) {
    return this._isPragma(comment.value);
},

_isValid: function(comment) {
    var first = this.<span class="apidocCodeKeywordSpan">_getFirstChar</span>(comment);

    return first &#x26;&#x26; upperCasePattern.test(first);
},

_isLetter: function(comment) {
    var first = this._getFirstChar(comment);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype._isException" id="apidoc.element.jscs.require_capitalized_comments.prototype._isException">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isException
        <span class="apidocSignatureSpan">(comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isException = function (comment) {
    return this._isPragma(comment.value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    message: &#x27;Comments must start with an uppercase letter, unless it is part of a textblock&#x27;,
    element: comment,
    additional: comment
});
        }

        file.iterateTokensByType(&#x27;CommentLine&#x27;, function(comment) {
if (_this.<span class="apidocCodeKeywordSpan">_isException</span>(comment)) {
    return;
}

if (_this._isUrl(comment)) {
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype._isLetter" id="apidoc.element.jscs.require_capitalized_comments.prototype._isLetter">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isLetter
        <span class="apidocSignatureSpan">(comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isLetter = function (comment) {
    var first = this._getFirstChar(comment);

    return first &#x26;&#x26; letterPattern.test(first);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
}

if (_this._isUrl(comment)) {
    return;
}

if (!_this.<span class="apidocCodeKeywordSpan">_isLetter</span>(comment)) {
    return;
}

if (_this._isTextBlock(file, comment)) {
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype._isTextBlock" id="apidoc.element.jscs.require_capitalized_comments.prototype._isTextBlock">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isTextBlock
        <span class="apidocSignatureSpan">(file, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isTextBlock = function (file, comment) {
    var prevComment = file.getPrevToken(comment, {includeComments: true});

    if (prevComment) {
        return prevComment.type === &#x27;CommentLine&#x27; &#x26;&#x26;
            !file.isOnTheSameLine(comment, prevComment) &#x26;&#x26;
            prevComment.value.trim().length &#x3e; 0;
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
}

if (!_this._isLetter(comment)) {
    return;
}

if (_this.<span class="apidocCodeKeywordSpan">_isTextBlock</span>(file, comment)) {
    return;
}

if (_this._isValid(comment)) {
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype._isUrl" id="apidoc.element.jscs.require_capitalized_comments.prototype._isUrl">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isUrl
        <span class="apidocSignatureSpan">(comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isUrl = function (comment) {
    var protocolParts = comment.value.split(&#x27;://&#x27;);

    if (protocolParts.length === 1) {
        return false;
    }

    return comment.value.indexOf(protocolParts[0]) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }

        file.iterateTokensByType(&#x27;CommentLine&#x27;, function(comment) {
if (_this._isException(comment)) {
    return;
}

if (_this.<span class="apidocCodeKeywordSpan">_isUrl</span>(comment)) {
    return;
}

if (!_this._isLetter(comment)) {
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype._isValid" id="apidoc.element.jscs.require_capitalized_comments.prototype._isValid">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isValid
        <span class="apidocSignatureSpan">(comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isValid = function (comment) {
    var first = this._getFirstChar(comment);

    return first &#x26;&#x26; upperCasePattern.test(first);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return;
    }

    if (_this._isTextBlock(file, comment)) {
        return;
    }

    if (_this.<span class="apidocCodeKeywordSpan">_isValid</span>(comment)) {
        return;
    }

    add(comment);
});

file.iterateTokensByType(&#x27;CommentBlock&#x27;, function(comment) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype._shouldIgnoreIfInTheMiddle" id="apidoc.element.jscs.require_capitalized_comments.prototype._shouldIgnoreIfInTheMiddle">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_shouldIgnoreIfInTheMiddle
        <span class="apidocSignatureSpan">(file, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_shouldIgnoreIfInTheMiddle = function (file, comment) {
    if (!this.inlined) {
        return false;
    }

    var firstToken = comment.getFirstToken();
    var otherToken = firstToken.getPreviousNonWhitespaceToken();

    return otherToken ? file.isOnTheSameLine(otherToken, firstToken) : false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
}

if (!_this._isLetter(comment)) {
    return;
}

if (_this.<span class="apidocCodeKeywordSpan">_shouldIgnoreIfInTheMiddle</span>(file, comment)) {
    return;
}

if (_this._isValid(comment)) {
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype.check" id="apidoc.element.jscs.require_capitalized_comments.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var _this = this;

    function add(comment) {
        errors.cast({
            message: &#x27;Comments must start with an uppercase letter, unless it is part of a textblock&#x27;,
            element: comment,
            additional: comment
        });
    }

    file.iterateTokensByType(&#x27;CommentLine&#x27;, function(comment) {
        if (_this._isException(comment)) {
            return;
        }

        if (_this._isUrl(comment)) {
            return;
        }

        if (!_this._isLetter(comment)) {
            return;
        }

        if (_this._isTextBlock(file, comment)) {
            return;
        }

        if (_this._isValid(comment)) {
            return;
        }

        add(comment);
    });

    file.iterateTokensByType(&#x27;CommentBlock&#x27;, function(comment) {
        if (_this._isException(comment)) {
            return;
        }

        if (_this._isUrl(comment)) {
            return;
        }

        if (!_this._isLetter(comment)) {
            return;
        }

        if (_this._shouldIgnoreIfInTheMiddle(file, comment)) {
            return;
        }

        if (_this._isValid(comment)) {
            return;
        }

        add(comment);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype.configure" id="apidoc.element.jscs.require_capitalized_comments.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var exceptions;

    this.inlined = false;
    this._isPragma = null;

    var optionName = this.getOptionName();

    var isObject = typeof options === &#x27;object&#x27;;
    var error = optionName + &#x27; option requires a true value &#x27; +
        &#x27;or an object with String[] `allExcept` property or true with `inlined`&#x27;;

    assert(
        options === true ||
        isObject,
        error
    );

    if (isObject &#x26;&#x26; options.allExcept) {
        exceptions = options.allExcept;

        // verify items in `allExcept` property in object are string values
        assert(
            Array.isArray(exceptions) &#x26;&#x26;
            exceptions.every(function(el) { return typeof el === &#x27;string&#x27;; }),
            &#x27;Property `allExcept` in &#x27; + optionName + &#x27; should be an array of strings&#x27;
        );

        this._isPragma = isPragma(exceptions);
    }

    if (!this._isPragma) {
        this._isPragma = isPragma();
    }

    if (isObject &#x26;&#x26; options.inlined) {
        this.inlined = true;
    }

    if (isObject &#x26;&#x26; !options.allExcept &#x26;&#x26; !options.inlined) {
        assert(false, error);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype.getOptionName" id="apidoc.element.jscs.require_capitalized_comments.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireCapitalizedComments&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_capitalized_constructors" id="apidoc.module.jscs.require_capitalized_constructors">module jscs.require_capitalized_constructors</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors.require_capitalized_constructors" id="apidoc.element.jscs.require_capitalized_constructors.require_capitalized_constructors">
        function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_capitalized_constructors = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_capitalized_constructors.prototype" id="apidoc.module.jscs.require_capitalized_constructors.prototype">module jscs.require_capitalized_constructors.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors.prototype.check" id="apidoc.element.jscs.require_capitalized_constructors.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var allowedConstructors = this._allowedConstructors;

    file.iterateNodesByType(&#x27;NewExpression&#x27;, function(node) {
        if (node.callee.type === &#x27;Identifier&#x27; &#x26;&#x26;
            !allowedConstructors[node.callee.name] &#x26;&#x26;
            node.callee.name[0].toUpperCase() !== node.callee.name[0]
        ) {
            errors.add(
                &#x27;Constructor functions should be capitalized&#x27;,
                node.callee
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors.prototype.configure" id="apidoc.element.jscs.require_capitalized_constructors.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || Array.isArray(options.allExcept),
        this.getOptionName() + &#x27; option requires a true value or an object of exceptions&#x27;
    );
    this._allowedConstructors = {};

    var allExcept = options.allExcept;
    if (allExcept) {
        for (var i = 0, l = allExcept.length; i &#x3c; l; i++) {
            this._allowedConstructors[allExcept[i]] = true;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors.prototype.getOptionName" id="apidoc.element.jscs.require_capitalized_constructors.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireCapitalizedConstructors&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_capitalized_constructors_new" id="apidoc.module.jscs.require_capitalized_constructors_new">module jscs.require_capitalized_constructors_new</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors_new.require_capitalized_constructors_new" id="apidoc.element.jscs.require_capitalized_constructors_new.require_capitalized_constructors_new">
        function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors_new
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_capitalized_constructors_new = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_capitalized_constructors_new.prototype" id="apidoc.module.jscs.require_capitalized_constructors_new.prototype">module jscs.require_capitalized_constructors_new.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors_new.prototype.check" id="apidoc.element.jscs.require_capitalized_constructors_new.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors_new.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var allowedConstructors = this._allowedConstructors;

    file.iterateNodesByType(&#x27;CallExpression&#x27;, function(node) {
        if (node.callee.type === &#x27;Identifier&#x27; &#x26;&#x26;
            !allowedConstructors[node.callee.name] &#x26;&#x26;
            node.callee.name[0].toLowerCase() !== node.callee.name[0]
        ) {
            errors.add(
                &#x27;Constructor functions should use the &#x22;new&#x22; keyword&#x27;,
                node.callee
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors_new.prototype.configure" id="apidoc.element.jscs.require_capitalized_constructors_new.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors_new.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || Array.isArray(options.allExcept),
        this.getOptionName() + &#x27; option requires a true value or an object of exceptions&#x27;
    );
    this._allowedConstructors = {};

    var allExcept = options.allExcept;
    if (allExcept) {
        for (var i = 0, l = allExcept.length; i &#x3c; l; i++) {
            this._allowedConstructors[allExcept[i]] = true;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors_new.prototype.getOptionName" id="apidoc.element.jscs.require_capitalized_constructors_new.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors_new.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireCapitalizedConstructorsNew&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_comma_before_line_break" id="apidoc.module.jscs.require_comma_before_line_break">module jscs.require_comma_before_line_break</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_comma_before_line_break.require_comma_before_line_break" id="apidoc.element.jscs.require_comma_before_line_break.require_comma_before_line_break">
        function <span class="apidocSignatureSpan">jscs.</span>require_comma_before_line_break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_comma_before_line_break = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_comma_before_line_break.prototype" id="apidoc.module.jscs.require_comma_before_line_break.prototype">module jscs.require_comma_before_line_break.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_comma_before_line_break.prototype.check" id="apidoc.element.jscs.require_comma_before_line_break.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_comma_before_line_break.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;,&#x27;, function(token) {
        var prevToken = token.getPreviousCodeToken();

        if (prevToken.value === &#x27;,&#x27;) {
            return;
        }
        errors.assert.sameLine({
            token: prevToken,
            nextToken: token,
            message: &#x27;Commas should not be placed on new line&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_comma_before_line_break.prototype.configure" id="apidoc.element.jscs.require_comma_before_line_break.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_comma_before_line_break.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_comma_before_line_break.prototype.getOptionName" id="apidoc.element.jscs.require_comma_before_line_break.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_comma_before_line_break.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireCommaBeforeLineBreak&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_curly_braces" id="apidoc.module.jscs.require_curly_braces">module jscs.require_curly_braces</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_curly_braces.require_curly_braces" id="apidoc.element.jscs.require_curly_braces.require_curly_braces">
        function <span class="apidocSignatureSpan">jscs.</span>require_curly_braces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_curly_braces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_curly_braces.prototype" id="apidoc.module.jscs.require_curly_braces.prototype">module jscs.require_curly_braces.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_curly_braces.prototype.check" id="apidoc.element.jscs.require_curly_braces.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_curly_braces.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var typeIndex = this._typeIndex;
    var exceptions = this._exceptions;

    function isNotABlockStatement(node) {
        return node &#x26;&#x26; node.type !== &#x27;BlockStatement&#x27;;
    }

    function addError(typeString, entity) {
        errors.add(
            typeString + &#x27; statement without curly braces&#x27;,
            entity
        );
    }

    function checkBody(type, typeString) {
        file.iterateNodesByType(type, function(node) {
            if (isNotABlockStatement(node.body)) {
                addError(typeString, node);
            }
        });
    }

    if (typeIndex.if || typeIndex.else) {
        file.iterateNodesByType(&#x27;IfStatement&#x27;, function(node) {
            if (typeIndex.if &#x26;&#x26; isNotABlockStatement(node.consequent) &#x26;&#x26;
                // check exceptions for if and else
                !(exceptions &#x26;&#x26; exceptions.indexOf(node.consequent.type) !== -1)) {
                // console.log(node.firstChild.getSourceCode());
                addError(&#x27;If&#x27;, node.firstChild);
            }
            if (typeIndex.else &#x26;&#x26; isNotABlockStatement(node.alternate) &#x26;&#x26;
                node.alternate.type !== &#x27;IfStatement&#x27; &#x26;&#x26;
                // check exceptions for if and else
                !(exceptions &#x26;&#x26; exceptions.indexOf(node.consequent.type) !== -1)) {
                addError(&#x27;Else&#x27;, node.alternate.getPreviousCodeToken());
            }
        });
    }

    if (typeIndex.case || typeIndex.default) {
        file.iterateNodesByType(&#x27;SwitchCase&#x27;, function(node) {
            // empty case statement
            if (node.consequent.length === 0) {
                return;
            }

            if (node.consequent.length === 1 &#x26;&#x26; node.consequent[0].type === &#x27;BlockStatement&#x27;) {
                return;
            }

            if (node.test === null &#x26;&#x26; typeIndex.default) {
                addError(&#x27;Default&#x27;, node);
            }

            if (node.test !== null &#x26;&#x26; typeIndex.case) {
                addError(&#x27;Case&#x27;, node);
            }
        });
    }

    if (typeIndex.while) {
        checkBody(&#x27;WhileStatement&#x27;, &#x27;While&#x27;);
    }

    if (typeIndex.for) {
        checkBody(&#x27;ForStatement&#x27;, &#x27;For&#x27;);
        checkBody(&#x27;ForInStatement&#x27;, &#x27;For in&#x27;);
        checkBody(&#x27;ForOfStatement&#x27;, &#x27;For of&#x27;);
    }

    if (typeIndex.do) {
        checkBody(&#x27;DoWhileStatement&#x27;, &#x27;Do while&#x27;);
    }

    if (typeIndex.with) {
        checkBody(&#x27;WithStatement&#x27;, &#x27;With&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_curly_braces.prototype.configure" id="apidoc.element.jscs.require_curly_braces.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_curly_braces.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        Array.isArray(options) || options === true || typeof options === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option requires array, true value, or object&#x27;
    );

    var keywordMap = {
        &#x27;return&#x27;: &#x27;ReturnStatement&#x27;,
        &#x27;break&#x27;: &#x27;BreakStatement&#x27;,
        &#x27;continue&#x27;: &#x27;ContinueStatement&#x27;
    };

    if (options === true) {
        options = defaultKeywords;
    }

    if (!Array.isArray(options)) {
        assert(
            Array.isArray(options.allExcept),
            this.getOptionName() + &#x27;.allExcept &#x27; +
            &#x27;property requires an array value&#x27;
        );
        assert(
            Array.isArray(options.keywords) || options.keywords === true,
            this.getOptionName() + &#x27;.keywords &#x27; +
            &#x27;property requires an array value or a value of true&#x27;
        );

        if (options.keywords === true) {
            options.keywords = defaultKeywords;
        }

        this._exceptions = options.allExcept.map(function(statementType) {
            return keywordMap[statementType];
        });
        options = options.keywords;
    }

    this._typeIndex = {};
    for (var i = 0, l = options.length; i &#x3c; l; i++) {
        this._typeIndex[options[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_curly_braces.prototype.getOptionName" id="apidoc.element.jscs.require_curly_braces.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_curly_braces.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireCurlyBraces&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_dollar_before_jquery_assignment" id="apidoc.module.jscs.require_dollar_before_jquery_assignment">module jscs.require_dollar_before_jquery_assignment</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_dollar_before_jquery_assignment.require_dollar_before_jquery_assignment" id="apidoc.element.jscs.require_dollar_before_jquery_assignment.require_dollar_before_jquery_assignment">
        function <span class="apidocSignatureSpan">jscs.</span>require_dollar_before_jquery_assignment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_dollar_before_jquery_assignment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_dollar_before_jquery_assignment.prototype" id="apidoc.module.jscs.require_dollar_before_jquery_assignment.prototype">module jscs.require_dollar_before_jquery_assignment.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.check" id="apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_dollar_before_jquery_assignment.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var ignoreProperties = this._ignoreProperties;

    file.iterateNodesByType([&#x27;VariableDeclarator&#x27;, &#x27;AssignmentExpression&#x27;, &#x27;ObjectExpression&#x27;], function(node) {
        var type = node.type;
        var left;
        var varName;
        var right;

        function checkIfVarNameShouldStartWithDollar(varName, left, right) {

            if (/^_?\$/.test(varName)) {
                return;
            }

            if (!right || right.type !== &#x27;CallExpression&#x27;) {
                return;
            }

            var nextToken = right.callee.firstChild;
            if (nextToken.value !== &#x27;$&#x27;) {
                return;
            }

            nextToken = file.getNextToken(nextToken);
            if (nextToken.value !== &#x27;(&#x27;) {
                return;
            }

            while (!(nextToken.type === &#x27;Punctuator&#x27; &#x26;&#x26; nextToken.value === &#x27;)&#x27;)) {
                nextToken = file.getNextToken(nextToken);
            }

            nextToken = file.getNextToken(nextToken);
            if (!nextToken || !(nextToken.type === &#x27;Punctuator&#x27; &#x26;&#x26; nextToken.value === &#x27;.&#x27;)) {
                errors.add(
                    &#x27;jQuery identifiers must start with a $&#x27;,
                    left
                );
            }
        }

        if (type === &#x27;VariableDeclarator&#x27;) {
            if (node.id.type === &#x27;ObjectPattern&#x27; || node.id.type === &#x27;ArrayPattern&#x27;) {
                return;
            }

            left = node.id;
            varName = left.name;
            right = node.init;
            checkIfVarNameShouldStartWithDollar(varName, left, right);
        } else if (ignoreProperties) {
            return;

        } else if (type === &#x27;AssignmentExpression&#x27;) {
            left = node.left;
            if (left.computed || left.type === &#x27;ArrayPattern&#x27;) {
                return;
            }

            varName = left.name || left.property.name;
            right = node.right;
            checkIfVarNameShouldStartWithDollar(varName, left, right);
        } else {// type === &#x27;ObjectExpression&#x27;
            var props = node.properties;

            if (!props) {
                return;
            }

            props.forEach(function(prop) {
                left = prop.key;

                if (!left || !left.name) {
                    return;
                }

                varName = left.name;
                right = prop.value;
                checkIfVarNameShouldStartWithDollar(varName, left, right);
            });
        }

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.configure" id="apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_dollar_before_jquery_assignment.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || options === &#x27;ignoreProperties&#x27;,
        this.getOptionName() + &#x27; option requires true or &#x22;ignoreProperties&#x22; value, or should be removed&#x27;
    );

    this._ignoreProperties = (options === &#x27;ignoreProperties&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.getOptionName" id="apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_dollar_before_jquery_assignment.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireDollarBeforejQueryAssignment&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_dot_notation" id="apidoc.module.jscs.require_dot_notation">module jscs.require_dot_notation</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_dot_notation.require_dot_notation" id="apidoc.element.jscs.require_dot_notation.require_dot_notation">
        function <span class="apidocSignatureSpan">jscs.</span>require_dot_notation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_dot_notation = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_dot_notation.prototype" id="apidoc.module.jscs.require_dot_notation.prototype">module jscs.require_dot_notation.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_dot_notation.prototype.check" id="apidoc.element.jscs.require_dot_notation.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_dot_notation.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptSnakeCase = this._exceptSnakeCase;
    var exceptKeywords = this._exceptKeywords;

    var dialect = file.getDialect();
    file.iterateNodesByType(&#x27;MemberExpression&#x27;, function(node) {
        if (!node.computed || node.property.type !== &#x27;StringLiteral&#x27;) {
            return;
        }

        var value = node.property.value;
        if (// allow numbers, nulls, and anything else
            typeof value !== &#x27;string&#x27; ||
            // allow invalid identifiers
            !utils.isValidIdentifierName(value, file.getDialect()) ||
            // allow quoted snake cased identifiers if allExcept: [&#x27;snake_case&#x27;]
            (exceptSnakeCase &#x26;&#x26; utils.isSnakeCased(utils.trimUnderscores(value))) ||
            // allow quoted reserved words if allExcept: [&#x27;keywords&#x27;]
            ((dialect === &#x27;es3&#x27; || exceptKeywords) &#x26;&#x26; reservedWords.check(value, dialect, true))
        ) {
            return;
        }

        errors.add(&#x27;Use dot notation instead of brackets for member expressions&#x27;, node.property);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_dot_notation.prototype.configure" id="apidoc.element.jscs.require_dot_notation.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_dot_notation.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    if (typeof options !== &#x27;object&#x27;) {
        assert(
            options === true || options === &#x27;except_snake_case&#x27;,
            this.getOptionName() + &#x27; option requires either a true value or an object&#x27;
        );

        var _options = {};
        if (options === &#x27;except_snake_case&#x27;) {
            _options.allExcept = [&#x27;snake_case&#x27;];
        }

        return this.configure(_options);
    }

    assert(
        !options.allExcept || Array.isArray(options.allExcept),
        &#x27;allExcept value of &#x27; + this.getOptionName() + &#x27; option requires an array with exceptions&#x27;
    );

    if (Array.isArray(options.allExcept)) {
        this._exceptSnakeCase = options.allExcept.indexOf(&#x27;snake_case&#x27;) &#x3e; -1;
        this._exceptKeywords = options.allExcept.indexOf(&#x27;keywords&#x27;) &#x3e; -1;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_dot_notation.prototype.getOptionName" id="apidoc.element.jscs.require_dot_notation.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_dot_notation.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireDotNotation&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_early_return" id="apidoc.module.jscs.require_early_return">module jscs.require_early_return</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_early_return.require_early_return" id="apidoc.element.jscs.require_early_return.require_early_return">
        function <span class="apidocSignatureSpan">jscs.</span>require_early_return
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_early_return = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_early_return.prototype" id="apidoc.module.jscs.require_early_return.prototype">module jscs.require_early_return.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_early_return.prototype.check" id="apidoc.element.jscs.require_early_return.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_early_return.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    function addError(entity) {
        errors.add(
            &#x27;Use of else after return&#x27;,
            entity
        );
    }

    // Check if the IfStatement node contain a ReturnStatement.
    // If the node has a block, check all the statements in backward order to see if there is one.
    // This is to ensure that code like this will still return true:
    //
    // if (true) {
    //    return;
    //    eval();
    // }
    function hasNodeReturn(node) {
        if (node.type === &#x27;BlockStatement&#x27;) {
            for (var i = node.body.length - 1; i &#x3e;= 0; i--) {
                if (node.body[i].type === &#x27;ReturnStatement&#x27;) {
                    return true;
                }
            }
            return false;
        }
        return node.type === &#x27;ReturnStatement&#x27;;
    }

    file.iterateNodesByType(&#x27;IfStatement&#x27;, function(node) {
        if (!node.alternate) {
            return;
        }

        // Check if all the parents have a return statement, if not continue to the following IfStatement node.
        //
        // Example:
        //
        // if (foo) {
        //     return;
        // } else if (bar) {  &#x3c;-- error
        //     bar();
        // } else if (baz) {  &#x3c;-- safe
        //     return baz();
        // } else {           &#x3c;-- safe
        //     bas();
        // }
        for (var nodeIf = node; nodeIf &#x26;&#x26; nodeIf.type === &#x27;IfStatement&#x27;; nodeIf = nodeIf.parentElement) {
            if (nodeIf.alternate &#x26;&#x26; !hasNodeReturn(nodeIf.consequent)) {
                return;
            }
        }

        return addError(file.getPrevToken(file.getFirstNodeToken(node.alternate)));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_early_return.prototype.configure" id="apidoc.element.jscs.require_early_return.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_early_return.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option allow only the `true` value&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_early_return.prototype.getOptionName" id="apidoc.element.jscs.require_early_return.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_early_return.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireEarlyReturn&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_enhanced_object_literals" id="apidoc.module.jscs.require_enhanced_object_literals">module jscs.require_enhanced_object_literals</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_enhanced_object_literals.require_enhanced_object_literals" id="apidoc.element.jscs.require_enhanced_object_literals.require_enhanced_object_literals">
        function <span class="apidocSignatureSpan">jscs.</span>require_enhanced_object_literals
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_enhanced_object_literals = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_enhanced_object_literals.prototype" id="apidoc.module.jscs.require_enhanced_object_literals.prototype">module jscs.require_enhanced_object_literals.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_enhanced_object_literals.prototype._fix" id="apidoc.element.jscs.require_enhanced_object_literals.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.require_enhanced_object_literals.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var elem = error.element;

    // Can&#x27;t fix it yet
    if (elem.value.type === &#x27;FunctionExpression&#x27;) {
        return;
    }

    var element = parse(elem.key.name);
    element.remove();
    elem.parentElement.replaceChild(element, elem);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &#x26;&#x26; instance._fix) {
        // &#x22;error.fixed = true&#x22; should go first, so rule can
        // decide for itself (with &#x22;error.fixed = false&#x22;)
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_enhanced_object_literals.prototype.check" id="apidoc.element.jscs.require_enhanced_object_literals.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_enhanced_object_literals.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;ObjectProperty&#x27;, function(node) {
        // node.key.name is used when the property key is an unquoted identifier
        // node.key.value is used when the property key is a quoted string
        var propertyName = node.key.name || node.key.value;
        var valueName = node.value.name;
        var shorthand = node.shorthand;
        var computed = node.computed;

        // check for non-shorthand properties
        if (propertyName &#x26;&#x26; propertyName === valueName &#x26;&#x26; !(shorthand || computed)) {
            errors.add(
              &#x27;Property assignment should use enhanced object literal function.\n&#x27; +
              &#x27; `{ propName: propName }` is not allowed.&#x27;,
              node
            );
        }

        // check for non-method function properties
        var valueType = node.value.type;
        var valueIsMethod = node.method;
        if (valueType === &#x27;FunctionExpression&#x27; &#x26;&#x26; !valueIsMethod) {
            errors.add(
              &#x27;Property assignment should use enhanced object literal function.\n&#x27; +
              &#x27; `{ funcName: function() {} }` is not allowed.&#x27;,
              node
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_enhanced_object_literals.prototype.configure" id="apidoc.element.jscs.require_enhanced_object_literals.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_enhanced_object_literals.prototype.</span>configure
        <span class="apidocSignatureSpan">(option)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (option) {
    assert(option === true, this.getOptionName() + &#x27; requires a true value&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_enhanced_object_literals.prototype.getOptionName" id="apidoc.element.jscs.require_enhanced_object_literals.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_enhanced_object_literals.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireEnhancedObjectLiterals&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_function_declarations" id="apidoc.module.jscs.require_function_declarations">module jscs.require_function_declarations</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_function_declarations.require_function_declarations" id="apidoc.element.jscs.require_function_declarations.require_function_declarations">
        function <span class="apidocSignatureSpan">jscs.</span>require_function_declarations
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_function_declarations = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_function_declarations.prototype" id="apidoc.module.jscs.require_function_declarations.prototype">module jscs.require_function_declarations.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_function_declarations.prototype.check" id="apidoc.element.jscs.require_function_declarations.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_function_declarations.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(
        &#x27;VariableDeclarator&#x27;,
        function(node) {
            if (node.init &#x26;&#x26; node.init.type === &#x27;FunctionExpression&#x27;) {
                errors.add(&#x27;Use a function declaration instead&#x27;, node);
            }
        }
    );

    file.iterateNodesByType(
        &#x27;AssignmentExpression&#x27;,
        function(node) {
            if (node.left.type !== &#x27;MemberExpression&#x27; &#x26;&#x26;
                node.right.type === &#x27;FunctionExpression&#x27;) {
                errors.add(&#x27;Use a function declaration instead&#x27;, node);
            }
        }
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_function_declarations.prototype.configure" id="apidoc.element.jscs.require_function_declarations.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_function_declarations.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_function_declarations.prototype.getOptionName" id="apidoc.element.jscs.require_function_declarations.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_function_declarations.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireFunctionDeclarations&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_imports_alphabetized" id="apidoc.module.jscs.require_imports_alphabetized">module jscs.require_imports_alphabetized</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_imports_alphabetized.require_imports_alphabetized" id="apidoc.element.jscs.require_imports_alphabetized.require_imports_alphabetized">
        function <span class="apidocSignatureSpan">jscs.</span>require_imports_alphabetized
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_imports_alphabetized = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_imports_alphabetized.prototype" id="apidoc.module.jscs.require_imports_alphabetized.prototype">module jscs.require_imports_alphabetized.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_imports_alphabetized.prototype.check" id="apidoc.element.jscs.require_imports_alphabetized.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_imports_alphabetized.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {

    var previous;
    var current;

    var createSpecHash = function(specifier) {

        var imported = &#x27;&#x27;;
        var local = &#x27;&#x27;;

        if (specifier.imported &#x26;&#x26; specifier.imported.name) {
            imported = specifier.imported.name;
        }

        if (specifier.local &#x26;&#x26; specifier.local.name) {
            local = specifier.local.name;
        }

        return imported === local ? imported : imported + local;

    };

    file.iterateNodesByType(
        &#x27;ImportDeclaration&#x27;,
        function(node) {

            current = &#x27;&#x27;;

            for (var i = 0; i &#x3c; node.specifiers.length; i++) {
                current += createSpecHash(node.specifiers[i]);
            }

            if (node.source &#x26;&#x26; node.source.value) {
                current += node.source.value;
            }

            if (previous &#x26;&#x26; previous &#x3e; current) {
                errors.add(&#x27;imports must be alphabetized&#x27;, node);
            }

            previous = current;
        }
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_imports_alphabetized.prototype.configure" id="apidoc.element.jscs.require_imports_alphabetized.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_imports_alphabetized.prototype.</span>configure
        <span class="apidocSignatureSpan">(option)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (option) {
    assert(
        option === true,
        this.getOptionName() + &#x27; option requires true value&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_imports_alphabetized.prototype.getOptionName" id="apidoc.element.jscs.require_imports_alphabetized.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_imports_alphabetized.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireImportAlphabetized&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_keywords_on_new_line" id="apidoc.module.jscs.require_keywords_on_new_line">module jscs.require_keywords_on_new_line</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_keywords_on_new_line.require_keywords_on_new_line" id="apidoc.element.jscs.require_keywords_on_new_line.require_keywords_on_new_line">
        function <span class="apidocSignatureSpan">jscs.</span>require_keywords_on_new_line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_keywords_on_new_line = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_keywords_on_new_line.prototype" id="apidoc.module.jscs.require_keywords_on_new_line.prototype">module jscs.require_keywords_on_new_line.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_keywords_on_new_line.prototype.check" id="apidoc.element.jscs.require_keywords_on_new_line.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_keywords_on_new_line.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue(&#x27;Keyword&#x27;, this._keywords, function(token) {
        errors.assert.differentLine({
            token: token.getPreviousCodeToken(),
            nextToken: token
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_keywords_on_new_line.prototype.configure" id="apidoc.element.jscs.require_keywords_on_new_line.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_keywords_on_new_line.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(Array.isArray(keywords), this.getOptionName() + &#x27; option requires array value&#x27;);
    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_keywords_on_new_line.prototype.getOptionName" id="apidoc.element.jscs.require_keywords_on_new_line.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_keywords_on_new_line.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireKeywordsOnNewLine&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_line_break_after_variable_assignment" id="apidoc.module.jscs.require_line_break_after_variable_assignment">module jscs.require_line_break_after_variable_assignment</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_line_break_after_variable_assignment.require_line_break_after_variable_assignment" id="apidoc.element.jscs.require_line_break_after_variable_assignment.require_line_break_after_variable_assignment">
        function <span class="apidocSignatureSpan">jscs.</span>require_line_break_after_variable_assignment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_line_break_after_variable_assignment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_line_break_after_variable_assignment.prototype" id="apidoc.module.jscs.require_line_break_after_variable_assignment.prototype">module jscs.require_line_break_after_variable_assignment.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.check" id="apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_line_break_after_variable_assignment.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var lastDeclaration;
    file.iterateNodesByType(&#x27;VariableDeclaration&#x27;, function(node) {
        if (node.parentElement.type === &#x27;ForStatement&#x27; ||
            node.parentElement.type === &#x27;ForInStatement&#x27; ||
            node.parentElement.type === &#x27;ForOfStatement&#x27;) {
            return;
        }

        for (var i = 0; i &#x3c; node.declarations.length; i++) {
            var thisDeclaration = node.declarations[i];
            if (thisDeclaration.parentElement.kind === &#x27;var&#x27; ||
                thisDeclaration.parentElement.kind === &#x27;let&#x27; ||
                thisDeclaration.parentElement.kind === &#x27;const&#x27;) {
                if (lastDeclaration &#x26;&#x26; lastDeclaration.init) {
                    errors.assert.differentLine({
                        token: lastDeclaration,
                        nextToken: thisDeclaration,
                        message: &#x27;Variable assignments should be followed by new line&#x27;
                    });
                }
                lastDeclaration = thisDeclaration;
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.configure" id="apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_line_break_after_variable_assignment.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.getOptionName" id="apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_line_break_after_variable_assignment.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireLineBreakAfterVariableAssignment&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_line_feed_at_file_end" id="apidoc.module.jscs.require_line_feed_at_file_end">module jscs.require_line_feed_at_file_end</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_line_feed_at_file_end.require_line_feed_at_file_end" id="apidoc.element.jscs.require_line_feed_at_file_end.require_line_feed_at_file_end">
        function <span class="apidocSignatureSpan">jscs.</span>require_line_feed_at_file_end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_line_feed_at_file_end = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_line_feed_at_file_end.prototype" id="apidoc.module.jscs.require_line_feed_at_file_end.prototype">module jscs.require_line_feed_at_file_end.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_line_feed_at_file_end.prototype.check" id="apidoc.element.jscs.require_line_feed_at_file_end.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_line_feed_at_file_end.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var lastToken = file.getLastToken({includeComments: true});
    var prevToken = file.getPrevToken(lastToken, {includeComments: true});
    errors.assert.differentLine({
        token: prevToken,
        nextToken: lastToken,
        message: &#x27;Missing line feed at file end&#x27;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_line_feed_at_file_end.prototype.configure" id="apidoc.element.jscs.require_line_feed_at_file_end.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_line_feed_at_file_end.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_line_feed_at_file_end.prototype.getOptionName" id="apidoc.element.jscs.require_line_feed_at_file_end.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_line_feed_at_file_end.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireLineFeedAtFileEnd&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_matching_function_name" id="apidoc.module.jscs.require_matching_function_name">module jscs.require_matching_function_name</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_matching_function_name.require_matching_function_name" id="apidoc.element.jscs.require_matching_function_name.require_matching_function_name">
        function <span class="apidocSignatureSpan">jscs.</span>require_matching_function_name
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_matching_function_name = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_matching_function_name.prototype" id="apidoc.module.jscs.require_matching_function_name.prototype">module jscs.require_matching_function_name.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_matching_function_name.prototype.check" id="apidoc.element.jscs.require_matching_function_name.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_matching_function_name.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var _includeModuleExports = this._includeModuleExports;
    file.iterateNodesByType([&#x27;FunctionExpression&#x27;], function(node) {
        switch (node.parentElement.type) {
            // var foo = function bar() {}
            // object.foo = function bar() {}
            // object[&#x27;foo&#x27;] = function bar() {}
            case &#x27;AssignmentExpression&#x27;:
                if (_includeModuleExports || !_isModuleExports(node.parentElement.left)) {
                    checkForMember(node.parentElement, skip, errors);
                }
                break;

            // object = {foo: function bar() {}}
            case &#x27;ObjectProperty&#x27;:
                checkForProperty(node.parentElement, skip, errors);
                break;
        }
    });

    function skip(key, value) {
        // We don&#x27;t care about anonymous functions as
        // those should be enforced by separate rule
        if (!value.id) {
            return true;
        }

        // Relax a bit when reserved word is detected
        if (reservedWords.check(key, file.getDialect(), true)) {
            return true;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_matching_function_name.prototype.configure" id="apidoc.element.jscs.require_matching_function_name.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_matching_function_name.prototype.</span>configure
        <span class="apidocSignatureSpan">(requireMatchingFunctionName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (requireMatchingFunctionName) {
    if (typeof requireMatchingFunctionName === &#x27;object&#x27;) {
        assert(requireMatchingFunctionName.includeModuleExports === true,
            &#x27;requireMatchingFunctionName option requires includeModuleExports property to be true for object&#x27;);
        this._includeModuleExports = requireMatchingFunctionName.includeModuleExports;
    } else {
        assert(
            requireMatchingFunctionName === true,
            &#x27;requireMatchingFunctionName option requires true value or should be removed&#x27;
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_matching_function_name.prototype.getOptionName" id="apidoc.element.jscs.require_matching_function_name.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_matching_function_name.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireMatchingFunctionName&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_multi_line_ternary" id="apidoc.module.jscs.require_multi_line_ternary">module jscs.require_multi_line_ternary</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_multi_line_ternary.require_multi_line_ternary" id="apidoc.element.jscs.require_multi_line_ternary.require_multi_line_ternary">
        function <span class="apidocSignatureSpan">jscs.</span>require_multi_line_ternary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_multi_line_ternary = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_multi_line_ternary.prototype" id="apidoc.module.jscs.require_multi_line_ternary.prototype">module jscs.require_multi_line_ternary.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_multi_line_ternary.prototype.check" id="apidoc.element.jscs.require_multi_line_ternary.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_multi_line_ternary.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;ConditionalExpression&#x27;, function(node) {

        errors.assert.differentLine({
            token: node.test,
            nextToken: node.consequent,
            message: &#x27;Missing new line after test&#x27;
        });

        errors.assert.differentLine({
            token: node.consequent,
            nextToken: node.alternate,
            message: &#x27;Missing new line after consequent&#x27;
        });

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_multi_line_ternary.prototype.configure" id="apidoc.element.jscs.require_multi_line_ternary.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_multi_line_ternary.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_multi_line_ternary.prototype.getOptionName" id="apidoc.element.jscs.require_multi_line_ternary.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_multi_line_ternary.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireMultiLineTernary&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_multiple_var_decl" id="apidoc.module.jscs.require_multiple_var_decl">module jscs.require_multiple_var_decl</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_multiple_var_decl.require_multiple_var_decl" id="apidoc.element.jscs.require_multiple_var_decl.require_multiple_var_decl">
        function <span class="apidocSignatureSpan">jscs.</span>require_multiple_var_decl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_multiple_var_decl = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_multiple_var_decl.prototype" id="apidoc.module.jscs.require_multiple_var_decl.prototype">module jscs.require_multiple_var_decl.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_multiple_var_decl.prototype.check" id="apidoc.element.jscs.require_multiple_var_decl.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_multiple_var_decl.prototype.</span>check
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function () {
    return this._check.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_multiple_var_decl.prototype.configure" id="apidoc.element.jscs.require_multiple_var_decl.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_multiple_var_decl.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var isExceptRequire = typeof options === &#x27;object&#x27; &#x26;&#x26;
                          options.allExcept.length &#x26;&#x26;
                          options.allExcept.indexOf(&#x27;require&#x27;) !== -1;

    assert(
        options === true ||
        options === &#x27;onevar&#x27; ||
        isExceptRequire,
        this.getOptionName() + &#x27; option requires a true value, `onevar` or {allExcept: [\&#x27;require\&#x27;]}&#x27;
    );

    var checkers = {
        &#x27;true&#x27;: consecutive,
        onevar: onevar
    };

    this._isExceptRequire = isExceptRequire;
    this._check = isExceptRequire ? consecutive : checkers[options];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_multiple_var_decl.prototype.getOptionName" id="apidoc.element.jscs.require_multiple_var_decl.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_multiple_var_decl.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireMultipleVarDecl&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_named_unassigned_functions" id="apidoc.module.jscs.require_named_unassigned_functions">module jscs.require_named_unassigned_functions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_named_unassigned_functions.require_named_unassigned_functions" id="apidoc.element.jscs.require_named_unassigned_functions.require_named_unassigned_functions">
        function <span class="apidocSignatureSpan">jscs.</span>require_named_unassigned_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_named_unassigned_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_named_unassigned_functions.prototype" id="apidoc.module.jscs.require_named_unassigned_functions.prototype">module jscs.require_named_unassigned_functions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_named_unassigned_functions.prototype.check" id="apidoc.element.jscs.require_named_unassigned_functions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_named_unassigned_functions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var _this = this;
    file.iterateNodesByType(&#x27;FunctionExpression&#x27;, function(node) {
        var parentElement = node.parentElement;
        // If the function has been named via left hand assignment, skip it
        //   e.g. `var hello = function() {`, `foo.bar = function() {`
        if (parentElement.type.match(/VariableDeclarator|Property|AssignmentExpression/)) {
            return;
        }

        // If the function has been named, skip it
        //   e.g. `[].forEach(function hello() {`
        if (node.id !== null) {
            return;
        }

        // If we have exceptions and the function is being invoked, detect whether we excepted it
        if (_this._allExceptItems &#x26;&#x26; parentElement.type === &#x27;CallExpression&#x27;) {
            // Determine the path that resolves to our call expression
            // We must cover both direct calls (e.g. `it(function() {`) and
            //   member expressions (e.g. `foo.bar(function() {`)
            var memberNode = parentElement.callee;
            var canBeRepresented = true;
            var fullpathParts = [];
            while (memberNode) {
                if (memberNode.type.match(/Identifier|Literal/)) {
                    fullpathParts.unshift(getNodeName(memberNode));
                } else if (memberNode.type === &#x27;MemberExpression&#x27;) {
                    fullpathParts.unshift(getNodeName(memberNode.property));
                } else {
                    canBeRepresented = false;
                    break;
                }
                memberNode = memberNode.object;
            }

            // If the path is not-dynamic (i.e. can be represented by static parts),
            //   then check it against our exceptions
            if (canBeRepresented) {
                var fullpath = JSON.stringify(fullpathParts);
                for (var i = 0, l = _this._allExceptItems.length; i &#x3c; l; i++) {
                    if (fullpath === _this._allExceptItems[i]) {
                        return;
                    }
                }
            }
        }

        // Complain that this function must be named
        errors.add(&#x27;Inline functions need to be named&#x27;, node);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_named_unassigned_functions.prototype.configure" id="apidoc.element.jscs.require_named_unassigned_functions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_named_unassigned_functions.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true ||
        typeof options === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option requires true value &#x27; +
        &#x27;or an object with String[] `allExcept` property&#x27;
    );

    // verify first item in `allExcept` property in object (if it&#x27;s an object)
    assert(
        typeof options !== &#x27;object&#x27; ||
        Array.isArray(options.allExcept) &#x26;&#x26;
        typeof options.allExcept[0] === &#x27;string&#x27;,
        &#x27;Property `allExcept` in &#x27; + this.getOptionName() + &#x27; should be an array of strings&#x27;
    );

    if (options.allExcept) {
        this._allExceptItems = options.allExcept.map(function(item) {
            var parts = pathval.parse(item).map(function extractPart(part) {
                return part.i !== undefined ? part.i : part.p;
            });
            return JSON.stringify(parts);
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_named_unassigned_functions.prototype.getOptionName" id="apidoc.element.jscs.require_named_unassigned_functions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_named_unassigned_functions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireNamedUnassignedFunctions&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_newline_before_block_statements" id="apidoc.module.jscs.require_newline_before_block_statements">module jscs.require_newline_before_block_statements</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_block_statements.require_newline_before_block_statements" id="apidoc.element.jscs.require_newline_before_block_statements.require_newline_before_block_statements">
        function <span class="apidocSignatureSpan">jscs.</span>require_newline_before_block_statements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_newline_before_block_statements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_newline_before_block_statements.prototype" id="apidoc.module.jscs.require_newline_before_block_statements.prototype">module jscs.require_newline_before_block_statements.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_block_statements.prototype.check" id="apidoc.element.jscs.require_newline_before_block_statements.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_newline_before_block_statements.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var setting = this._setting;

    function assertDifferentLine(token, nextToken) {
        errors.assert.differentLine({
            token: token,
            nextToken: nextToken,
            message: &#x27;Newline before curly brace for block statement is required&#x27;
        });
    }

    file.iterateNodesByType(&#x27;BlockStatement&#x27;, function(node) {
        if (setting === true || setting.indexOf(getBlockType(node)) !== -1) {
            var openingBrace = node.getFirstToken();
            var prevToken = openingBrace.getPreviousCodeToken();

            assertDifferentLine(prevToken, openingBrace);
        }
    });
    if (setting === true || setting.indexOf(&#x27;switch&#x27;) !== -1) {
        file.iterateNodesByType([&#x27;SwitchStatement&#x27;], function(node) {
            var openingBrace = file.findNextToken(file.getLastNodeToken(node.discriminant), &#x27;Punctuator&#x27;, &#x27;{&#x27;);
            var prevToken = file.getPrevToken(openingBrace);

            assertDifferentLine(prevToken, openingBrace);
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_block_statements.prototype.configure" id="apidoc.element.jscs.require_newline_before_block_statements.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_newline_before_block_statements.prototype.</span>configure
        <span class="apidocSignatureSpan">(settingValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (settingValue) {
    assert(
        Array.isArray(settingValue) &#x26;&#x26; settingValue.length || settingValue === true,
        &#x27;requireNewlineBeforeBlockStatements option requires non-empty array value or true value&#x27;
    );

    this._setting = settingValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_block_statements.prototype.getOptionName" id="apidoc.element.jscs.require_newline_before_block_statements.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_newline_before_block_statements.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireNewlineBeforeBlockStatements&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_newline_before_single_statements_in_if" id="apidoc.module.jscs.require_newline_before_single_statements_in_if">module jscs.require_newline_before_single_statements_in_if</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_single_statements_in_if.require_newline_before_single_statements_in_if" id="apidoc.element.jscs.require_newline_before_single_statements_in_if.require_newline_before_single_statements_in_if">
        function <span class="apidocSignatureSpan">jscs.</span>require_newline_before_single_statements_in_if
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_newline_before_single_statements_in_if = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_newline_before_single_statements_in_if.prototype" id="apidoc.module.jscs.require_newline_before_single_statements_in_if.prototype">module jscs.require_newline_before_single_statements_in_if.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.check" id="apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_newline_before_single_statements_in_if.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    function assertDifferentLine(token, nextToken) {
        errors.assert.differentLine({
            token: token,
            nextToken: nextToken,
            message: &#x27;Newline before single statement in if is required&#x27;
        });
    }

    // Recursively locate a token based on it&#x27;s type.
    function getToken(entity, tokenType, tokenProperty) {
        if (entity.type === tokenType || !entity[tokenProperty]) {
            return entity;
        } else {
            return getToken(entity[tokenProperty], tokenType, tokenProperty);
        }
    }

    file.iterateNodesByType(&#x27;IfStatement&#x27;, function(node) {
        var consequentNode = getFirstStatement(node.consequent);
        var alternateNode = getFirstStatement(node.alternate);

        if (consequentNode) {
            assertDifferentLine(
                getToken(consequentNode, &#x27;Keyword&#x27;, &#x27;previousSibling&#x27;),
                consequentNode
            );
        }

        if (alternateNode &#x26;&#x26; alternateNode.type !== &#x27;IfStatement&#x27; &#x26;&#x26; alternateNode.type !== &#x27;BlockStatement&#x27;) {
            assertDifferentLine(
                getToken(alternateNode, &#x27;Keyword&#x27;, &#x27;previousSibling&#x27;),
                alternateNode
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.configure" id="apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_newline_before_single_statements_in_if.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    assert(
        value === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.getOptionName" id="apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_newline_before_single_statements_in_if.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireNewlineBeforeSingleStatementsInIf&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_numeric_literals" id="apidoc.module.jscs.require_numeric_literals">module jscs.require_numeric_literals</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_numeric_literals.require_numeric_literals" id="apidoc.element.jscs.require_numeric_literals.require_numeric_literals">
        function <span class="apidocSignatureSpan">jscs.</span>require_numeric_literals
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_numeric_literals = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_numeric_literals.prototype" id="apidoc.module.jscs.require_numeric_literals.prototype">module jscs.require_numeric_literals.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_numeric_literals.prototype.check" id="apidoc.element.jscs.require_numeric_literals.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_numeric_literals.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var radixMap = this._radixMap;
    file.iterateNodesByType([&#x27;CallExpression&#x27;], function(node) {
        // don&#x27;t check for parseInt(1)
        if (node.arguments.length !== 2) {
            return;
        }

        // only error if the radix is 2, 8, or 16
        var radixName = radixMap[node.arguments[1].value];

        if (node.callee.type === &#x27;Identifier&#x27; &#x26;&#x26;
            node.callee.name === &#x27;parseInt&#x27; &#x26;&#x26;
            radixName &#x26;&#x26;
            node.arguments[0].type.indexOf(&#x27;Literal&#x27;) &#x3e; -1
        ) {
            errors.add(&#x27;Use &#x27; + radixName + &#x27; literals instead of parseInt&#x27;, node);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_numeric_literals.prototype.configure" id="apidoc.element.jscs.require_numeric_literals.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_numeric_literals.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );

    this._radixMap = {
        2: &#x27;binary&#x27;,
        8: &#x27;octal&#x27;,
        16: &#x27;hexadecimal&#x27;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_numeric_literals.prototype.getOptionName" id="apidoc.element.jscs.require_numeric_literals.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_numeric_literals.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireNumericLiterals&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_object_destructuring" id="apidoc.module.jscs.require_object_destructuring">module jscs.require_object_destructuring</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_object_destructuring.require_object_destructuring" id="apidoc.element.jscs.require_object_destructuring.require_object_destructuring">
        function <span class="apidocSignatureSpan">jscs.</span>require_object_destructuring
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_object_destructuring = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_object_destructuring.prototype" id="apidoc.module.jscs.require_object_destructuring.prototype">module jscs.require_object_destructuring.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_object_destructuring.prototype.check" id="apidoc.element.jscs.require_object_destructuring.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_object_destructuring.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var propertyExceptions = this._propertyExceptions;

    file.iterateNodesByType(&#x27;VariableDeclaration&#x27;, function(node) {

        node.declarations.forEach(function(declaration) {
            var declarationId = declaration.id || {};
            var declarationInit = declaration.init || {};

            if (declarationId.type !== &#x27;Identifier&#x27; || declarationInit.type !== &#x27;MemberExpression&#x27;) {
                return;
            }

            var propertyName = declarationInit.property &#x26;&#x26; declarationInit.property.name;

            if (declarationId.name === propertyName &#x26;&#x26;
                propertyExceptions.indexOf(propertyName) &#x3c; 0) {

                errors.add(&#x27;Property assignments should use destructuring&#x27;, node);
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_object_destructuring.prototype.configure" id="apidoc.element.jscs.require_object_destructuring.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_object_destructuring.prototype.</span>configure
        <span class="apidocSignatureSpan">(option)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (option) {
    var isTrue = option === true;

    assert(
        isTrue || (typeof option === &#x27;object&#x27; &#x26;&#x26; Array.isArray(option.allExcept)),
        this.getOptionName() + &#x27; requires the value `true` &#x27; +
          &#x27;or an object with an `allExcept` array property&#x27;
    );

    this._propertyExceptions = !isTrue &#x26;&#x26; option.allExcept || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_object_destructuring.prototype.getOptionName" id="apidoc.element.jscs.require_object_destructuring.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_object_destructuring.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireObjectDestructuring&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_object_keys_on_new_line" id="apidoc.module.jscs.require_object_keys_on_new_line">module jscs.require_object_keys_on_new_line</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_object_keys_on_new_line.require_object_keys_on_new_line" id="apidoc.element.jscs.require_object_keys_on_new_line.require_object_keys_on_new_line">
        function <span class="apidocSignatureSpan">jscs.</span>require_object_keys_on_new_line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_object_keys_on_new_line = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_object_keys_on_new_line.prototype" id="apidoc.module.jscs.require_object_keys_on_new_line.prototype">module jscs.require_object_keys_on_new_line.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_object_keys_on_new_line.prototype.check" id="apidoc.element.jscs.require_object_keys_on_new_line.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_object_keys_on_new_line.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var message = &#x27;Object keys must go on a new line&#x27;;
    var isSameLine = this._isSameLine;

    if (isSameLine) {
        message = &#x27;Object keys must go on a new line if they aren\&#x27;t all on the same line&#x27;;
    }

    file.iterateNodesByType(&#x27;ObjectExpression&#x27;, function(node) {
        var firstKeyToken;
        var lastValueToken;
        var lastProp;

        if (isSameLine) {
            if (node.properties.length &#x3e; 1) {
                firstKeyToken = file.getFirstNodeToken(node.properties[0].key);
                lastProp = node.properties[node.properties.length - 1];
                lastValueToken = file.getLastNodeToken(lastProp.value || lastProp.key);

                if (firstKeyToken.getLoc().end.line === lastValueToken.getLoc().start.line) {
                    // It&#x27;s ok, all keys and values are on the same line.
                    return;
                }
            }
        }

        for (var i = 1; i &#x3c; node.properties.length; i++) {
            var prop = node.properties[i - 1];
            lastValueToken = file.getLastNodeToken(prop.value || prop.body);
            var comma = file.findNextToken(lastValueToken, &#x27;Punctuator&#x27;, &#x27;,&#x27;);

            firstKeyToken = file.getFirstNodeToken(node.properties[i].key);

            errors.assert.differentLine({
                token: comma,
                nextToken: firstKeyToken,
                message: message
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_object_keys_on_new_line.prototype.configure" id="apidoc.element.jscs.require_object_keys_on_new_line.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_object_keys_on_new_line.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || Array.isArray(options.allExcept),
        this.getOptionName() + &#x27; option requires a true value or an object of exceptions&#x27;
    );

    this._isSameLine = false;
    if (Array.isArray(options.allExcept)) {
        this._isSameLine = options.allExcept[0] === &#x27;sameLine&#x27;;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_object_keys_on_new_line.prototype.getOptionName" id="apidoc.element.jscs.require_object_keys_on_new_line.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_object_keys_on_new_line.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireObjectKeysOnNewLine&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_operator_before_line_break" id="apidoc.module.jscs.require_operator_before_line_break">module jscs.require_operator_before_line_break</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_operator_before_line_break.require_operator_before_line_break" id="apidoc.element.jscs.require_operator_before_line_break.require_operator_before_line_break">
        function <span class="apidocSignatureSpan">jscs.</span>require_operator_before_line_break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_operator_before_line_break = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_operator_before_line_break.prototype" id="apidoc.module.jscs.require_operator_before_line_break.prototype">module jscs.require_operator_before_line_break.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_operator_before_line_break.prototype.check" id="apidoc.element.jscs.require_operator_before_line_break.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_operator_before_line_break.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operators = this._operatorIndex;
    var throughTokens = [&#x27;?&#x27;, &#x27;,&#x27;];

    function errorIfApplicable(operatorToken) {
        errors.assert.sameLine({
            token: file.getPrevToken(operatorToken),
            nextToken: operatorToken,
            message: &#x27;Operator &#x27; + operatorToken.value + &#x27; should not be on a new line&#x27;,
            stickToPreviousToken: true
        });
    }

    throughTokens = throughTokens.filter(function(operator) {
        return operators[operator];
    });

    if (throughTokens.length) {
        file.iterateTokensByType(&#x27;Punctuator&#x27;, function(token) {
            var operator = token.value;

            if (throughTokens.every(function() {
                return throughTokens.indexOf(operator) &#x3e;= 0;
            })) {
                errorIfApplicable(token);
            }
        });
    }

    file.iterateNodesByType(
        [&#x27;BinaryExpression&#x27;, &#x27;AssignmentExpression&#x27;, &#x27;LogicalExpression&#x27;],
        function(node) {
            var operator = node.operator;

            if (!operators[operator]) {
                return;
            }

            var nextToken = file.getFirstNodeToken(node.argument || node.right);
            var token = file.findPrevOperatorToken(nextToken, operator);

            errorIfApplicable(token);
        }
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_operator_before_line_break.prototype.configure" id="apidoc.element.jscs.require_operator_before_line_break.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_operator_before_line_break.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + &#x27; option requires array value or true value&#x27;
    );

    if (isTrue) {
        operators = defaultOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &#x3c; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_operator_before_line_break.prototype.getOptionName" id="apidoc.element.jscs.require_operator_before_line_break.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_operator_before_line_break.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireOperatorBeforeLineBreak&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newline_after_variable_declaration" id="apidoc.module.jscs.require_padding_newline_after_variable_declaration">module jscs.require_padding_newline_after_variable_declaration</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration.require_padding_newline_after_variable_declaration" id="apidoc.element.jscs.require_padding_newline_after_variable_declaration.require_padding_newline_after_variable_declaration">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newline_after_variable_declaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newline_after_variable_declaration = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newline_after_variable_declaration.prototype" id="apidoc.module.jscs.require_padding_newline_after_variable_declaration.prototype">module jscs.require_padding_newline_after_variable_declaration.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.check" id="apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_padding_newline_after_variable_declaration.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;VariableDeclaration&#x27;, function(node) {
        if (node.parentElement.type === &#x27;ForStatement&#x27; ||
            node.parentElement.type === &#x27;ForInStatement&#x27; ||
            node.parentElement.type === &#x27;ForOfStatement&#x27;) {
            return;
        }

        var endOfDeclaration = file.getLastNodeToken(node);
        var nextToken = file.getNextToken(endOfDeclaration);

        // check export declaration
        if (nextToken.value === &#x27;export&#x27;) {
            nextToken = file.getNextToken(nextToken);
        }

        if (nextToken.value in {&#x27;var&#x27;: true, &#x27;let&#x27;: true, &#x27;const&#x27;: true}) {
            return;
        }

        if (nextToken.value === &#x27;}&#x27;) {
            return;
        }

        if (nextToken.type === &#x27;EOF&#x27;) {
            return;
        }

        errors.assert.linesBetween({
            atLeast: 2,
            token: endOfDeclaration,
            nextToken: nextToken
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.configure" id="apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_padding_newline_after_variable_declaration.prototype.</span>configure
        <span class="apidocSignatureSpan">(requirePaddingNewLineAfterVariableDeclaration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (requirePaddingNewLineAfterVariableDeclaration) {
    assert(
        requirePaddingNewLineAfterVariableDeclaration === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.getOptionName" id="apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_padding_newline_after_variable_declaration.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requirePaddingNewLineAfterVariableDeclaration&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_after_blocks" id="apidoc.module.jscs.require_padding_newlines_after_blocks">module jscs.require_padding_newlines_after_blocks</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_blocks.require_padding_newlines_after_blocks" id="apidoc.element.jscs.require_padding_newlines_after_blocks.require_padding_newlines_after_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_after_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_after_blocks.prototype" id="apidoc.module.jscs.require_padding_newlines_after_blocks.prototype">module jscs.require_padding_newlines_after_blocks.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.check" id="apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_blocks.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    function isException(node, parent, exceptions) {
        var grandpa = parent.parentElement;

        // Check if this block is used in call or array expression
        if (grandpa &#x26;&#x26; exceptions[grandpa.type]) {
            return true;
        }

        var first = node.getFirstToken();
        var last = node.getLastToken();

        if (exceptions.SingleLine &#x26;&#x26; file.isOnTheSameLine(first, last)) {
            return true;
        }

        return false;
    }

    file.iterateNodesByType(&#x27;BlockStatement&#x27;, (function(node) {

        var endToken = file.getLastNodeToken(node);
        var parentElement = node.parentElement;
        var tokens = {
            next: endToken.getNextCodeToken(),
            token: endToken
        };

        if (isException(node, parentElement, this.exceptions)) {
            return;
        }

        while (tokens.next.type !== &#x27;EOF&#x27;) {
            var excludeValues = excludes[parentElement.type];
            if (excludeValues &#x26;&#x26; excludeValues.indexOf(tokens.next.value) !== -1) {
                return;
            }

            if (file.isOnTheSameLine(tokens.token, tokens.next)) {
                endToken = tokens.next;
                tokens.next = tokens.next.getNextCodeToken();
                continue;
            }

            if (tokens.next.type === &#x27;Punctuator&#x27; &#x26;&#x26; (
                tokens.next.value === &#x27;}&#x27; ||
                tokens.next.value === &#x27;]&#x27; ||
                tokens.next.value === &#x27;&#x3e;&#x27; ||
                tokens.next.value === &#x27;)&#x27;)
            ) {
                return;
            }

            errors.assert.linesBetween({
                token: tokens.token,
                nextToken: tokens.next,
                atLeast: 2,
                message: &#x27;Missing newline after block&#x27;
            });

            return;
        }
    }).bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.configure" id="apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_blocks.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    this.exceptions = {
        &#x27;CallExpression&#x27;: false,
        &#x27;NewExpression&#x27;: false,
        &#x27;ArrayExpression&#x27;: false,
        &#x27;ObjectProperty&#x27;: false,
        &#x27;SingleLine&#x27;: false
    };

    var optionName = this.getOptionName();

    if (typeof value === &#x27;object&#x27;) {
        assert(Array.isArray(value.allExcept), optionName + &#x27; option requires &#x22;allExcept&#x22; &#x27; +
            &#x27;to be an array&#x27;);
        assert(value.allExcept.length &#x3e; 0, optionName + &#x27; option requires &#x22;allExcept&#x22; &#x27; +
            &#x27;to have at least one item or be set to `true`&#x27;);

        value.allExcept.forEach(function(except) {
            if (except === &#x27;inCallExpressions&#x27;) {
                this.exceptions.CallExpression = true;
            } else if (except === &#x27;inNewExpressions&#x27;) {
                this.exceptions.NewExpression = true;
            } else if (except === &#x27;inArrayExpressions&#x27;) {
                this.exceptions.ArrayExpression = true;
            } else if (except === &#x27;inProperties&#x27;) {
                this.exceptions.ObjectProperty = true;
            } else if (except === &#x27;singleLine&#x27;) {
                this.exceptions.SingleLine = true;
            } else {
                assert(false, optionName + &#x27; option requires &#x22;allExcept&#x22; to only have &#x27; +
                    &#x27;one of &#x22;inCallExpressions&#x22;, &#x22;inNewExpressions&#x22;,&#x27; +
                    &#x27;&#x22;inArrayExpressions&#x22;, &#x22;inProperties&#x22; or &#x22;singleLine&#x22;&#x27;);
            }
        }, this);
    } else {
        assert(value === true,
            optionName + &#x27; option requires true value or object&#x27;
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.getOptionName" id="apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_blocks.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requirePaddingNewLinesAfterBlocks&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_after_use_strict" id="apidoc.module.jscs.require_padding_newlines_after_use_strict">module jscs.require_padding_newlines_after_use_strict</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_use_strict.require_padding_newlines_after_use_strict" id="apidoc.element.jscs.require_padding_newlines_after_use_strict.require_padding_newlines_after_use_strict">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_use_strict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_after_use_strict = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_after_use_strict.prototype" id="apidoc.module.jscs.require_padding_newlines_after_use_strict.prototype">module jscs.require_padding_newlines_after_use_strict.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.check" id="apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_use_strict.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptRequire = this._exceptRequire;
    file.iterateNodesByType(&#x27;Directive&#x27;, function(node) {
        var literal = node.value;

        if (literal.value !== &#x27;use strict&#x27;) {
            return;
        }

        var endOfNode = file.getLastNodeToken(node);
        if (exceptRequire) {
            var requireToken = file.findNextToken(endOfNode, &#x27;Identifier&#x27;, &#x27;require&#x27;);
            if (requireToken &#x26;&#x26; node.getLoc().start.line + 1 === requireToken.getLoc().start.line) {

                // Ensure the detected require is the first declaration of this line
                var keywordToken = file.getNextToken(endOfNode, {
                    includeComments: true
                });
                var identifierToken = file.getNextToken(file.getLastNodeToken(keywordToken), {
                    includeComments: true
                });
                var punctuatorToken = file.getNextToken(file.getLastNodeToken(identifierToken), {
                    includeComments: true
                });
                requireToken = file.getNextToken(file.getLastNodeToken(punctuatorToken), {
                    includeComments: true
                });

                if (
                    keywordToken.type === &#x27;Keyword&#x27; &#x26;&#x26;
                    identifierToken.type === &#x27;Identifier&#x27; &#x26;&#x26;
                    punctuatorToken.type === &#x27;Punctuator&#x27; &#x26;&#x26;
                    requireToken.type === &#x27;Identifier&#x27; &#x26;&#x26;
                    requireToken.value === &#x27;require&#x27;
                ) {
                    return;
                }
            }
        }

        var nextToken = file.getNextToken(endOfNode, {
            includeComments: true
        });

        errors.assert.linesBetween({
            atLeast: 2,
            token: endOfNode,
            nextToken: nextToken
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.configure" id="apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_use_strict.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    if (typeof options !== &#x27;object&#x27;) {
        assert(
            options === true,
            this.getOptionName() + &#x27; option requires either a true value or an object&#x27;
        );

        var _options = {allExcept: []};
        return this.configure(_options);
    }

    if (Array.isArray(options.allExcept)) {
        this._exceptRequire = options.allExcept.indexOf(&#x27;require&#x27;) &#x3e; -1;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.getOptionName" id="apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_use_strict.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requirePaddingNewLinesAfterUseStrict&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_before_export" id="apidoc.module.jscs.require_padding_newlines_before_export">module jscs.require_padding_newlines_before_export</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_export.require_padding_newlines_before_export" id="apidoc.element.jscs.require_padding_newlines_before_export.require_padding_newlines_before_export">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_export
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_before_export = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_before_export.prototype" id="apidoc.module.jscs.require_padding_newlines_before_export.prototype">module jscs.require_padding_newlines_before_export.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_export.prototype.check" id="apidoc.element.jscs.require_padding_newlines_before_export.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_export.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;AssignmentExpression&#x27;, function(node) {
        var left = node.left;
        var greatGrandpa = node.parentElement.parentElement;
        if (!(
            left.object &#x26;&#x26;
            left.object.name === &#x27;module&#x27; &#x26;&#x26;
            left.property &#x26;&#x26;
            left.property.name === &#x27;exports&#x27;)) {
            return;
        }

        // module.exports is in a block and is the only statement.
        if (greatGrandpa.type === &#x27;BlockStatement&#x27; &#x26;&#x26; greatGrandpa.body.length === 1) {
            return;
        }

        var firstToken = node.getFirstToken();
        var prevToken = file.getPrevToken(firstToken);

        errors.assert.linesBetween({
            atLeast: 2,
            token: prevToken,
            nextToken: firstToken,
            message: &#x27;Missing newline before export&#x27;
        });
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_export.prototype.configure" id="apidoc.element.jscs.require_padding_newlines_before_export.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_export.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    assert(
        value === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_export.prototype.getOptionName" id="apidoc.element.jscs.require_padding_newlines_before_export.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_export.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requirePaddingNewLinesBeforeExport&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_before_keywords" id="apidoc.module.jscs.require_padding_newlines_before_keywords">module jscs.require_padding_newlines_before_keywords</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_keywords.require_padding_newlines_before_keywords" id="apidoc.element.jscs.require_padding_newlines_before_keywords.require_padding_newlines_before_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_before_keywords = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_before_keywords.prototype" id="apidoc.module.jscs.require_padding_newlines_before_keywords.prototype">module jscs.require_padding_newlines_before_keywords.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.check" id="apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_keywords.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var excludedTokens = [&#x27;:&#x27;, &#x27;,&#x27;, &#x27;(&#x27;, &#x27;=&#x27;];
    var specialCases = { &#x27;if&#x27;: &#x27;else&#x27; };
    file.iterateTokensByTypeAndValue(&#x27;Keyword&#x27;, this._keywords, function(token) {
        var prevToken = token.getPreviousCodeToken();

        if (!prevToken) {
            return;
        }

        // Handle special cases listed in specialCasesToken array
        if (prevToken.value === specialCases[token.value]) {
            return;
        }

        // allow returning a function
        if (prevToken.value === &#x27;return&#x27; &#x26;&#x26; token.value === &#x27;function&#x27;) {
            return;
        }

        // Do not report `do...while` statements
        if (token.value === &#x27;while&#x27; &#x26;&#x26; token.parentElement.type === &#x27;DoWhileStatement&#x27;) {
            return;
        }

        // Handle excludedTokens
        if (excludedTokens.indexOf(prevToken.value) &#x3e; -1) {
            return;
        }

        // Handle all other cases
        // The { character is there to handle the case of a matching token which happens to be the first
        //   statement in a block
        // The ) character is there to handle the case of `if (...) matchingKeyword` in which case
        //   requiring padding would break the statement
        if (prevToken.value !== &#x27;{&#x27; &#x26;&#x26; prevToken.value !== &#x27;)&#x27;) {
            errors.assert.linesBetween({
                token: prevToken,
                nextToken: token,
                atLeast: 2,
                message: &#x27;Keyword `&#x27; + token.value + &#x27;` should have an empty line above it&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.configure" id="apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_keywords.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(Array.isArray(keywords) || keywords === true,
        this.getOptionName() + &#x27; option requires array or true value&#x27;);

    if (keywords === true) {
        keywords = defaultKeywords;
    }

    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.getOptionName" id="apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_keywords.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requirePaddingNewlinesBeforeKeywords&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_before_line_comments" id="apidoc.module.jscs.require_padding_newlines_before_line_comments">module jscs.require_padding_newlines_before_line_comments</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_line_comments.require_padding_newlines_before_line_comments" id="apidoc.element.jscs.require_padding_newlines_before_line_comments.require_padding_newlines_before_line_comments">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_line_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_before_line_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_before_line_comments.prototype" id="apidoc.module.jscs.require_padding_newlines_before_line_comments.prototype">module jscs.require_padding_newlines_before_line_comments.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.check" id="apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_line_comments.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var allowFirstAfterCurly = this._allowFirstAfterCurly;

    file.iterateTokensByType(&#x27;CommentLine&#x27;, function(comment) {
        if (comment.getLoc().start.line === 1) {
            return;
        }

        var firstToken = file.getFirstTokenOnLineWith(comment);

        // Should not consider code and comment on the same line (#1194)
        if (firstToken !== null &#x26;&#x26; firstToken.type !== &#x27;EOF&#x27;) {
            return;
        }

        var prevToken = file.getPrevToken(comment, {includeComments: true});

        if (!prevToken || prevToken.type === &#x27;CommentLine&#x27;) {
            return;
        }

        if (allowFirstAfterCurly &#x26;&#x26; prevToken.type === &#x27;Punctuator&#x27; &#x26;&#x26; prevToken.value === &#x27;{&#x27;) {
            return;
        }

        errors.assert.linesBetween({
            token: prevToken,
            nextToken: comment,
            atLeast: 2,
            message: &#x27;Line comments must be preceded with a blank line&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.configure" id="apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_line_comments.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    this._allowFirstAfterCurly = false;

    if (typeof value === &#x27;object&#x27;) {
        assert(typeof value.allExcept === &#x27;string&#x27; &#x26;&#x26; value.allExcept === &#x27;firstAfterCurly&#x27;,
            this.getOptionName() + &#x27; option requires the &#x22;allExcept&#x22; &#x27; +
             &#x27;property to equal &#x22;firstAfterCurly&#x22;&#x27;);
        this._allowFirstAfterCurly = true;
    } else {
        assert(value === true,
            this.getOptionName() + &#x27; option requires true value or object&#x27;
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.getOptionName" id="apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_line_comments.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requirePaddingNewLinesBeforeLineComments&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_in_blocks" id="apidoc.module.jscs.require_padding_newlines_in_blocks">module jscs.require_padding_newlines_in_blocks</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_blocks.require_padding_newlines_in_blocks" id="apidoc.element.jscs.require_padding_newlines_in_blocks.require_padding_newlines_in_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_in_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_in_blocks.prototype" id="apidoc.module.jscs.require_padding_newlines_in_blocks.prototype">module jscs.require_padding_newlines_in_blocks.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.check" id="apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_blocks.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var minLines = this._minLines;
    var exceptConditionals = this._exceptConditionals;
    var exceptFunctions = this._exceptFunctions;
    var checkOpen = this._checkOpen;
    var checkClose = this._checkClose;

    file.iterateNodesByType(&#x27;BlockStatement&#x27;, function(node) {
        var openingBracket;
        var closingBracket;

        if (node.body.length &#x3c;= minLines) {
            return;
        }

        if (exceptConditionals &#x26;&#x26; node.parentElement.type === &#x27;IfStatement&#x27; ||
            exceptFunctions &#x26;&#x26; (node.parentElement.type === &#x27;FunctionExpression&#x27; ||
            node.parentElement.type === &#x27;FunctionDeclaration&#x27;)) {
            return;
        }

        if (checkOpen === true) {
            openingBracket = node.getFirstToken();

            errors.assert.linesBetween({
                token: openingBracket,
                nextToken: file.getNextToken(openingBracket, {includeComments: true}),
                atLeast: 2,
                message: &#x27;Expected a padding newline after opening curly brace&#x27;
            });
        }

        if (checkClose === true) {
            closingBracket = file.getLastNodeToken(node);

            errors.assert.linesBetween({
                token: file.getPrevToken(closingBracket, {includeComments: true}),
                nextToken: closingBracket,
                atLeast: 2,
                message: &#x27;Expected a padding newline before closing curly brace&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.configure" id="apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_blocks.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var optionName = this.getOptionName();

    assert(
        options === true || typeof options === &#x27;number&#x27; || typeof options === &#x27;object&#x27;,
        optionName + &#x27; option requires the value true, an Integer or an object&#x27;
    );

    this._checkOpen = true;
    this._checkClose = true;
    this._minLines = 0;

    if (typeof options === &#x27;object&#x27;) {
        assert(options.allExcept || options.open || options.close,
        optionName + &#x27;option requires either &#x22;open&#x22;, &#x22;close&#x22;, &#x22;allExcept&#x22;&#x27;);

        if (options.allExcept) {
            assert(Array.isArray(options.allExcept), optionName + &#x27; option requires &#x22;allExcept&#x22; to be an array&#x27;);
            assert(options.allExcept.length &#x3e; 0, optionName + &#x27; option requires &#x22;allExcept&#x22; to have at least one &#x27; +
            &#x27;item or be set to `true`&#x27;);
            this._exceptConditionals = options.allExcept.indexOf(&#x27;conditionals&#x27;) &#x3e; -1;
            this._exceptFunctions = options.allExcept.indexOf(&#x27;functions&#x27;) &#x3e; -1;
        }

        if (options.open || options.close) {
            assert(typeof options.open === &#x27;boolean&#x27; &#x26;&#x26; typeof options.close === &#x27;boolean&#x27;,
              this.getOptionName() + &#x27; option requires the &#x22;open&#x22; and &#x22;close&#x22; &#x27; +
              &#x27;properties to be booleans&#x27;);

            this._checkOpen = options.open;
            this._checkClose = options.close;
        }
    } else if (typeof options === &#x27;number&#x27;) {
        this._minLines = options;
    } else {
        assert(options === true, this.getOptionName() + &#x27; option requires either a true value, or an object&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.getOptionName" id="apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_blocks.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requirePaddingNewlinesInBlocks&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_in_objects" id="apidoc.module.jscs.require_padding_newlines_in_objects">module jscs.require_padding_newlines_in_objects</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_objects.require_padding_newlines_in_objects" id="apidoc.element.jscs.require_padding_newlines_in_objects.require_padding_newlines_in_objects">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_objects
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_in_objects = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_in_objects.prototype" id="apidoc.module.jscs.require_padding_newlines_in_objects.prototype">module jscs.require_padding_newlines_in_objects.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_objects.prototype.check" id="apidoc.element.jscs.require_padding_newlines_in_objects.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_objects.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;ObjectExpression&#x27;, function(node) {
        var openingBracket = node.getFirstToken();
        var nextToken = file.getNextToken(openingBracket);

        if (nextToken.type === &#x27;Punctuator&#x27; &#x26;&#x26; nextToken.value === &#x27;}&#x27;) {
            return;
        }

        errors.assert.differentLine({
            token: openingBracket,
            nextToken: nextToken,
            message: &#x27;Missing newline after opening curly brace&#x27;
        });

        var closingBracket = file.getLastNodeToken(node);

        errors.assert.differentLine({
            token: file.getPrevToken(closingBracket),
            nextToken: closingBracket,
            message: &#x27;Missing newline before closing curly brace&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_objects.prototype.configure" id="apidoc.element.jscs.require_padding_newlines_in_objects.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_objects.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    assert(
        value === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_objects.prototype.getOptionName" id="apidoc.element.jscs.require_padding_newlines_in_objects.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_objects.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requirePaddingNewLinesInObjects&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_parentheses_around_arrow_param" id="apidoc.module.jscs.require_parentheses_around_arrow_param">module jscs.require_parentheses_around_arrow_param</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_arrow_param.require_parentheses_around_arrow_param" id="apidoc.element.jscs.require_parentheses_around_arrow_param.require_parentheses_around_arrow_param">
        function <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_arrow_param
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_parentheses_around_arrow_param = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_parentheses_around_arrow_param.prototype" id="apidoc.module.jscs.require_parentheses_around_arrow_param.prototype">module jscs.require_parentheses_around_arrow_param.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.check" id="apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_parentheses_around_arrow_param.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    function isWrapped(node) {
        var openParensToken = file.getPrevToken(file.getFirstNodeToken(node));
        var closingParensToken = file.getNextToken(file.getLastNodeToken(node));
        var closingTokenValue = closingParensToken ? closingParensToken.value : &#x27;&#x27;;

        return openParensToken.value + closingTokenValue === &#x27;()&#x27;;
    }

    file.iterateNodesByType(&#x27;ArrowFunctionExpression&#x27;, function(node) {
        var params = node.params;
        var firstParam = params[0];

        if (params.length === 1 &#x26;&#x26; !isWrapped(firstParam)) {
            errors.add(
                &#x27;Wrap arrow function expressions in parentheses&#x27;,
                firstParam
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.configure" id="apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_parentheses_around_arrow_param.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.getOptionName" id="apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_parentheses_around_arrow_param.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireParenthesesAroundArrowParam&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_parentheses_around_iife" id="apidoc.module.jscs.require_parentheses_around_iife">module jscs.require_parentheses_around_iife</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_iife.require_parentheses_around_iife" id="apidoc.element.jscs.require_parentheses_around_iife.require_parentheses_around_iife">
        function <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_iife
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_parentheses_around_iife = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_parentheses_around_iife.prototype" id="apidoc.module.jscs.require_parentheses_around_iife.prototype">module jscs.require_parentheses_around_iife.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_iife.prototype.check" id="apidoc.element.jscs.require_parentheses_around_iife.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_parentheses_around_iife.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {

    function isWrapped(node) {
        var openParensToken = file.getPrevToken(file.getFirstNodeToken(node));

        var closingParensToken = file.getNextToken(file.getLastNodeToken(node));
        var closingTokenValue = closingParensToken ? closingParensToken.value : &#x27;&#x27;;

        return openParensToken.value + closingTokenValue === &#x27;()&#x27;;
    }

    file.iterateNodesByType(&#x27;CallExpression&#x27;, function(node) {
        var inner = utils.getFunctionNodeFromIIFE(node);

        if (inner &#x26;&#x26; !isWrapped(inner) &#x26;&#x26; !isWrapped(node)) {
            errors.add(
                &#x27;Wrap immediately invoked function expressions in parentheses&#x27;,
                node
            );

        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_iife.prototype.configure" id="apidoc.element.jscs.require_parentheses_around_iife.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_parentheses_around_iife.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_iife.prototype.getOptionName" id="apidoc.element.jscs.require_parentheses_around_iife.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_parentheses_around_iife.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireParenthesesAroundIIFE&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_quoted_keys_in_objects" id="apidoc.module.jscs.require_quoted_keys_in_objects">module jscs.require_quoted_keys_in_objects</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_quoted_keys_in_objects.require_quoted_keys_in_objects" id="apidoc.element.jscs.require_quoted_keys_in_objects.require_quoted_keys_in_objects">
        function <span class="apidocSignatureSpan">jscs.</span>require_quoted_keys_in_objects
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_quoted_keys_in_objects = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_quoted_keys_in_objects.prototype" id="apidoc.module.jscs.require_quoted_keys_in_objects.prototype">module jscs.require_quoted_keys_in_objects.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_quoted_keys_in_objects.prototype._fix" id="apidoc.element.jscs.require_quoted_keys_in_objects.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.require_quoted_keys_in_objects.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var element = error.element.firstChild;
    var newElem = new cst.Token(element.type, &#x27;&#x22;&#x27; + element.getSourceCode() + &#x27;&#x22;&#x27;);

    element.parentElement.replaceChild(
        newElem,
        element
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &#x26;&#x26; instance._fix) {
        // &#x22;error.fixed = true&#x22; should go first, so rule can
        // decide for itself (with &#x22;error.fixed = false&#x22;)
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_quoted_keys_in_objects.prototype.check" id="apidoc.element.jscs.require_quoted_keys_in_objects.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_quoted_keys_in_objects.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;ObjectExpression&#x27;, function(node) {
        node.properties.forEach(function(property) {
            if (
                property.type === &#x27;ObjectMethod&#x27; &#x26;&#x26;
                (property.kind === &#x27;get&#x27; || property.kind === &#x27;set&#x27;)
            ) {
                return;
            }

            if (property.shorthand || property.method ||
                node.type === &#x27;SpreadProperty&#x27;) {
                return;
            }

            var key = property.key;
            if (key &#x26;&#x26; !(typeof key.value === &#x27;string&#x27; &#x26;&#x26; key.type.indexOf(&#x27;Literal&#x27;) &#x3e; -1)) {
                errors.cast({
                    message: &#x27;Object key without surrounding quotes&#x27;,
                    element: property.firstChild
                });
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_quoted_keys_in_objects.prototype.configure" id="apidoc.element.jscs.require_quoted_keys_in_objects.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_quoted_keys_in_objects.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_quoted_keys_in_objects.prototype.getOptionName" id="apidoc.element.jscs.require_quoted_keys_in_objects.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_quoted_keys_in_objects.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireQuotedKeysInObjects&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_semicolons" id="apidoc.module.jscs.require_semicolons">module jscs.require_semicolons</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_semicolons.require_semicolons" id="apidoc.element.jscs.require_semicolons.require_semicolons">
        function <span class="apidocSignatureSpan">jscs.</span>require_semicolons
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_semicolons = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_semicolons.prototype" id="apidoc.module.jscs.require_semicolons.prototype">module jscs.require_semicolons.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_semicolons.prototype._fix" id="apidoc.element.jscs.require_semicolons.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.require_semicolons.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var element = error.element;
    var semicolon = new cst.Token(&#x27;Punctuator&#x27;, &#x27;;&#x27;);

    while (element) {
        try {
            element.appendChild(semicolon);
            break;
        } catch (e) {}

        element = element.parentElement;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &#x26;&#x26; instance._fix) {
        // &#x22;error.fixed = true&#x22; should go first, so rule can
        // decide for itself (with &#x22;error.fixed = false&#x22;)
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_semicolons.prototype.check" id="apidoc.element.jscs.require_semicolons.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_semicolons.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType([
        &#x27;VariableDeclaration&#x27;,
        &#x27;ImportDeclaration&#x27;,
        &#x27;ExportDeclaration&#x27;,
        &#x27;ExportDefaultDeclaration&#x27;,
        &#x27;ExportNamedDeclaration&#x27;,
        &#x27;ExpressionStatement&#x27;,
        &#x27;DoWhileStatement&#x27;,
        &#x27;ReturnStatement&#x27;,
        &#x27;ThrowStatement&#x27;,
        &#x27;BreakStatement&#x27;,
        &#x27;ContinueStatement&#x27;,
        &#x27;DebuggerStatement&#x27;,
        &#x27;ClassProperty&#x27;
    ], function(node) {
        // ignore variable declaration inside for and for-in
        if (node.type === &#x27;VariableDeclaration&#x27;) {
            if ((node.parentElement.type === &#x27;ForInStatement&#x27; &#x26;&#x26; node.parentElement.left === node) ||
                (node.parentElement.type === &#x27;ForOfStatement&#x27; &#x26;&#x26; node.parentElement.left === node) ||
                (node.parentElement.type === &#x27;ForStatement&#x27; &#x26;&#x26; node.parentElement.init === node)) {
                return;
            }
        }

        // don&#x27;t require semicolon for class and function exports
        if (node.type === &#x27;ExportDefaultDeclaration&#x27; ||
            node.type === &#x27;ExportNamedDeclaration&#x27;) {
            if (node.declaration) {
                if (node.declaration.type === &#x27;ClassDeclaration&#x27; ||
                    node.declaration.type === &#x27;FunctionDeclaration&#x27;) {
                    return;
                }
            }
        }

        // get last token inside node
        var lastToken = file.getLastNodeToken(node);
        var checkToken = lastToken;

        // if last token is not a semicolon punctuator, try to get next token in file
        if (checkToken &#x26;&#x26; (checkToken.type !== &#x27;Punctuator&#x27; || checkToken.value !== &#x27;;&#x27;)) {
            checkToken = file.getNextToken(checkToken);
        }

        // check token is semicolon
        if (!checkToken || checkToken.type !== &#x27;Punctuator&#x27; || checkToken.value !== &#x27;;&#x27;) {
            var entity = lastToken || node;

            errors.cast({
                message: &#x27;Missing semicolon after statement&#x27;,
                element: entity
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_semicolons.prototype.configure" id="apidoc.element.jscs.require_semicolons.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_semicolons.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_semicolons.prototype.getOptionName" id="apidoc.element.jscs.require_semicolons.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_semicolons.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSemicolons&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_shorthand_arrow_functions" id="apidoc.module.jscs.require_shorthand_arrow_functions">module jscs.require_shorthand_arrow_functions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_shorthand_arrow_functions.require_shorthand_arrow_functions" id="apidoc.element.jscs.require_shorthand_arrow_functions.require_shorthand_arrow_functions">
        function <span class="apidocSignatureSpan">jscs.</span>require_shorthand_arrow_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_shorthand_arrow_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_shorthand_arrow_functions.prototype" id="apidoc.module.jscs.require_shorthand_arrow_functions.prototype">module jscs.require_shorthand_arrow_functions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_shorthand_arrow_functions.prototype.check" id="apidoc.element.jscs.require_shorthand_arrow_functions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_shorthand_arrow_functions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;ArrowFunctionExpression&#x27;, function(node) {
        var body = node.body;
        if (body.type === &#x27;BlockStatement&#x27; &#x26;&#x26;
            body.body.length === 1 &#x26;&#x26;
            body.body[0].type === &#x27;ReturnStatement&#x27;) {
            errors.add(
                &#x27;Use the shorthand arrow function form&#x27;,
                node.body
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_shorthand_arrow_functions.prototype.configure" id="apidoc.element.jscs.require_shorthand_arrow_functions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_shorthand_arrow_functions.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_shorthand_arrow_functions.prototype.getOptionName" id="apidoc.element.jscs.require_shorthand_arrow_functions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_shorthand_arrow_functions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireShorthandArrowFunctions&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_binary_operators" id="apidoc.module.jscs.require_space_after_binary_operators">module jscs.require_space_after_binary_operators</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_binary_operators.require_space_after_binary_operators" id="apidoc.element.jscs.require_space_after_binary_operators.require_space_after_binary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_binary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_binary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_binary_operators.prototype" id="apidoc.module.jscs.require_space_after_binary_operators.prototype">module jscs.require_space_after_binary_operators.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_binary_operators.prototype.check" id="apidoc.element.jscs.require_space_after_binary_operators.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_after_binary_operators.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operators = this._operatorIndex;

    // Comma
    if (operators[&#x27;,&#x27;]) {
        file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;,&#x27;, function(token) {
            errors.assert.whitespaceBetween({
                token: token,
                nextToken: file.getNextToken(token),
                message: &#x27;Operator , should not stick to following expression&#x27;
            });
        });
    }

    // For everything else
    file.iterateNodesByType(
        [&#x27;BinaryExpression&#x27;, &#x27;AssignmentExpression&#x27;, &#x27;VariableDeclarator&#x27;, &#x27;LogicalExpression&#x27;],
        function(node) {
            var operator;
            var expression;

            if (node.type === &#x27;VariableDeclarator&#x27;) {
                expression = node.init;
                operator = &#x27;=&#x27;;
            } else {
                operator = node.operator;
                expression = node.right;
            }

            if (expression === null) {
                return;
            }

            var operatorToken = file.findPrevOperatorToken(
                file.getFirstNodeToken(expression),
                operator
            );

            var nextToken = file.getNextToken(operatorToken);

            if (operators[operator]) {
                errors.assert.whitespaceBetween({
                    token: operatorToken,
                    nextToken: nextToken,
                    message: &#x27;Operator &#x27; + operator + &#x27; should not stick to following expression&#x27;
                });
            }
        }
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_binary_operators.prototype.configure" id="apidoc.element.jscs.require_space_after_binary_operators.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_after_binary_operators.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + &#x27; option requires array or true value&#x27;
    );

    if (isTrue) {
        operators = allOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &#x3c; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_binary_operators.prototype.getOptionName" id="apidoc.element.jscs.require_space_after_binary_operators.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_after_binary_operators.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpaceAfterBinaryOperators&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_comma" id="apidoc.module.jscs.require_space_after_comma">module jscs.require_space_after_comma</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_comma.require_space_after_comma" id="apidoc.element.jscs.require_space_after_comma.require_space_after_comma">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_comma = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_comma.prototype" id="apidoc.module.jscs.require_space_after_comma.prototype">module jscs.require_space_after_comma.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_comma.prototype.check" id="apidoc.element.jscs.require_space_after_comma.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_after_comma.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptTrailingCommas = this._exceptTrailingCommas;
    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;,&#x27;, function(token) {
        if (exceptTrailingCommas &#x26;&#x26; [&#x27;]&#x27;, &#x27;}&#x27;].indexOf(file.getNextToken(token).value) &#x3e;= 0) {
            return;
        }
        errors.assert.whitespaceBetween({
            token: token,
            nextToken: file.getNextToken(token),
            message: &#x27;Space required after comma&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_comma.prototype.configure" id="apidoc.element.jscs.require_space_after_comma.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_after_comma.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    if (typeof options !== &#x27;object&#x27;) {
        assert(
            options === true,
            this.getOptionName() + &#x27; option requires true value or an object&#x27;
        );
        var _options = {allExcept: []};
        return this.configure(_options);
    }

    assert(
        Array.isArray(options.allExcept),
        &#x27; property `allExcept` in &#x27; + this.getOptionName() + &#x27; should be an array of strings&#x27;
    );
    this._exceptTrailingCommas = options.allExcept.indexOf(&#x27;trailing&#x27;) &#x3e;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_comma.prototype.getOptionName" id="apidoc.element.jscs.require_space_after_comma.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_after_comma.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpaceAfterComma&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_keywords" id="apidoc.module.jscs.require_space_after_keywords">module jscs.require_space_after_keywords</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_keywords.require_space_after_keywords" id="apidoc.element.jscs.require_space_after_keywords.require_space_after_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_keywords.prototype" id="apidoc.module.jscs.require_space_after_keywords.prototype">module jscs.require_space_after_keywords.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_keywords.prototype.check" id="apidoc.element.jscs.require_space_after_keywords.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_after_keywords.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue(&#x27;Keyword&#x27;, this._keywords, function(token) {
        var nextToken = file.getNextToken(token, {includeComments: true});

        if (nextToken.type === &#x27;Punctuator&#x27; &#x26;&#x26; nextToken.value === &#x27;;&#x27;) {
            return;
        }

        errors.assert.spacesBetween({
            token: token,
            nextToken: nextToken,
            exactly: 1,
            message: &#x27;One space required after &#x22;&#x27; + token.value + &#x27;&#x22; keyword&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_keywords.prototype.configure" id="apidoc.element.jscs.require_space_after_keywords.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_after_keywords.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(
        Array.isArray(keywords) || keywords === true,
        this.getOptionName() + &#x27; option requires array or true value&#x27;);

    if (keywords === true) {
        keywords = defaultKeywords;
    }

    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_keywords.prototype.getOptionName" id="apidoc.element.jscs.require_space_after_keywords.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_after_keywords.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpaceAfterKeywords&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_line_comment" id="apidoc.module.jscs.require_space_after_line_comment">module jscs.require_space_after_line_comment</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_line_comment.require_space_after_line_comment" id="apidoc.element.jscs.require_space_after_line_comment.require_space_after_line_comment">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_line_comment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_line_comment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_line_comment.prototype" id="apidoc.module.jscs.require_space_after_line_comment.prototype">module jscs.require_space_after_line_comment.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_line_comment.prototype.check" id="apidoc.element.jscs.require_space_after_line_comment.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_after_line_comment.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var allExcept = this._allExcept;

    file.iterateTokensByType(&#x27;CommentLine&#x27;, function(comment) {
        var value = comment.value;

        // cutout exceptions
        allExcept.forEach(function(el) {
            if (value.indexOf(el) === 0) {
                value = value.substr(el.length);
            }
        });

        if (value.length === 0) {
            return;
        }

        if (value[0] !== &#x27; &#x27;) {
            errors.add(&#x27;Missing space after line comment&#x27;, comment);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_line_comment.prototype.configure" id="apidoc.element.jscs.require_space_after_line_comment.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_after_line_comment.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true ||
        options === &#x27;allowSlash&#x27; ||
        typeof options === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option requires a true value &#x27; +
        &#x27;or an object with String[] `allExcept` property&#x27;
    );

    // verify first item in `allExcept` property in object (if it&#x27;s an object)
    assert(
        typeof options !== &#x27;object&#x27; ||
        Array.isArray(options.allExcept) &#x26;&#x26;
        typeof options.allExcept[0] === &#x27;string&#x27;,
        &#x27;Property `allExcept` in &#x27; + this.getOptionName() + &#x27; should be an array of strings&#x27;
    );

    // don&#x27;t check triple slashed comments, microsoft js doc convention. see #593
    // exceptions. see #592
    // need to drop allowSlash support in 2.0. Fixes #697
    this._allExcept = options === &#x27;allowSlash&#x27; ? [&#x27;/&#x27;] :
        options.allExcept || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_line_comment.prototype.getOptionName" id="apidoc.element.jscs.require_space_after_line_comment.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_after_line_comment.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpaceAfterLineComment&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_object_keys" id="apidoc.module.jscs.require_space_after_object_keys">module jscs.require_space_after_object_keys</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_object_keys.require_space_after_object_keys" id="apidoc.element.jscs.require_space_after_object_keys.require_space_after_object_keys">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_object_keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_object_keys = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_object_keys.prototype" id="apidoc.module.jscs.require_space_after_object_keys.prototype">module jscs.require_space_after_object_keys.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_object_keys.prototype.check" id="apidoc.element.jscs.require_space_after_object_keys.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_after_object_keys.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;ObjectExpression&#x27;, function(node) {
        node.properties.forEach(function(property) {
            if (
                property.type === &#x27;ObjectMethod&#x27; &#x26;&#x26;
                (property.kind === &#x27;get&#x27; || property.kind === &#x27;set&#x27;)
            ) {
                return;
            }

            if (property.shorthand ||
                property.type === &#x27;SpreadProperty&#x27;) {
                return;
            }

            var token = file.getLastNodeToken(property.key);

            if (property.computed === true) {
                token = file.getNextToken(token);
            }

            errors.assert.whitespaceBetween({
                token: token,
                nextToken: file.getNextToken(token),
                message: &#x27;Missing space after key&#x27;
            });
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_object_keys.prototype.configure" id="apidoc.element.jscs.require_space_after_object_keys.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_after_object_keys.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_object_keys.prototype.getOptionName" id="apidoc.element.jscs.require_space_after_object_keys.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_after_object_keys.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpaceAfterObjectKeys&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_prefix_unary_operators" id="apidoc.module.jscs.require_space_after_prefix_unary_operators">module jscs.require_space_after_prefix_unary_operators</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_prefix_unary_operators.require_space_after_prefix_unary_operators" id="apidoc.element.jscs.require_space_after_prefix_unary_operators.require_space_after_prefix_unary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_prefix_unary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_prefix_unary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_prefix_unary_operators.prototype" id="apidoc.module.jscs.require_space_after_prefix_unary_operators.prototype">module jscs.require_space_after_prefix_unary_operators.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.check" id="apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_after_prefix_unary_operators.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operatorIndex = this._operatorIndex;

    file.iterateNodesByType([&#x27;UnaryExpression&#x27;, &#x27;UpdateExpression&#x27;], function(node) {
        // Check &#x22;node.prefix&#x22; for prefix type of (inc|dec)rement
        if (node.prefix &#x26;&#x26; operatorIndex[node.operator]) {
            var argument = node.argument.type;
            var operatorToken = node.getFirstToken();
            var nextToken = file.getNextToken(operatorToken);

            // Do not report consecutive operators (#405)
            if (
                argument === &#x27;UnaryExpression&#x27; || argument === &#x27;UpdateExpression&#x27; &#x26;&#x26;
                nextToken.value !== &#x27;(&#x27;
            ) {
                return;
            }

            errors.assert.whitespaceBetween({
                token: operatorToken,
                nextToken: nextToken,
                message: &#x27;Operator &#x27; + node.operator + &#x27; should not stick to operand&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.configure" id="apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_after_prefix_unary_operators.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + &#x27; option requires array or true value&#x27;
    );

    if (isTrue) {
        operators = defaultOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &#x3c; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.getOptionName" id="apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_after_prefix_unary_operators.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpaceAfterPrefixUnaryOperators&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_binary_operators" id="apidoc.module.jscs.require_space_before_binary_operators">module jscs.require_space_before_binary_operators</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_binary_operators.require_space_before_binary_operators" id="apidoc.element.jscs.require_space_before_binary_operators.require_space_before_binary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_binary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_binary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_binary_operators.prototype" id="apidoc.module.jscs.require_space_before_binary_operators.prototype">module jscs.require_space_before_binary_operators.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_binary_operators.prototype.check" id="apidoc.element.jscs.require_space_before_binary_operators.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_before_binary_operators.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operators = this._operatorIndex;

    // Comma
    if (operators[&#x27;,&#x27;]) {
        file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;,&#x27;, function(token) {
            errors.assert.whitespaceBetween({
                token: file.getPrevToken(token),
                nextToken: token,
                message: &#x27;Operator , should not stick to preceding expression&#x27;
            });
        });
    }

    // For everything else
    file.iterateNodesByType(
        [&#x27;BinaryExpression&#x27;, &#x27;AssignmentExpression&#x27;, &#x27;VariableDeclarator&#x27;, &#x27;LogicalExpression&#x27;],
        function(node) {
            var operator;
            var expression;

            if (node.type === &#x27;VariableDeclarator&#x27;) {
                expression = node.init;
                operator = &#x27;=&#x27;;
            } else {
                operator = node.operator;
                expression = node.right;
            }

            if (expression === null) {
                return;
            }

            var operatorToken = file.findPrevOperatorToken(
                file.getFirstNodeToken(expression),
                operator
            );

            var prevToken = file.getPrevToken(operatorToken);

            if (operators[operator]) {
                errors.assert.whitespaceBetween({
                    token: prevToken,
                    nextToken: operatorToken,
                    message: &#x27;Operator &#x27; + operator + &#x27; should not stick to preceding expression&#x27;
                });
            }
        }
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_binary_operators.prototype.configure" id="apidoc.element.jscs.require_space_before_binary_operators.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_before_binary_operators.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + &#x27; option requires array or true value&#x27;
    );

    if (isTrue) {
        operators = allOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &#x3c; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_binary_operators.prototype.getOptionName" id="apidoc.element.jscs.require_space_before_binary_operators.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_before_binary_operators.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpaceBeforeBinaryOperators&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_block_statements" id="apidoc.module.jscs.require_space_before_block_statements">module jscs.require_space_before_block_statements</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_block_statements.require_space_before_block_statements" id="apidoc.element.jscs.require_space_before_block_statements.require_space_before_block_statements">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_block_statements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_block_statements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_block_statements.prototype" id="apidoc.module.jscs.require_space_before_block_statements.prototype">module jscs.require_space_before_block_statements.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_block_statements.prototype.check" id="apidoc.element.jscs.require_space_before_block_statements.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_before_block_statements.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var count = this._count;
    file.iterateNodesByType(&#x27;BlockStatement&#x27;, function(node) {
        var first = node.getFirstToken();

        errors.assert.spacesBetween({
            token: file.getPrevToken(first),
            nextToken: first,
            atLeast: count,
            disallowNewLine: true,
            message: &#x27;One (or more) spaces required before opening brace for block expressions&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_block_statements.prototype.configure" id="apidoc.element.jscs.require_space_before_block_statements.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_before_block_statements.prototype.</span>configure
        <span class="apidocSignatureSpan">(requireSpaceBeforeBlockStatements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (requireSpaceBeforeBlockStatements) {
    assert(
        typeof requireSpaceBeforeBlockStatements === &#x27;boolean&#x27; ||
        typeof requireSpaceBeforeBlockStatements === &#x27;number&#x27;,
        this.getOptionName() + &#x27; option requires number or bolean&#x27;
    );
    assert(
        requireSpaceBeforeBlockStatements &#x3e;= 1,
        this.getOptionName() +
          &#x27; option requires true value or a number greater than equal to 1 or should be removed&#x27;
    );
    this._count = +requireSpaceBeforeBlockStatements;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_block_statements.prototype.getOptionName" id="apidoc.element.jscs.require_space_before_block_statements.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_before_block_statements.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpaceBeforeBlockStatements&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_comma" id="apidoc.module.jscs.require_space_before_comma">module jscs.require_space_before_comma</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_comma.require_space_before_comma" id="apidoc.element.jscs.require_space_before_comma.require_space_before_comma">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_comma = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_comma.prototype" id="apidoc.module.jscs.require_space_before_comma.prototype">module jscs.require_space_before_comma.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_comma.prototype.check" id="apidoc.element.jscs.require_space_before_comma.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_before_comma.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;,&#x27;, function(token) {
        var prevToken = token.getPreviousCodeToken();

        errors.assert.whitespaceBetween({
            token: prevToken,
            nextToken: token,
            message: &#x27;Space required before comma&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_comma.prototype.configure" id="apidoc.element.jscs.require_space_before_comma.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_before_comma.prototype.</span>configure
        <span class="apidocSignatureSpan">(option)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (option) {
    assert(
        option === true,
        this.getOptionName() + &#x27; option requires true value&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_comma.prototype.getOptionName" id="apidoc.element.jscs.require_space_before_comma.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_before_comma.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpaceBeforeComma&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_destructured_values" id="apidoc.module.jscs.require_space_before_destructured_values">module jscs.require_space_before_destructured_values</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_destructured_values.require_space_before_destructured_values" id="apidoc.element.jscs.require_space_before_destructured_values.require_space_before_destructured_values">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_destructured_values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_destructured_values = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_destructured_values.prototype" id="apidoc.module.jscs.require_space_before_destructured_values.prototype">module jscs.require_space_before_destructured_values.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_destructured_values.prototype.check" id="apidoc.element.jscs.require_space_before_destructured_values.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_before_destructured_values.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var checkSpaceMissing = function(propKey) {
        var keyToken = file.getFirstNodeToken(propKey);
        var colon    = file.findNextToken(keyToken, &#x27;Punctuator&#x27;, &#x27;:&#x27;);

        errors.assert.whitespaceBetween({
            token: colon,
            nextToken: file.getNextToken(colon),
            message: &#x27;Missing space after key colon&#x27;
        });
    };

    var letsCheckThisOne = function(item) {

        if (!item) {
            return;
        }

        if (item.type === &#x27;ObjectPattern&#x27;) {
            item.properties.forEach(function(property) {

                if (property.shorthand || property.method) {
                    return;
                }

                checkSpaceMissing(property.key);

                //Strategy for nested structures
                var propValue = property.value;

                if (!propValue) {
                    return;
                }

                letsCheckThisOne(propValue);
            });
        }

        if (item.type === &#x27;ArrayPattern&#x27;) {
            item.elements.forEach(letsCheckThisOne);
        }
    };

    file.iterateNodesByType([&#x27;VariableDeclaration&#x27;, &#x27;AssignmentExpression&#x27;], function(node) {

        if (node.type === &#x27;VariableDeclaration&#x27;) {
            node.declarations.forEach(function(declaration) {
                letsCheckThisOne(declaration.id || {});
            });
        }

        if (node.type === &#x27;AssignmentExpression&#x27;) {
            var left = node.left;

            if (left) {
                letsCheckThisOne(left);
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_destructured_values.prototype.configure" id="apidoc.element.jscs.require_space_before_destructured_values.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_before_destructured_values.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_destructured_values.prototype.getOptionName" id="apidoc.element.jscs.require_space_before_destructured_values.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_before_destructured_values.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpaceBeforeDestructuredValues&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_keywords" id="apidoc.module.jscs.require_space_before_keywords">module jscs.require_space_before_keywords</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_keywords.require_space_before_keywords" id="apidoc.element.jscs.require_space_before_keywords.require_space_before_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_keywords.prototype" id="apidoc.module.jscs.require_space_before_keywords.prototype">module jscs.require_space_before_keywords.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_keywords.prototype.check" id="apidoc.element.jscs.require_space_before_keywords.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_before_keywords.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue(&#x27;Keyword&#x27;, this._keywords, function(token) {
        var prevToken = file.getPrevToken(token, {includeComments: true});
        if (!prevToken || prevToken.isComment) {
            return;
        }

        if (prevToken.type !== &#x27;Punctuator&#x27; || prevToken.value !== &#x27;;&#x27;) {
            errors.assert.whitespaceBetween({
                token: prevToken,
                nextToken: token,
                message: &#x27;Missing space before &#x22;&#x27; + token.value + &#x27;&#x22; keyword&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_keywords.prototype.configure" id="apidoc.element.jscs.require_space_before_keywords.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_before_keywords.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    var isValidObject = (keywords === Object(keywords) &#x26;&#x26; keywords.hasOwnProperty(&#x27;allExcept&#x27;));

    assert(
        Array.isArray(keywords) || keywords === true || isValidObject,
        this.getOptionName() + &#x27; option requires array, object with &#x22;allExcept&#x22; property or true value&#x27;);

    var excludedKeywords = ignoredKeywords;
    if (isValidObject) {
        excludedKeywords = keywords.allExcept;
    }

    if (!Array.isArray(keywords)) {
        keywords = defaultKeywords.filter(function(keyword) {
            return (excludedKeywords.indexOf(keyword) === -1);
        });
    }

    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_keywords.prototype.getOptionName" id="apidoc.element.jscs.require_space_before_keywords.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_before_keywords.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpaceBeforeKeywords&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_object_values" id="apidoc.module.jscs.require_space_before_object_values">module jscs.require_space_before_object_values</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_object_values.require_space_before_object_values" id="apidoc.element.jscs.require_space_before_object_values.require_space_before_object_values">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_object_values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_object_values = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_object_values.prototype" id="apidoc.module.jscs.require_space_before_object_values.prototype">module jscs.require_space_before_object_values.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_object_values.prototype.check" id="apidoc.element.jscs.require_space_before_object_values.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_before_object_values.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;ObjectExpression&#x27;, function(node) {
        node.properties.forEach(function(property) {
            if (
               property.type === &#x27;ObjectMethod&#x27; &#x26;&#x26;
               (property.kind === &#x27;get&#x27; || property.kind === &#x27;set&#x27;)
           ) {
                return;
            }

            if (property.shorthand || property.method ||
                property.type === &#x27;SpreadProperty&#x27;) {
                return;
            }

            var keyToken = file.getFirstNodeToken(property.key);

            var colon = file.findNextToken(keyToken, &#x27;Punctuator&#x27;, &#x27;:&#x27;);

            errors.assert.whitespaceBetween({
                token: colon,
                nextToken: file.getNextToken(colon),
                message: &#x27;Missing space after key colon&#x27;
            });
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_object_values.prototype.configure" id="apidoc.element.jscs.require_space_before_object_values.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_before_object_values.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_object_values.prototype.getOptionName" id="apidoc.element.jscs.require_space_before_object_values.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_before_object_values.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpaceBeforeObjectValues&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_postfix_unary_operators" id="apidoc.module.jscs.require_space_before_postfix_unary_operators">module jscs.require_space_before_postfix_unary_operators</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_postfix_unary_operators.require_space_before_postfix_unary_operators" id="apidoc.element.jscs.require_space_before_postfix_unary_operators.require_space_before_postfix_unary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_postfix_unary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_postfix_unary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_postfix_unary_operators.prototype" id="apidoc.module.jscs.require_space_before_postfix_unary_operators.prototype">module jscs.require_space_before_postfix_unary_operators.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.check" id="apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_before_postfix_unary_operators.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operatorIndex = this._operatorIndex;

    // &#x27;UpdateExpression&#x27; involve only ++ and -- operators
    file.iterateNodesByType(&#x27;UpdateExpression&#x27;, function(node) {
        // &#x22;!node.prefix&#x22; means postfix type of (inc|dec)rement
        if (!node.prefix &#x26;&#x26; operatorIndex[node.operator]) {
            var operatorToken = file.getLastNodeToken(node);

            errors.assert.whitespaceBetween({
                token: file.getPrevToken(operatorToken),
                nextToken: operatorToken,
                message: &#x27;Operator &#x27; + node.operator + &#x27; should not stick to operand&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.configure" id="apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_before_postfix_unary_operators.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + &#x27; option requires array or true value&#x27;
    );

    if (isTrue) {
        operators = defaultOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &#x3c; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.getOptionName" id="apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_before_postfix_unary_operators.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpaceBeforePostfixUnaryOperators&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_between_arguments" id="apidoc.module.jscs.require_space_between_arguments">module jscs.require_space_between_arguments</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_between_arguments.require_space_between_arguments" id="apidoc.element.jscs.require_space_between_arguments.require_space_between_arguments">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_between_arguments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_between_arguments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_between_arguments.prototype" id="apidoc.module.jscs.require_space_between_arguments.prototype">module jscs.require_space_between_arguments.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_between_arguments.prototype.check" id="apidoc.element.jscs.require_space_between_arguments.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_between_arguments.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType([&#x27;CallExpression&#x27;], function(node) {
        node.arguments.forEach(function(param) {
            var punctuatorToken = file.getPrevToken(file.getFirstNodeToken(param));
            if (punctuatorToken.value === &#x27;,&#x27;) {
                errors.assert.whitespaceBetween({
                    token: punctuatorToken,
                    nextToken: file.getNextToken(punctuatorToken)
                });
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_between_arguments.prototype.configure" id="apidoc.element.jscs.require_space_between_arguments.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_between_arguments.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_between_arguments.prototype.getOptionName" id="apidoc.element.jscs.require_space_between_arguments.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_between_arguments.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpaceBetweenArguments&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_anonymous_function_expression" id="apidoc.module.jscs.require_spaces_in_anonymous_function_expression">module jscs.require_spaces_in_anonymous_function_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression.require_spaces_in_anonymous_function_expression" id="apidoc.element.jscs.require_spaces_in_anonymous_function_expression.require_spaces_in_anonymous_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_anonymous_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_anonymous_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_anonymous_function_expression.prototype" id="apidoc.module.jscs.require_spaces_in_anonymous_function_expression.prototype">module jscs.require_spaces_in_anonymous_function_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.check" id="apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_anonymous_function_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;
    var exceptions = this._exceptions;

    file.iterateNodesByType([&#x27;FunctionExpression&#x27;], function(node) {
        var functionNode = node;
        var parent = node.parentElement;

        // Ignore syntactic sugar for getters and setters.
        if (parent.type === &#x27;Property&#x27; &#x26;&#x26; (parent.kind === &#x27;get&#x27; || parent.kind === &#x27;set&#x27;)) {
            return;
        }

        // shorthand or constructor methods
        if (parent.method || parent.type === &#x27;MethodDefinition&#x27;) {
            functionNode = parent.key;
            if (exceptions.shorthand) {
                return;
            }
        }

        // anonymous function expressions only
        if (node.id) {
            return;
        }

        if (beforeOpeningRoundBrace) {
            var functionToken = file.getFirstNodeToken(functionNode);
            if (node.async &#x26;&#x26; functionToken.value === &#x27;async&#x27;) {
                functionToken = file.getNextToken(functionToken);
            }
            // if generator, set token to be * instead
            if (node.generator &#x26;&#x26; functionToken.value === &#x27;function&#x27;) {
                functionToken = file.getNextToken(functionToken);
            }
            errors.assert.whitespaceBetween({
                token: functionToken,
                nextToken: file.getNextToken(functionToken),
                message: &#x27;Missing space before opening round brace&#x27;
            });
        }

        if (beforeOpeningCurlyBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            errors.assert.whitespaceBetween({
                token: file.getPrevToken(bodyToken),
                nextToken: bodyToken,
                message: &#x27;Missing space before opening curly brace&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.configure" id="apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_anonymous_function_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    this._exceptions = {
        &#x27;shorthand&#x27;: false
    };

    assert(
        typeof options === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option must be the object&#x27;
    );

    if (&#x27;beforeOpeningRoundBrace&#x27; in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningRoundBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    if (&#x27;beforeOpeningCurlyBrace&#x27; in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningCurlyBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    if (&#x27;allExcept&#x27; in options) {
        if (typeof options.allExcept === &#x27;object&#x27;) {
            assert(
                Array.isArray(options.allExcept),
                this.getOptionName() + &#x27; option requires &#x22;allExcept&#x22; to be &#x27; +
                &#x27;an array&#x27;
            );
            assert(
                options.allExcept.length &#x3e; 0,
                this.getOptionName() + &#x27; option requires &#x22;allExcept&#x22; to have &#x27; +
                &#x27;at least one item or be set to `true`&#x27;
            );
            options.allExcept.forEach(function(except) {
                if (except === &#x27;shorthand&#x27;) {
                    this._exceptions.shorthand = true;
                } else {
                    assert(false, this.getOptionName() + &#x27; option requires &#x27; +
                    &#x27;&#x22;allExcept&#x22; to be an array containing &#x22;shorthand&#x22;&#x27;);
                }
            }, this);
        } else {
            assert(
                options.allExcept === true,
                this.getOptionName() + &#x27; option requires a true value or array&#x27;
            );
            this._exceptions.shorthand = true;
        }
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + &#x27; must have beforeOpeningCurlyBrace &#x27; +
        &#x27; or beforeOpeningRoundBrace property&#x27;
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_anonymous_function_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpacesInAnonymousFunctionExpression&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_call_expression" id="apidoc.module.jscs.require_spaces_in_call_expression">module jscs.require_spaces_in_call_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_call_expression.require_spaces_in_call_expression" id="apidoc.element.jscs.require_spaces_in_call_expression.require_spaces_in_call_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_call_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_call_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_call_expression.prototype" id="apidoc.module.jscs.require_spaces_in_call_expression.prototype">module jscs.require_spaces_in_call_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_call_expression.prototype.check" id="apidoc.element.jscs.require_spaces_in_call_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_call_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;CallExpression&#x27;, function(node) {
        var lastCalleeToken = file.getLastNodeToken(node.callee);
        var roundBraceToken = file.findNextToken(lastCalleeToken, &#x27;Punctuator&#x27;, &#x27;(&#x27;);

        errors.assert.whitespaceBetween({
            token: file.getPrevToken(roundBraceToken),
            nextToken: roundBraceToken,
            message: &#x27;Missing space before opening round brace&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_call_expression.prototype.configure" id="apidoc.element.jscs.require_spaces_in_call_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_call_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_call_expression.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_call_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_call_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpacesInCallExpression&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_conditional_expression" id="apidoc.module.jscs.require_spaces_in_conditional_expression">module jscs.require_spaces_in_conditional_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_conditional_expression.require_spaces_in_conditional_expression" id="apidoc.element.jscs.require_spaces_in_conditional_expression.require_spaces_in_conditional_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_conditional_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_conditional_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_conditional_expression.prototype" id="apidoc.module.jscs.require_spaces_in_conditional_expression.prototype">module jscs.require_spaces_in_conditional_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.check" id="apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_conditional_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType([&#x27;ConditionalExpression&#x27;], function(node) {
        var consequent = node.consequent;
        var alternate = node.alternate;
        var consequentToken = file.getFirstNodeToken(consequent);
        var alternateToken = file.getFirstNodeToken(alternate);
        var questionMarkToken = file.findPrevOperatorToken(consequentToken, &#x27;?&#x27;);
        var colonToken = file.findPrevOperatorToken(alternateToken, &#x27;:&#x27;);
        var token;

        if (this._afterTest) {
            token = file.getPrevToken(questionMarkToken);
            errors.assert.whitespaceBetween({
                token: token,
                nextToken: questionMarkToken,
                message: &#x27;Missing space after test&#x27;
            });
        }

        if (this._beforeConsequent) {
            token = file.getNextToken(questionMarkToken);
            errors.assert.whitespaceBetween({
                token: questionMarkToken,
                nextToken: token,
                message: &#x27;Missing space before consequent&#x27;
            });
        }

        if (this._afterConsequent) {
            token = file.getPrevToken(colonToken);
            errors.assert.whitespaceBetween({
                token: token,
                nextToken: colonToken,
                message: &#x27;Missing space after consequent&#x27;
            });
        }

        if (this._beforeAlternate) {
            token = file.getNextToken(colonToken);
            errors.assert.whitespaceBetween({
                token: colonToken,
                nextToken: token,
                message: &#x27;Missing space before alternate&#x27;
            });
        }
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.configure" id="apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_conditional_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var validProperties = [
        &#x27;afterTest&#x27;,
        &#x27;beforeConsequent&#x27;,
        &#x27;afterConsequent&#x27;,
        &#x27;beforeAlternate&#x27;
    ];
    var optionName = this.getOptionName();

    if (options === true) {
        options = {
            &#x27;afterTest&#x27;: true,
            &#x27;beforeConsequent&#x27;: true,
            &#x27;afterConsequent&#x27;: true,
            &#x27;beforeAlternate&#x27;: true
        };
    }

    assert(
        typeof options === &#x27;object&#x27;,
        optionName + &#x27; option requires a true value or an object&#x27;
    );

    var isProperlyConfigured = validProperties.some(function(key) {
        var isPresent = key in options;

        if (isPresent) {
            assert(
                options[key] === true,
                optionName + &#x27;.&#x27; + key + &#x27; property requires true value or should be removed&#x27;
            );
        }

        return isPresent;
    });

    assert(
        isProperlyConfigured,
        optionName + &#x27; must have at least 1 of the following properties: &#x27; + validProperties.join(&#x27;, &#x27;)
    );

    validProperties.forEach(function(property) {
        this[&#x27;_&#x27; + property] = Boolean(options[property]);
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_conditional_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpacesInConditionalExpression&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_for_statement" id="apidoc.module.jscs.require_spaces_in_for_statement">module jscs.require_spaces_in_for_statement</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_for_statement.require_spaces_in_for_statement" id="apidoc.element.jscs.require_spaces_in_for_statement.require_spaces_in_for_statement">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_for_statement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_for_statement = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_for_statement.prototype" id="apidoc.module.jscs.require_spaces_in_for_statement.prototype">module jscs.require_spaces_in_for_statement.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_for_statement.prototype.check" id="apidoc.element.jscs.require_spaces_in_for_statement.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_for_statement.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;ForStatement&#x27;, function(node) {
        if (node.test) {
            var testToken = file.getFirstNodeToken(node.test);
            var prevToken = file.getPrevToken(testToken);

            if (prevToken.value === &#x27;(&#x27; &#x26;&#x26;
                TokenCategorizer.categorizeOpenParen(prevToken) === &#x27;ParenthesizedExpression&#x27;) {
                testToken = prevToken;
                prevToken = file.getPrevToken(prevToken);
            }
            errors.assert.spacesBetween({
                token: prevToken,
                nextToken: testToken,
                exactly: 1,
                message: &#x27;One space required after semicolon&#x27;
            });
        }
        if (node.update) {
            var updateToken = file.getFirstNodeToken(node.update);
            errors.assert.spacesBetween({
                token: file.getPrevToken(updateToken),
                nextToken: updateToken,
                exactly: 1,
                message: &#x27;One space required after semicolon&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_for_statement.prototype.configure" id="apidoc.element.jscs.require_spaces_in_for_statement.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_for_statement.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_for_statement.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_for_statement.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_for_statement.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpacesInForStatement&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_function" id="apidoc.module.jscs.require_spaces_in_function">module jscs.require_spaces_in_function</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function.require_spaces_in_function" id="apidoc.element.jscs.require_spaces_in_function.require_spaces_in_function">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_function = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_function.prototype" id="apidoc.module.jscs.require_spaces_in_function.prototype">module jscs.require_spaces_in_function.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function.prototype.check" id="apidoc.element.jscs.require_spaces_in_function.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType([&#x27;FunctionDeclaration&#x27;, &#x27;FunctionExpression&#x27;], function(node) {
        // for a named function, use node.id
        var functionNode = node.id || node;
        var parent = node.parentElement;

        // Ignore syntactic sugar for getters and setters.
        if (parent.type === &#x27;Property&#x27; &#x26;&#x26; (parent.kind === &#x27;get&#x27; || parent.kind === &#x27;set&#x27;)) {
            return;
        }

        // shorthand or constructor methods
        if (parent.method || parent.type === &#x27;MethodDefinition&#x27;) {
            functionNode = parent.key;
        }

        if (beforeOpeningRoundBrace) {
            var functionToken = file.getFirstNodeToken(functionNode);
            if (node.async &#x26;&#x26; functionToken.value === &#x27;async&#x27;) {
                functionToken = file.getNextToken(functionToken);
            }
            // if generator, set token to be * instead
            if (node.generator &#x26;&#x26; functionToken.value === &#x27;function&#x27;) {
                functionToken = file.getNextToken(functionToken);
            }
            errors.assert.whitespaceBetween({
                token: functionToken,
                nextToken: file.getNextToken(functionToken),
                message: &#x27;Missing space before opening round brace&#x27;
            });
        }

        if (beforeOpeningCurlyBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            errors.assert.whitespaceBetween({
                token: file.getPrevToken(bodyToken),
                nextToken: bodyToken,
                message: &#x27;Missing space before opening curly brace&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function.prototype.configure" id="apidoc.element.jscs.require_spaces_in_function.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option must be the object&#x27;
    );

    if (&#x27;beforeOpeningRoundBrace&#x27; in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningRoundBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    if (&#x27;beforeOpeningCurlyBrace&#x27; in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningCurlyBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + &#x27; must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property&#x27;
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_function.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpacesInFunction&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_function_declaration" id="apidoc.module.jscs.require_spaces_in_function_declaration">module jscs.require_spaces_in_function_declaration</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_declaration.require_spaces_in_function_declaration" id="apidoc.element.jscs.require_spaces_in_function_declaration.require_spaces_in_function_declaration">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_declaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_function_declaration = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_function_declaration.prototype" id="apidoc.module.jscs.require_spaces_in_function_declaration.prototype">module jscs.require_spaces_in_function_declaration.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_declaration.prototype.check" id="apidoc.element.jscs.require_spaces_in_function_declaration.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_declaration.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType([&#x27;FunctionDeclaration&#x27;], function(node) {
        // Exception for `export default function` #1376
        if (!node.id) {
            return;
        }

        if (beforeOpeningRoundBrace) {
            // for a named function, use node.id
            var functionToken = file.getFirstNodeToken(node.id || node);
            if (node.async &#x26;&#x26; functionToken.value === &#x27;async&#x27;) {
                functionToken = file.getNextToken(functionToken);
            }
            // if generator, set token to be * instead
            if (node.generator &#x26;&#x26; functionToken.value === &#x27;function&#x27;) {
                functionToken = file.getNextToken(functionToken);
            }
            errors.assert.whitespaceBetween({
                token: functionToken,
                nextToken: file.getNextToken(functionToken),
                message: &#x27;Missing space before opening round brace&#x27;
            });
        }

        if (beforeOpeningCurlyBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            errors.assert.whitespaceBetween({
                token: file.getPrevToken(bodyToken),
                nextToken: bodyToken,
                message: &#x27;Missing space before opening curly brace&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_declaration.prototype.configure" id="apidoc.element.jscs.require_spaces_in_function_declaration.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_declaration.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option must be the object&#x27;
    );

    if (&#x27;beforeOpeningRoundBrace&#x27; in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningRoundBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    if (&#x27;beforeOpeningCurlyBrace&#x27; in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningCurlyBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + &#x27; must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property&#x27;
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_declaration.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_function_declaration.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_declaration.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpacesInFunctionDeclaration&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_function_expression" id="apidoc.module.jscs.require_spaces_in_function_expression">module jscs.require_spaces_in_function_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_expression.require_spaces_in_function_expression" id="apidoc.element.jscs.require_spaces_in_function_expression.require_spaces_in_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_function_expression.prototype" id="apidoc.module.jscs.require_spaces_in_function_expression.prototype">module jscs.require_spaces_in_function_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_expression.prototype.check" id="apidoc.element.jscs.require_spaces_in_function_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType(&#x27;FunctionExpression&#x27;, function(node) {
        // for a named function, use node.id
        var functionNode = node.id || node;
        var parent = node.parentElement;

        // Ignore syntactic sugar for getters and setters.
        if (parent.type === &#x27;Property&#x27; &#x26;&#x26; (parent.kind === &#x27;get&#x27; || parent.kind === &#x27;set&#x27;)) {
            return;
        }

        // shorthand or constructor methods
        if (parent.method || parent.type === &#x27;MethodDefinition&#x27;) {
            functionNode = parent.key;
        }

        if (beforeOpeningRoundBrace) {
            var functionToken = file.getFirstNodeToken(functionNode);
            if (node.async &#x26;&#x26; functionToken.value === &#x27;async&#x27;) {
                functionToken = file.getNextToken(functionToken);
            }
            // if generator, set token to be * instead
            if (node.generator &#x26;&#x26; functionToken.value === &#x27;function&#x27;) {
                functionToken = file.getNextToken(functionToken);
            }
            errors.assert.whitespaceBetween({
                token: functionToken,
                nextToken: file.getNextToken(functionToken),
                message: &#x27;Missing space before opening round brace&#x27;
            });
        }

        if (beforeOpeningCurlyBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            errors.assert.whitespaceBetween({
                token: file.getPrevToken(bodyToken),
                nextToken: bodyToken,
                message: &#x27;Missing space before opening curly brace&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_expression.prototype.configure" id="apidoc.element.jscs.require_spaces_in_function_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option must be the object&#x27;
    );

    if (&#x27;beforeOpeningRoundBrace&#x27; in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningRoundBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    if (&#x27;beforeOpeningCurlyBrace&#x27; in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningCurlyBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + &#x27; must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property&#x27;
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_expression.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_function_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpacesInFunctionExpression&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_generator" id="apidoc.module.jscs.require_spaces_in_generator">module jscs.require_spaces_in_generator</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_generator.require_spaces_in_generator" id="apidoc.element.jscs.require_spaces_in_generator.require_spaces_in_generator">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_generator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_generator = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_generator.prototype" id="apidoc.module.jscs.require_spaces_in_generator.prototype">module jscs.require_spaces_in_generator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_generator.prototype.check" id="apidoc.element.jscs.require_spaces_in_generator.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_generator.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeStar = this._beforeStar;
    var afterStar = this._afterStar;

    file.iterateNodesByType([&#x27;FunctionDeclaration&#x27;, &#x27;FunctionExpression&#x27;], function(node) {
        if (!node.generator) {
            return;
        }

        var parent = node.parentElement;
        var shorthand = false;

        // shorthand or constructor methods
        if (parent.method || parent.type === &#x27;MethodDefinition&#x27;) {
            shorthand = true;
            node = parent.key;
        }

        var currentToken = node.getFirstToken();

        if (node.async &#x26;&#x26; currentToken.value === &#x27;async&#x27;) {
            currentToken = file.getNextToken(currentToken);
        }

        if (beforeStar &#x26;&#x26; !shorthand) {
            // currentToken assigned outside of function
            errors.assert.whitespaceBetween({
                token: currentToken,
                nextToken: file.getNextToken(currentToken),
                message: &#x27;Missing space before star&#x27;
            });
        }

        if (afterStar) {
            if (shorthand) {
                currentToken = file.getPrevToken(currentToken);
            } else {
                // currentToken reassigned for star token
                currentToken = file.getNextToken(currentToken);
            }

            errors.assert.whitespaceBetween({
                token: currentToken,
                nextToken: file.getNextToken(currentToken),
                message: &#x27;Missing space after star&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_generator.prototype.configure" id="apidoc.element.jscs.require_spaces_in_generator.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_generator.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option must be an object&#x27;
    );

    if (&#x27;beforeStar&#x27; in options) {
        assert(
            options.beforeStar === true,
            this.getOptionName() + &#x27;.beforeStar &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }
    if (&#x27;afterStar&#x27; in options) {
        assert(
            options.afterStar === true,
            this.getOptionName() + &#x27;.afterStar &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    assert(
        options.beforeStar || options.afterStar,
        this.getOptionName() + &#x27; must have beforeStar or afterStar property&#x27;
    );

    this._beforeStar = options.beforeStar;
    this._afterStar = options.afterStar;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_generator.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_generator.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_generator.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpacesInGenerator&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_named_function_expression" id="apidoc.module.jscs.require_spaces_in_named_function_expression">module jscs.require_spaces_in_named_function_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_named_function_expression.require_spaces_in_named_function_expression" id="apidoc.element.jscs.require_spaces_in_named_function_expression.require_spaces_in_named_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_named_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_named_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_named_function_expression.prototype" id="apidoc.module.jscs.require_spaces_in_named_function_expression.prototype">module jscs.require_spaces_in_named_function_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.check" id="apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_named_function_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType([&#x27;FunctionExpression&#x27;], function(node) {
        var functionNode = node.id;
        var parent = node.parentElement;

        // Ignore syntactic sugar for getters and setters.
        if (parent.type === &#x27;Property&#x27; &#x26;&#x26; (parent.kind === &#x27;get&#x27; || parent.kind === &#x27;set&#x27;)) {
            return;
        }

        // shorthand or constructor methods
        if (parent.method || parent.type === &#x27;MethodDefinition&#x27;) {
            functionNode = parent.key;
        }

        // named function expressions only
        if (node.id) {
            if (beforeOpeningRoundBrace) {
                var functionToken = file.getFirstNodeToken(functionNode);
                if (node.async &#x26;&#x26; functionToken.value === &#x27;async&#x27;) {
                    functionToken = file.getNextToken(functionToken);
                }
                errors.assert.whitespaceBetween({
                    token: functionToken,
                    nextToken: file.getNextToken(functionToken),
                    message: &#x27;Missing space before opening round brace&#x27;
                });
            }

            if (beforeOpeningCurlyBrace) {
                var bodyToken = file.getFirstNodeToken(node.body);
                errors.assert.whitespaceBetween({
                    token: file.getPrevToken(bodyToken),
                    nextToken: bodyToken,
                    message: &#x27;Missing space before opening curly brace&#x27;
                });
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.configure" id="apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_named_function_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option must be the object&#x27;
    );

    if (&#x27;beforeOpeningRoundBrace&#x27; in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningRoundBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    if (&#x27;beforeOpeningCurlyBrace&#x27; in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + &#x27;.beforeOpeningCurlyBrace &#x27; +
            &#x27;property requires true value or should be removed&#x27;
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + &#x27; must have beforeOpeningCurlyBrace &#x27; +
        &#x27;or beforeOpeningRoundBrace property&#x27;
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_named_function_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpacesInNamedFunctionExpression&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_array_brackets" id="apidoc.module.jscs.require_spaces_inside_array_brackets">module jscs.require_spaces_inside_array_brackets</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_array_brackets.require_spaces_inside_array_brackets" id="apidoc.element.jscs.require_spaces_inside_array_brackets.require_spaces_inside_array_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_array_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_array_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_array_brackets.prototype" id="apidoc.module.jscs.require_spaces_inside_array_brackets.prototype">module jscs.require_spaces_inside_array_brackets.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.check" id="apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_array_brackets.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateNodesByType(&#x27;ArrayExpression&#x27;, function(node) {
        var openBracket = node.getFirstToken();
        var afterOpen = file.getNextToken(openBracket, {includeComments: true});
        var closeBracket = file.getLastNodeToken(node);
        var beforeClose = file.getPrevToken(closeBracket, {includeComments: true});

        // Skip for empty array brackets
        if (afterOpen.value === &#x27;]&#x27;) {
            return;
        }

        if (!(afterOpen.value in exceptions)) {
            errors.assert.spacesBetween({
                token: openBracket,
                nextToken: afterOpen,
                exactly: 1,
                message: &#x27;One space required after opening bracket&#x27;
            });
        }

        if (!(beforeClose.value in exceptions)) {
            errors.assert.spacesBetween({
                token: beforeClose,
                nextToken: closeBracket,
                exactly: 1,
                message: &#x27;One space required before closing bracket&#x27;
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.configure" id="apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_array_brackets.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var mode;
    var modes = {
        &#x27;all&#x27;: true,
        &#x27;allButNested&#x27;: true
    };
    var isObject = typeof value === &#x27;object&#x27;;

    var error = this.getOptionName() + &#x27; rule&#x27; +
    &#x27; requires string value &#x22;all&#x22; or &#x22;allButNested&#x22; or object&#x27;;

    if (typeof value === &#x27;string&#x27;) {
        assert(modes[value], error);

    } else if (isObject) {
        assert(&#x27;allExcept&#x27; in value, error);
    } else {
        assert(false, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);

    } else {
        mode = value;
    }

    if (mode === &#x27;allButNested&#x27;) {
        this._exceptions[&#x27;[&#x27;] = this._exceptions[&#x27;]&#x27;] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_array_brackets.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpacesInsideArrayBrackets&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_brackets" id="apidoc.module.jscs.require_spaces_inside_brackets">module jscs.require_spaces_inside_brackets</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_brackets.require_spaces_inside_brackets" id="apidoc.element.jscs.require_spaces_inside_brackets.require_spaces_inside_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_brackets.prototype" id="apidoc.module.jscs.require_spaces_inside_brackets.prototype">module jscs.require_spaces_inside_brackets.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_brackets.prototype.check" id="apidoc.element.jscs.require_spaces_inside_brackets.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_brackets.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;[&#x27;, function(token) {
        var nextToken = file.getNextToken(token, { includeComments: true });
        var value = nextToken.value;

        if (value in exceptions) {
            return;
        }

        // Skip for empty array brackets
        if (value === &#x27;]&#x27;) {
            return;
        }

        errors.assert.spacesBetween({
            token: token,
            nextToken: nextToken,
            exactly: 1,
            message: &#x27;One space required after opening bracket&#x27;
        });
    });

    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;]&#x27;, function(token) {
        var prevToken = file.getPrevToken(token, { includeComments: true });
        var value = prevToken.value;

        if (value in exceptions) {
            return;
        }

        // Skip for empty array brackets
        if (value === &#x27;[&#x27;) {
            return;
        }

        errors.assert.spacesBetween({
            token: prevToken,
            nextToken: token,
            exactly: 1,
            message: &#x27;One space required before closing bracket&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_brackets.prototype.configure" id="apidoc.element.jscs.require_spaces_inside_brackets.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_brackets.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var isObject = typeof value === &#x27;object&#x27;;

    var error = this.getOptionName() + &#x27; rule requires string value true or object&#x27;;

    if (isObject) {
        assert(&#x27;allExcept&#x27; in value, error);
    } else {
        assert(value === true, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_brackets.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_inside_brackets.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_brackets.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpacesInsideBrackets&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_imported_object_braces" id="apidoc.module.jscs.require_spaces_inside_imported_object_braces">module jscs.require_spaces_inside_imported_object_braces</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces.require_spaces_inside_imported_object_braces" id="apidoc.element.jscs.require_spaces_inside_imported_object_braces.require_spaces_inside_imported_object_braces">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_imported_object_braces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_imported_object_braces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_imported_object_braces.prototype" id="apidoc.module.jscs.require_spaces_inside_imported_object_braces.prototype">module jscs.require_spaces_inside_imported_object_braces.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.check" id="apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_imported_object_braces.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType([&#x27;ImportDeclaration&#x27;], function(node) {

        if (!node.specifiers) {
            return;
        }

        node.specifiers.forEach(function(specifier) {

            if (specifier.type !== &#x27;ImportSpecifier&#x27;) {
                return;
            }

            var maybeOpeningBrace = file.getPrevToken(specifier.getFirstToken());
            var maybeClosingBrace = file.getNextToken(specifier.getLastToken());

            if (maybeOpeningBrace.value === &#x27;{&#x27;) {
                errors.assert.spacesBetween({
                    token: maybeOpeningBrace,
                    nextToken: specifier.getFirstToken(),
                    exactly: 1,
                    message: &#x27;One space required after opening curly brace&#x27;
                });
            }

            if (maybeClosingBrace.value === &#x27;}&#x27;) {
                errors.assert.spacesBetween({
                    token: specifier.getLastToken(),
                    nextToken: maybeClosingBrace,
                    exactly: 1,
                    message: &#x27;One space required before closing curly brace&#x27;
                });
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.configure" id="apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_imported_object_braces.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_imported_object_braces.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpacesInsideImportedObjectBraces&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_object_brackets" id="apidoc.module.jscs.require_spaces_inside_object_brackets">module jscs.require_spaces_inside_object_brackets</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_object_brackets.require_spaces_inside_object_brackets" id="apidoc.element.jscs.require_spaces_inside_object_brackets.require_spaces_inside_object_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_object_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_object_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_object_brackets.prototype" id="apidoc.module.jscs.require_spaces_inside_object_brackets.prototype">module jscs.require_spaces_inside_object_brackets.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.check" id="apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_object_brackets.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateNodesByType([&#x27;ObjectExpression&#x27;, &#x27;ObjectPattern&#x27;], function(node) {
        var openingBracket = node.getFirstToken();
        var nextToken = file.getNextToken(openingBracket);

        // Don&#x27;t check empty object
        if (nextToken.value === &#x27;}&#x27;) {
            return;
        }

        errors.assert.spacesBetween({
            token: openingBracket,
            nextToken: nextToken,
            exactly: 1,
            message: &#x27;One space required after opening curly brace&#x27;
        });

        var closingBracket = file.getLastNodeToken(node);
        var prevToken = file.getPrevToken(closingBracket);

        if (prevToken.value in exceptions) {
            return;
        }

        errors.assert.spacesBetween({
            token: prevToken,
            nextToken: closingBracket,
            exactly: 1,
            message: &#x27;One space required before closing curly brace&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.configure" id="apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_object_brackets.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var mode;
    var modes = {
        &#x27;all&#x27;: true,
        &#x27;allButNested&#x27;: true
    };
    var isObject = typeof value === &#x27;object&#x27;;

    var error = this.getOptionName() + &#x27; rule&#x27; +
    &#x27; requires string value \&#x27;all\&#x27; or \&#x27;allButNested\&#x27; or object&#x27;;

    if (typeof value === &#x27;string&#x27;) {
        assert(modes[value], error);

    } else if (isObject) {
        assert(&#x27;allExcept&#x27; in value, error);
    } else {
        assert(false, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);

    } else {
        mode = value;
    }

    if (mode === &#x27;allButNested&#x27;) {
        this._exceptions[&#x27;}&#x27;] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_object_brackets.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpacesInsideObjectBrackets&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_parentheses" id="apidoc.module.jscs.require_spaces_inside_parentheses">module jscs.require_spaces_inside_parentheses</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parentheses.require_spaces_inside_parentheses" id="apidoc.element.jscs.require_spaces_inside_parentheses.require_spaces_inside_parentheses">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parentheses
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_parentheses = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_parentheses.prototype" id="apidoc.module.jscs.require_spaces_inside_parentheses.prototype">module jscs.require_spaces_inside_parentheses.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parentheses.prototype.check" id="apidoc.element.jscs.require_spaces_inside_parentheses.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parentheses.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;
    var singleQuote = this._exceptSingleQuote;
    var doubleQuote = this._exceptDoubleQuote;
    var ignoreParenthesizedExpression = this._ignoreParenthesizedExpression;

    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;(&#x27;, function(token) {
        var nextToken = file.getNextToken(token, {includeComments: true});
        var value = nextToken.getSourceCode();

        if (
            ignoreParenthesizedExpression &#x26;&#x26;
            TokenCategorizer.categorizeOpenParen(token) === &#x27;ParenthesizedExpression&#x27;
        ) {
            return;
        }

        if (value in exceptions) {
            return;
        }

        if (doubleQuote &#x26;&#x26; nextToken.type === &#x27;String&#x27; &#x26;&#x26; value[0] === &#x27;&#x22;&#x27;) {
            return;
        }

        if (singleQuote &#x26;&#x26; nextToken.type === &#x27;String&#x27; &#x26;&#x26; value[0] === &#x27;\&#x27;&#x27;) {
            return;
        }

        // Skip for empty parentheses
        if (value === &#x27;)&#x27;) {
            return;
        }

        errors.assert.whitespaceBetween({
            token: token,
            nextToken: nextToken,
            message: &#x27;Missing space after opening round bracket&#x27;
        });
    });

    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;)&#x27;, function(token) {
        var prevToken = file.getPrevToken(token, {includeComments: true});
        var value = prevToken.getSourceCode();

        if (
            ignoreParenthesizedExpression &#x26;&#x26;
            TokenCategorizer.categorizeCloseParen(token) === &#x27;ParenthesizedExpression&#x27;
        ) {
            return;
        }

        if (value in exceptions) {

            // Special case - foo( object[i] )
            if (!(
                value === &#x27;]&#x27; &#x26;&#x26;
                prevToken.parentElement.type === &#x27;MemberExpression&#x27;
            )) {
                return;
            }
        }

        if (doubleQuote &#x26;&#x26; prevToken.type === &#x27;String&#x27; &#x26;&#x26; value[value.length - 1] === &#x27;&#x22;&#x27;) {
            return;
        }

        if (singleQuote &#x26;&#x26; prevToken.type === &#x27;String&#x27; &#x26;&#x26; value[value.length - 1] === &#x27;\&#x27;&#x27;) {
            return;
        }

        // Skip for empty parentheses
        if (value === &#x27;(&#x27;) {
            return;
        }

        errors.assert.whitespaceBetween({
            token: prevToken,
            nextToken: token,
            message: &#x27;Missing space before closing round bracket&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parentheses.prototype.configure" id="apidoc.element.jscs.require_spaces_inside_parentheses.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parentheses.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var mode;
    var modes = {
        &#x27;all&#x27;: true,
        &#x27;allButNested&#x27;: true
    };
    var isObject = typeof value === &#x27;object&#x27;;

    var error = this.getOptionName() + &#x27; rule&#x27; +
    &#x27; requires string value \&#x27;all\&#x27; or \&#x27;allButNested\&#x27; or object&#x27;;

    if (typeof value === &#x27;string&#x27;) {
        assert(modes[value], error);

    } else if (isObject) {
        assert(
            &#x27;all&#x27; in value || &#x27;allButNested&#x27; in value,
            error
        );
    } else {
        assert(false, error);
    }

    this._exceptions = {};
    this._exceptSingleQuote = false;
    this._exceptDoubleQuote = false;
    this._ignoreParenthesizedExpression = false;

    if (isObject) {
        mode = &#x27;all&#x27; in value ? &#x27;all&#x27; : &#x27;allButNested&#x27;;

        (value.except || []).forEach(function(value) {
            if (value === &#x27;\&#x27;&#x27;) {
                this._exceptSingleQuote = true;
            }

            if (value === &#x27;&#x22;&#x27;) {
                this._exceptDoubleQuote = true;
            }

            this._exceptions[value] = true;
        }, this);

        if (value.ignoreParenthesizedExpression === true) {
            this._ignoreParenthesizedExpression = true;
        }

    } else {
        mode = value;
    }

    if (mode === &#x27;allButNested&#x27;) {
        this._exceptions[&#x27;)&#x27;] = this._exceptions[&#x27;(&#x27;] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parentheses.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_inside_parentheses.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parentheses.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpacesInsideParentheses&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_parenthesized_expression" id="apidoc.module.jscs.require_spaces_inside_parenthesized_expression">module jscs.require_spaces_inside_parenthesized_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression.require_spaces_inside_parenthesized_expression" id="apidoc.element.jscs.require_spaces_inside_parenthesized_expression.require_spaces_inside_parenthesized_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parenthesized_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_parenthesized_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_parenthesized_expression.prototype" id="apidoc.module.jscs.require_spaces_inside_parenthesized_expression.prototype">module jscs.require_spaces_inside_parenthesized_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.check" id="apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parenthesized_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;(&#x27;, function(token) {
        var nextToken = file.getNextToken(token, {includeComments: true});
        var value = nextToken.isComment ?
            nextToken.type === &#x27;CommentBlock&#x27; ? &#x27;/*&#x27; : &#x27;//&#x27; :
            nextToken.value;

        // Skip empty parentheses and explicit exceptions
        if (value === &#x27;)&#x27; || value in exceptions) {
            return;
        }

        // Skip non-expression parentheses
        var type = TokenCategorizer.categorizeOpenParen(token);
        if (type !== &#x27;ParenthesizedExpression&#x27;) {
            return;
        }

        errors.assert.whitespaceBetween({
            token: token,
            nextToken: nextToken,
            message: &#x27;Missing space after opening grouping parenthesis&#x27;
        });
    });

    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;)&#x27;, function(token) {
        var prevToken = file.getPrevToken(token, {includeComments: true});
        var value = prevToken.isComment ?
            prevToken.type === &#x27;CommentBlock&#x27; ? &#x27;*/&#x27; : &#x27;&#x27; :
            prevToken.value;

        // Skip empty parentheses and explicit exceptions
        if (value === &#x27;(&#x27; || value in exceptions) {
            return;
        }

        // Skip non-expression parentheses
        var type = TokenCategorizer.categorizeCloseParen(token);
        if (type !== &#x27;ParenthesizedExpression&#x27;) {
            return;
        }

        errors.assert.whitespaceBetween({
            token: prevToken,
            nextToken: token,
            message: &#x27;Missing space before closing grouping parenthesis&#x27;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.configure" id="apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parenthesized_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var isObject = typeof value === &#x27;object&#x27;;

    var error = this.getOptionName() + &#x27; rule requires string value true or object&#x27;;

    if (isObject) {
        assert(&#x27;allExcept&#x27; in value, error);
    } else {
        assert(value === true, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parenthesized_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpacesInsideParenthesizedExpression&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spread" id="apidoc.module.jscs.require_spread">module jscs.require_spread</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spread.require_spread" id="apidoc.element.jscs.require_spread.require_spread">
        function <span class="apidocSignatureSpan">jscs.</span>require_spread
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spread = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spread.prototype" id="apidoc.module.jscs.require_spread.prototype">module jscs.require_spread.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spread.prototype.check" id="apidoc.element.jscs.require_spread.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spread.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(&#x27;CallExpression&#x27;, function(node) {
        var callee = node.callee;
        var firstParameter = node.arguments[0];

        if (node.arguments.length === 2 &#x26;&#x26;
            callee.property &#x26;&#x26; callee.property.name === &#x27;apply&#x27; &#x26;&#x26;
            callee.object &#x26;&#x26; callee.object.name === firstParameter.name) {
            errors.add(
                &#x27;Illegal use of apply method. Use the spread operator instead&#x27;,
                node.callee.property
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spread.prototype.configure" id="apidoc.element.jscs.require_spread.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spread.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spread.prototype.getOptionName" id="apidoc.element.jscs.require_spread.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spread.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireSpread&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_template_strings" id="apidoc.module.jscs.require_template_strings">module jscs.require_template_strings</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_template_strings.require_template_strings" id="apidoc.element.jscs.require_template_strings.require_template_strings">
        function <span class="apidocSignatureSpan">jscs.</span>require_template_strings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_template_strings = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_template_strings.prototype" id="apidoc.module.jscs.require_template_strings.prototype">module jscs.require_template_strings.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_template_strings.prototype.check" id="apidoc.element.jscs.require_template_strings.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_template_strings.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var allowStringConcatenation = this._allowStringConcatenation;

    function add(node) {
        errors.add(
            &#x27;Illegal use of string concatenation. Use template strings instead.&#x27;,
            node.left
        );
    }

    file.iterateNodesByType(&#x27;BinaryExpression&#x27;, function(node) {
        if (node.operator !== &#x27;+&#x27;) {
            return;
        }

        var leftIsString = node.left;
        var rightIsString = node.right;

        // Left side could also be binary expression (See gh-2050),
        // but not the right one
        while (leftIsString.type === &#x27;BinaryExpression&#x27;) {
            leftIsString = leftIsString.left;
        }

        leftIsString = typeof leftIsString.value === &#x27;string&#x27; ||
            leftIsString.type === &#x27;TemplateLiteral&#x27;;

        rightIsString = typeof rightIsString.value === &#x27;string&#x27; ||
            rightIsString.type === &#x27;TemplateLiteral&#x27;;

        if (allowStringConcatenation &#x26;&#x26; leftIsString &#x26;&#x26; rightIsString) {
            return;
        }

        // At least one of the operands should be a string or template string,
        // otherwise this is not a concatenation
        if (leftIsString || rightIsString) {
            add(node);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_template_strings.prototype.configure" id="apidoc.element.jscs.require_template_strings.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_template_strings.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    this._allowStringConcatenation = false;
    var optionName = this.getOptionName();

    if (typeof options === &#x27;object&#x27;) {
        assert(Array.isArray(options.allExcept), optionName + &#x27; option requires &#x22;allExcept&#x22; &#x27; +
            &#x27;to be an array&#x27;);
        assert(options.allExcept.length &#x3e; 0, optionName + &#x27; option requires &#x22;allExcept&#x22; &#x27; +
            &#x27;to have at least one item or be set to `true`&#x27;);
        options.allExcept.forEach(function(except) {
            if (except === &#x27;stringConcatenation&#x27;) {
                this._allowStringConcatenation = true;
            } else {
                assert(false, optionName + &#x27; option requires &#x22;allExcept&#x22; to only have &#x27; +
                    &#x27;&#x22;stringConcatenation&#x22;&#x27;);
            }
        }, this);
    } else {
        assert(
            options === true,
            optionName + &#x27; option requires true value or object&#x27;
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_template_strings.prototype.getOptionName" id="apidoc.element.jscs.require_template_strings.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_template_strings.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireTemplateStrings&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_trailing_comma" id="apidoc.module.jscs.require_trailing_comma">module jscs.require_trailing_comma</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_trailing_comma.require_trailing_comma" id="apidoc.element.jscs.require_trailing_comma.require_trailing_comma">
        function <span class="apidocSignatureSpan">jscs.</span>require_trailing_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_trailing_comma = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_trailing_comma.prototype" id="apidoc.module.jscs.require_trailing_comma.prototype">module jscs.require_trailing_comma.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_trailing_comma.prototype._fix" id="apidoc.element.jscs.require_trailing_comma.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.require_trailing_comma.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var parent = error.additional;
    var afterProp;

    // ArrayPattern/ArrayExpression
    if (parent.type.indexOf(&#x27;Array&#x27;) === 0) {
        afterProp = parent.elements[parent.elements.length - 1].lastChild.getNextToken();

    // ObjectExpression/ObjectPattern
    } else {
        afterProp = parent.properties[parent.properties.length - 1].lastChild.getNextToken();
    }

    parent.insertChildBefore(new Token(&#x27;Punctuator&#x27;, &#x27;,&#x27;), afterProp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &#x26;&#x26; instance._fix) {
        // &#x22;error.fixed = true&#x22; should go first, so rule can
        // decide for itself (with &#x22;error.fixed = false&#x22;)
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_trailing_comma.prototype.check" id="apidoc.element.jscs.require_trailing_comma.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_trailing_comma.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var _this = this;

    file.iterateNodesByType([
        &#x27;ObjectExpression&#x27;, &#x27;ArrayExpression&#x27;,
        &#x27;ObjectPattern&#x27;, &#x27;ArrayPattern&#x27;
    ], function(node) {
        var isLikeObject = node.type === &#x27;ObjectExpression&#x27; || node.type === &#x27;ObjectPattern&#x27;;
        var entities = isLikeObject ? node.properties : node.elements;

        if (entities.length === 0) {
            return;
        }

        if (_this._ignoreSingleValue &#x26;&#x26; entities.length === 1) {
            return;
        }

        if (_this._ignoreSingleLine &#x26;&#x26; node.getNewlineCount() === 0) {
            return;
        }

        var possibleComma = file.getLastNodeToken(node).getPreviousCodeToken();

        if (possibleComma.value !== &#x27;,&#x27;) {
            errors.cast({
                message: &#x27;Missing comma before closing &#x27; + (isLikeObject ? &#x27;curly brace&#x27; : &#x27;bracket&#x27;),
                element: possibleComma,
                additional: node
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_trailing_comma.prototype.configure" id="apidoc.element.jscs.require_trailing_comma.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_trailing_comma.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {

    if (typeof options === &#x27;object&#x27;) {
        if (&#x27;ignoreSingleValue&#x27; in options) {
            assert(
                options.ignoreSingleValue === true,
                this.getOptionName() + &#x27; option ignoreSingleValue requires true value or should be removed&#x27;
            );
            this._ignoreSingleValue = true;
        }
        if (&#x27;ignoreSingleLine&#x27; in options) {
            assert(
                options.ignoreSingleLine === true,
                this.getOptionName() + &#x27; option ignoreSingleLine requires true value or should be removed&#x27;
            );
            this._ignoreSingleLine = true;
        }
    } else {
        assert(
            options === true,
            this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_trailing_comma.prototype.getOptionName" id="apidoc.element.jscs.require_trailing_comma.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_trailing_comma.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireTrailingComma&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_use_strict" id="apidoc.module.jscs.require_use_strict">module jscs.require_use_strict</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_use_strict.require_use_strict" id="apidoc.element.jscs.require_use_strict.require_use_strict">
        function <span class="apidocSignatureSpan">jscs.</span>require_use_strict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_use_strict = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_use_strict.prototype" id="apidoc.module.jscs.require_use_strict.prototype">module jscs.require_use_strict.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_use_strict.prototype.check" id="apidoc.element.jscs.require_use_strict.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_use_strict.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var program = file.getProgram();
    var directive = program.directives[0];

    if (directive) {
        return;
    }

    errors.add(
        &#x27;`&#x22;use strict&#x22;;` is required at the top of each file&#x27;,
        program
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_use_strict.prototype.configure" id="apidoc.element.jscs.require_use_strict.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_use_strict.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    if (typeof options !== &#x27;object&#x27;) {
        assert(
            options === true,
            this.getOptionName() + &#x27; option requires either a true value or an object&#x27;
        );

        var _options = {files: true};
        return this.configure(_options);
    }

    this._checkFiles = (options.files === true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_use_strict.prototype.getOptionName" id="apidoc.element.jscs.require_use_strict.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_use_strict.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireUseStrict&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_var_decl_first" id="apidoc.module.jscs.require_var_decl_first">module jscs.require_var_decl_first</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_var_decl_first.require_var_decl_first" id="apidoc.element.jscs.require_var_decl_first.require_var_decl_first">
        function <span class="apidocSignatureSpan">jscs.</span>require_var_decl_first
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_var_decl_first = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_var_decl_first.prototype" id="apidoc.module.jscs.require_var_decl_first.prototype">module jscs.require_var_decl_first.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_var_decl_first.prototype.check" id="apidoc.element.jscs.require_var_decl_first.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_var_decl_first.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType([&#x27;VariableDeclaration&#x27;], function(varDecl) {
        // Ignore let and const for now #1783
        if (varDecl.kind !== &#x27;var&#x27;) {
            return;
        }

        // Checking scope to not allow vars inside block statements.
        if (isScopeElement(varDecl.parentElement) &#x26;&#x26; isVarDeclFirst(varDecl)) {
            return;
        }

        errors.add(&#x27;Variable declarations must be the first statements of a function scope.&#x27;,
            varDecl);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_var_decl_first.prototype.configure" id="apidoc.element.jscs.require_var_decl_first.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_var_decl_first.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + &#x27; option requires a true value&#x27;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_var_decl_first.prototype.getOptionName" id="apidoc.element.jscs.require_var_decl_first.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_var_decl_first.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireVarDeclFirst&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_yoda_conditions" id="apidoc.module.jscs.require_yoda_conditions">module jscs.require_yoda_conditions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_yoda_conditions.require_yoda_conditions" id="apidoc.element.jscs.require_yoda_conditions.require_yoda_conditions">
        function <span class="apidocSignatureSpan">jscs.</span>require_yoda_conditions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_yoda_conditions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_yoda_conditions.prototype" id="apidoc.module.jscs.require_yoda_conditions.prototype">module jscs.require_yoda_conditions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_yoda_conditions.prototype.check" id="apidoc.element.jscs.require_yoda_conditions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_yoda_conditions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operators = this._operatorIndex;
    file.iterateNodesByType(&#x27;BinaryExpression&#x27;, function(node) {
        if (operators[node.operator]) {
            if (
                node.right.type.indexOf(&#x27;Literal&#x27;) &#x3e; -1 ||
                (node.right.type === &#x27;Identifier&#x27; &#x26;&#x26; node.right.name === &#x27;undefined&#x27;)
            ) {
                errors.add(&#x27;Not yoda condition&#x27;, node.left);
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_yoda_conditions.prototype.configure" id="apidoc.element.jscs.require_yoda_conditions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_yoda_conditions.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + &#x27; option requires array or true value&#x27;
    );

    if (isTrue) {
        operators = [&#x27;==&#x27;, &#x27;===&#x27;, &#x27;!=&#x27;, &#x27;!==&#x27;];
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &#x3c; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_yoda_conditions.prototype.getOptionName" id="apidoc.element.jscs.require_yoda_conditions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_yoda_conditions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;requireYodaConditions&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.safe_context_keyword" id="apidoc.module.jscs.safe_context_keyword">module jscs.safe_context_keyword</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.safe_context_keyword.safe_context_keyword" id="apidoc.element.jscs.safe_context_keyword.safe_context_keyword">
        function <span class="apidocSignatureSpan">jscs.</span>safe_context_keyword
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">safe_context_keyword = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.safe_context_keyword.prototype" id="apidoc.module.jscs.safe_context_keyword.prototype">module jscs.safe_context_keyword.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.safe_context_keyword.prototype.check" id="apidoc.element.jscs.safe_context_keyword.prototype.check">
        function <span class="apidocSignatureSpan">jscs.safe_context_keyword.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var keywords = typeof this._keywords === &#x27;string&#x27; ? [this._keywords] : this._keywords;

    // var that = this
    file.iterateNodesByType(&#x27;VariableDeclaration&#x27;, function(node) {

        for (var i = 0; i &#x3c; node.declarations.length; i++) {
            var decl = node.declarations[i];

            // Miss destructing assignment (#1699, #2119)
            if (decl.firstChild.type === &#x27;ObjectPattern&#x27;) {
                continue;
            }

            // decl.init === null in case of &#x22;var foo;&#x22;
            if (decl.init &#x26;&#x26;
                (decl.init.type === &#x27;ThisExpression&#x27; &#x26;&#x26; checkKeywords(decl.id.name, keywords))
            ) {
                errors.add(
                    &#x27;You should use &#x22;&#x27; + keywords.join(&#x27;&#x22; or &#x22;&#x27;) + &#x27;&#x22; to save a reference to &#x22;this&#x22;&#x27;,
                    node
                );
            }
        }
    });

    // that = this
    file.iterateNodesByType(&#x27;AssignmentExpression&#x27;, function(node) {

        if (
            // filter property assignments &#x22;foo.bar = this&#x22;
            node.left.type === &#x27;Identifier&#x27; &#x26;&#x26;
            (node.right.type === &#x27;ThisExpression&#x27; &#x26;&#x26; checkKeywords(node.left.name, keywords))
        ) {
            errors.add(
                &#x27;You should use &#x22;&#x27; + keywords.join(&#x27;&#x22; or &#x22;&#x27;) + &#x27;&#x22; to save a reference to &#x22;this&#x22;&#x27;,
                node
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.safe_context_keyword.prototype.configure" id="apidoc.element.jscs.safe_context_keyword.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.safe_context_keyword.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(
        Array.isArray(keywords) || typeof keywords === &#x27;string&#x27;,
        this.getOptionName() + &#x27; option requires string or array value&#x27;
    );

    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.safe_context_keyword.prototype.getOptionName" id="apidoc.element.jscs.safe_context_keyword.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.safe_context_keyword.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;safeContextKeyword&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.super_" id="apidoc.module.jscs.super_">module jscs.super_</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.super_.super_" id="apidoc.element.jscs.super_.super_">
        function <span class="apidocSignatureSpan">jscs.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {
    this._configuredRules = [];

    this._errorsFound = 0;
    this._maxErrorsExceeded = false;

    this._configuration = this._createConfiguration();
    this._configuration.registerDefaultPresets();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.super_.prototype" id="apidoc.module.jscs.super_.prototype">module jscs.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.super_.prototype._addParseError" id="apidoc.element.jscs.super_.prototype._addParseError">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_addParseError
        <span class="apidocSignatureSpan">(errors, parseError, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addParseError = function (errors, parseError, file) {
    if (this._maxErrorsExceeded) {
        return;
    }

    errors.add(parseError, file.getProgram());

    if (this.maxErrorsEnabled()) {
        this._errorsFound += 1;
        this._maxErrorsExceeded = this._errorsFound &#x3e;= this._maxErrors;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     *
     * @param {String | Error} message
     * @param {cst.types.Element} element
     * @param {Number} [offset] relative offset
     */
    add: function(message, element, offset) {
if (message instanceof Error) {
    this.<span class="apidocCodeKeywordSpan">_addParseError</span>(message);
    return;
}

this._addError({
    message: message,
    element: element,
    offset: offset
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype._checkJsFile" id="apidoc.element.jscs.super_.prototype._checkJsFile">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_checkJsFile
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkJsFile = function (file, errors) {
    if (this._maxErrorsExceeded) {
        return;
    }

    var errorFilter = this._configuration.getErrorFilter();

    this._configuredRules.forEach(function(rule) {
        errors.setCurrentRule(rule.getOptionName());

        try {
            rule.check(file, errors);
        } catch (e) {
            errors.setCurrentRule(&#x27;internalError&#x27;);
            errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
        }
    }, this);

    this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
        errors.add(&#x27;Unsupported rule: &#x27; + rulename, file.getProgram());
    });

    var program = file.getProgram();
    var tokenIndex = new TokenIndex(program.getFirstToken());
    errors.calculateErrorLocations(tokenIndex);
    errors.filter(function(error) {
        if (error.element) {
            return tokenIndex.isRuleEnabled(error.rule, error.element);
        } else {
            return true;
        }
    });

    // sort errors list to show errors as they appear in source
    errors.getErrorList().sort(function(a, b) {
        return (a.line - b.line) || (a.column - b.column);
    });

    if (errorFilter) {
        errors.filter(errorFilter);
    }

    if (this.maxErrorsEnabled()) {
        if (this._maxErrors === -1 || this._maxErrors === null) {
            this._maxErrorsExceeded = false;

        } else {
            this._maxErrorsExceeded = this._errorsFound + errors.getErrorCount() &#x3e; this._maxErrors;
            errors.stripErrorList(Math.max(0, this._maxErrors - this._errorsFound));
        }
    }

    this._errorsFound += errors.getErrorCount();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }, this);

    if (!file._program || file._program.firstChild.type === &#x27;EOF&#x27;) {
        return errors;
    }

    this.<span class="apidocCodeKeywordSpan">_checkJsFile</span>(file, errors);

    return errors;
},

/**
 * Apply fix for common errors.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype._createConfiguration" id="apidoc.element.jscs.super_.prototype._createConfiguration">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_createConfiguration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createConfiguration = function () {
    return new Configuration();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
var StringChecker = function() {
this._configuredRules = [];

this._errorsFound = 0;
this._maxErrorsExceeded = false;

this._configuration = this.<span class="apidocCodeKeywordSpan">_createConfiguration</span>();
this._configuration.registerDefaultPresets();
};

StringChecker.prototype = {
/**
 * Registers single Code Style checking rule.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype._createJsFileInstance" id="apidoc.element.jscs.super_.prototype._createJsFileInstance">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_createJsFileInstance
        <span class="apidocSignatureSpan">(filename, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createJsFileInstance = function (filename, source) {
    return new JsFile({
        filename: filename,
        source: source,
        es3: this._configuration.isES3Enabled()
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {String} source
     * @param {String} [filename=&#x27;input&#x27;]
     * @returns {Errors}
     */
    checkString: function(source, filename) {
filename = filename || &#x27;input&#x27;;

var file = this.<span class="apidocCodeKeywordSpan">_createJsFileInstance</span>(filename, source);

var errors = new Errors(file);

file.getParseErrors().forEach(function(parseError) {
    if (!this._maxErrorsExceeded) {
        this._addParseError(errors, parseError, file);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype._fixCommonError" id="apidoc.element.jscs.super_.prototype._fixCommonError">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_fixCommonError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fixCommonError = function (error) {
    if (error.fix) {
        // &#x22;error.fixed = true&#x22; should go first, so rule can
        // decide for itself (with &#x22;error.fixed = false&#x22;)
        // if it can fix this particular error
        error.fixed = true;
        error.fix();
    }

    return !!error.fixed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        errors.getErrorList().forEach(function(error) {
if (error.fixed) {
    return;
}

try {
    // Try to apply fixes for common errors
    var isFixed = this.<span class="apidocCodeKeywordSpan">_fixCommonError</span>(error);

    // Apply specific fix
    if (!isFixed) {
        this._fixSpecificError(file, error);
    }
} catch (e) {
    error.fixed = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype._fixJsFile" id="apidoc.element.jscs.super_.prototype._fixJsFile">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_fixJsFile
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fixJsFile = function (file, errors) {
    errors.getErrorList().forEach(function(error) {
        if (error.fixed) {
            return;
        }

        try {
            // Try to apply fixes for common errors
            var isFixed = this._fixCommonError(error);

            // Apply specific fix
            if (!isFixed) {
                this._fixSpecificError(file, error);
            }
        } catch (e) {
            error.fixed = false;
            errors.add(
                getInternalErrorMessage(error.rule, e),
                file.getProgram()
            );
        }
    }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            var attempt = 0;
            do {

// Fill in errors list
this._checkJsFile(file, errors);

// Apply fixes
this.<span class="apidocCodeKeywordSpan">_fixJsFile</span>(file, errors);

var hasFixes = errors.getErrorList().some(function(err) {
    return err.fixed;
});

if (!hasFixes) {
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype._fixSpecificError" id="apidoc.element.jscs.super_.prototype._fixSpecificError">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_fixSpecificError
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fixSpecificError = function (file, error) {
    var configuration = this.getConfiguration();
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &#x26;&#x26; instance._fix) {
        // &#x22;error.fixed = true&#x22; should go first, so rule can
        // decide for itself (with &#x22;error.fixed = false&#x22;)
        // if it can fix this particular error
        error.fixed = true;
        instance._fix(file, error);
    }

    return !!error.fixed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

try {
    // Try to apply fixes for common errors
    var isFixed = this._fixCommonError(error);

    // Apply specific fix
    if (!isFixed) {
        this.<span class="apidocCodeKeywordSpan">_fixSpecificError</span>(file, error);
    }
} catch (e) {
    error.fixed = false;
    errors.add(
        getInternalErrorMessage(error.rule, e),
        file.getProgram()
    );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.checkString" id="apidoc.element.jscs.super_.prototype.checkString">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>checkString
        <span class="apidocSignatureSpan">(source, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkString = function (source, filename) {
    filename = filename || &#x27;input&#x27;;

    var file = this._createJsFileInstance(filename, source);

    var errors = new Errors(file);

    file.getParseErrors().forEach(function(parseError) {
        if (!this._maxErrorsExceeded) {
            this._addParseError(errors, parseError, file);
        }
    }, this);

    if (!file._program || file._program.firstChild.type === &#x27;EOF&#x27;) {
        return errors;
    }

    this._checkJsFile(file, errors);

    return errors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
Checker.prototype.checkFile = function(path) {
   if (this._configuration.isFileExcluded(path)) {
       return Vow.resolve(null);
   }

   return vowFs.read(path, &#x27;utf8&#x27;).then(function(data) {
       return this.<span class="apidocCodeKeywordSpan">checkString</span>(data, path);
   }, this);
};

/**
* Fixes single file.
*
* @param {String} path
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.configure" id="apidoc.element.jscs.super_.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>configure
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (config) {
    this._configuration.load(config);

    this._configuredRules = this._configuration.getConfiguredRules();
    this._maxErrors = this._configuration.getMaxErrors();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.fixString" id="apidoc.element.jscs.super_.prototype.fixString">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>fixString
        <span class="apidocSignatureSpan">(source, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fixString = function (source, filename) {
    filename = filename || &#x27;input&#x27;;

    var file = this._createJsFileInstance(filename, source);
    var errors = new Errors(file);

    var parseErrors = file.getParseErrors();
    if (parseErrors.length &#x3e; 0) {
        parseErrors.forEach(function(parseError) {
            this._addParseError(errors, parseError, file);
        }, this);

        return {output: source, errors: errors};
    } else {
        var attempt = 0;
        do {

            // Fill in errors list
            this._checkJsFile(file, errors);

            // Apply fixes
            this._fixJsFile(file, errors);

            var hasFixes = errors.getErrorList().some(function(err) {
                return err.fixed;
            });

            if (!hasFixes) {
                break;
            }

            file = this._createJsFileInstance(filename, file.render());
            errors = new Errors(file);
            attempt++;
        } while (attempt &#x3c; MAX_FIX_ATTEMPTS);

        return {output: file.getSource(), errors: errors};
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Checker.prototype.fixFile = function(path) {
    if (this._configuration.isFileExcluded(path)) {
        return Vow.resolve(null);
    }

    return vowFs.read(path, &#x27;utf8&#x27;).then(function(data) {
        var result = this.<span class="apidocCodeKeywordSpan">fixString</span>(data, path);
        return vowFs.write(path, result.output).then(function() {
            return result.errors;
        });
    }, this);
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.getConfiguration" id="apidoc.element.jscs.super_.prototype.getConfiguration">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>getConfiguration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConfiguration = function () {
    return this._configuration;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// To run autoconfigure over all errors in the path
if (program.autoConfigure) {
    program.maxErrors = Infinity;
}

checker.<span class="apidocCodeKeywordSpan">getConfiguration</span>().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.configure(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.getProcessedConfig" id="apidoc.element.jscs.super_.prototype.getProcessedConfig">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>getProcessedConfig
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getProcessedConfig = function () {
    return this._configuration.getProcessedConfig();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Get processed config.
 *
 * @return {Object}
 */
getProcessedConfig: function() {
    return this._configuration.<span class="apidocCodeKeywordSpan">getProcessedConfig</span>();
},

/**
 * Loads configuration from JS Object. Activates and configures required rules.
 *
 * @param {Object} config
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.maxErrorsEnabled" id="apidoc.element.jscs.super_.prototype.maxErrorsEnabled">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>maxErrorsEnabled
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxErrorsEnabled = function () {
    return this._maxErrors !== null &#x26;&#x26; this._maxErrors !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return (a.line - b.line) || (a.column - b.column);
        });

        if (errorFilter) {
errors.filter(errorFilter);
        }

        if (this.<span class="apidocCodeKeywordSpan">maxErrorsEnabled</span>()) {
if (this._maxErrors === -1 || this._maxErrors === null) {
    this._maxErrorsExceeded = false;

} else {
    this._maxErrorsExceeded = this._errorsFound + errors.getErrorCount() &#x3e; this._maxErrors;
    errors.stripErrorList(Math.max(0, this._maxErrors - this._errorsFound));
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.maxErrorsExceeded" id="apidoc.element.jscs.super_.prototype.maxErrorsExceeded">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>maxErrorsExceeded
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxErrorsExceeded = function () {
    return this._maxErrorsExceeded;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var returnArgs = {
    checker: checker,
    reporter: program.reporter,
    promise: promise
};

function handleMaxErrors() {
    if (checker.<span class="apidocCodeKeywordSpan">maxErrorsExceeded</span>()) {
        console.error(&#x27;Too many errors... Increase `maxErrors` configuration option value to see more.&#x27;);
    }
}

promise.always(function(status) {
    exit(status.valueOf());
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.registerDefaultRules" id="apidoc.element.jscs.super_.prototype.registerDefaultRules">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>registerDefaultRules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerDefaultRules = function () {
    this._configuration.registerDefaultRules();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// To run autoconfigure over all errors in the path
if (program.autoConfigure) {
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().<span class="apidocCodeKeywordSpan">registerDefaultRules</span>();

try {
    checker.configure(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.registerRule" id="apidoc.element.jscs.super_.prototype.registerRule">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>registerRule
        <span class="apidocSignatureSpan">(rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerRule = function (rule) {
    this._configuration.registerRule(rule);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
StringChecker.prototype = {
/**
 * Registers single Code Style checking rule.
 *
 * @param {Rule} rule
 */
registerRule: function(rule) {
    this._configuration.<span class="apidocCodeKeywordSpan">registerRule</span>(rule);
},

/**
 * Registers built-in Code Style checking rules.
 */
registerDefaultRules: function() {
    this._configuration.registerDefaultRules();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.token_assert" id="apidoc.module.jscs.token_assert">module jscs.token_assert</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.token_assert.token_assert" id="apidoc.element.jscs.token_assert.token_assert">
        function <span class="apidocSignatureSpan">jscs.</span>token_assert
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenAssert(file) {
    EventEmitter.call(this);

    this._file = file;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.super_" id="apidoc.element.jscs.token_assert.super_">
        function <span class="apidocSignatureSpan">jscs.token_assert.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.token_assert.prototype" id="apidoc.module.jscs.token_assert.prototype">module jscs.token_assert.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype._augmentLineCount" id="apidoc.element.jscs.token_assert.prototype._augmentLineCount">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>_augmentLineCount
        <span class="apidocSignatureSpan">(options, lineCount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_augmentLineCount = function (options, lineCount) {
    var token = options.nextToken;
    if (lineCount === 0) {
        if (options.stickToPreviousToken) {
            var nextToken = this._file.getNextToken(token, {
                includeComments: true
            });
            this._file.setWhitespaceBefore(nextToken, this._file.getWhitespaceBefore(token));
        }

        this._file.setWhitespaceBefore(token, &#x27; &#x27;);
        return;
    }

    this._updateWhitespaceByLine(token, function(lines) {
        var currentLineCount = lines.length;
        var lastLine = lines[lines.length - 1];

        if (currentLineCount &#x3c;= lineCount) {
            // add additional lines that maintain the same indentation as the former last line
            for (; currentLineCount &#x3c;= lineCount; currentLineCount++) {
                lines[lines.length - 1] = &#x27;&#x27;;
                lines.push(lastLine);
            }
        } else {
            // remove lines and then ensure that the new last line maintains the previous indentation
            lines = lines.slice(0, lineCount + 1);
            lines[lines.length - 1] = lastLine;
        }

        return lines;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    var linesBetween = this._file.getLineCountBetween(token, nextToken);

    var emitError = function(countPrefix, lineCount) {
var msgPrefix = token.value + &#x27; and &#x27; + nextToken.value;

var fix = function() {
    this.<span class="apidocCodeKeywordSpan">_augmentLineCount</span>(options, lineCount);
}.bind(this);

if (!options.message) {
    if (exactly === 0) {
        // support sameLine
        options.message = msgPrefix + &#x27; should be on the same line&#x27;;
    } else if (atLeast === 1 &#x26;&#x26; atMost === undefined) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype._updateCommentWhitespace" id="apidoc.element.jscs.token_assert.prototype._updateCommentWhitespace">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>_updateCommentWhitespace
        <span class="apidocSignatureSpan">(token, indentChar, actual, expected)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateCommentWhitespace = function (token, indentChar, actual, expected) {
    var difference = expected - actual;
    var tokenLines = token.value.split(/\r\n|\r|\n/);
    var i = 1;
    if (difference &#x3e;= 0) {
        var lineWhitespace = (new Array(difference + 1)).join(indentChar);
        for (; i &#x3c; tokenLines.length; i++) {
            tokenLines[i] = tokenLines[i] === &#x27;&#x27; ? &#x27;&#x27; : lineWhitespace + tokenLines[i];
        }
    } else {
        for (; i &#x3c; tokenLines.length; i++) {
            tokenLines[i] = tokenLines[i].substring(-difference);
        }
    }

    var newComment = new Token(&#x27;CommentBlock&#x27;, tokenLines.join(this._file.getLineBreakStyle()));
    token.parentElement.replaceChild(newComment, token);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

            this._updateWhitespaceByLine(token, function(lines) {
                lines[lines.length - 1] = newWhitespace;
                return lines;
            });

            if (token.isComment) {
                this.<span class="apidocCodeKeywordSpan">_updateCommentWhitespace</span>(token, indentChar, actual, expected);
            }
        }.bind(this)
    });

    return true;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype._updateWhitespaceByLine" id="apidoc.element.jscs.token_assert.prototype._updateWhitespaceByLine">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>_updateWhitespaceByLine
        <span class="apidocSignatureSpan">(token, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateWhitespaceByLine = function (token, callback) {
    var lineBreak = this._file.getLineBreakStyle();
    var lines = this._file.getWhitespaceBefore(token).split(/\r\n|\r|\n/);

    lines = callback(lines);
    this._file.setWhitespaceBefore(token, lines.join(lineBreak));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.emit(&#x27;error&#x27;, {
        message: &#x27;Expected indentation of &#x27; + expected + &#x27; characters&#x27;,
        line: lineNumber,
        column: expected,
        fix: function() {
var newWhitespace = (new Array(expected + 1)).join(indentChar);

this.<span class="apidocCodeKeywordSpan">_updateWhitespaceByLine</span>(token, function(lines) {
    lines[lines.length - 1] = newWhitespace;
    return lines;
});

if (token.isComment) {
    this._updateCommentWhitespace(token, indentChar, actual, expected);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype._validateOptions" id="apidoc.element.jscs.token_assert.prototype._validateOptions">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>_validateOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_validateOptions = function (options) {
    var token = options.token;
    var nextToken = options.nextToken;
    var atLeast = options.atLeast;
    var atMost = options.atMost;
    var exactly = options.exactly;

    if (token === nextToken) {
        throw new Error(&#x27;You cannot specify the same token as both token and nextToken&#x27;);
    }

    if (atLeast === undefined &#x26;&#x26;
        atMost === undefined &#x26;&#x26;
        exactly === undefined) {
        throw new Error(&#x27;You must specify at least one option&#x27;);
    }

    if (exactly !== undefined &#x26;&#x26; (atLeast !== undefined || atMost !== undefined)) {
        throw new Error(&#x27;You cannot specify atLeast or atMost with exactly&#x27;);
    }

    if (atLeast !== undefined &#x26;&#x26; atMost !== undefined &#x26;&#x26; atMost &#x3c; atLeast) {
        throw new Error(&#x27;atLeast and atMost are in conflict&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var atMost = options.atMost;
var exactly = options.exactly;

if (!token || !nextToken) {
    return false;
}

this.<span class="apidocCodeKeywordSpan">_validateOptions</span>(options);

if (!options.disallowNewLine &#x26;&#x26; !this._file.isOnTheSameLine(token, nextToken)) {
    return false;
}

// Only attempt to remove or add lines if there are no comments between the two nodes
// as this prevents accidentally moving a valid token onto a line comment ed line
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype.differentLine" id="apidoc.element.jscs.token_assert.prototype.differentLine">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>differentLine
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">differentLine = function (options) {
    options.atLeast = 1;

    return this.linesBetween(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        errors.assert.sameLine({
            token: token,
            nextToken: nextToken,
            message: &#x27;Commas should be placed on the same line as value&#x27;
        });

        errors.assert.<span class="apidocCodeKeywordSpan">differentLine</span>({
            token: token.getPreviousCodeToken(),
            nextToken: token,
            message: &#x27;Commas should be placed on new line&#x27;
        });
    });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype.indentation" id="apidoc.element.jscs.token_assert.prototype.indentation">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>indentation
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indentation = function (options) {
    var token = options.token;
    var lineNumber = options.lineNumber;
    var actual = options.actual;
    var expected = options.expected;
    var indentChar = options.indentChar;

    if (actual === expected) {
        return false;
    }

    this.emit(&#x27;error&#x27;, {
        message: &#x27;Expected indentation of &#x27; + expected + &#x27; characters&#x27;,
        line: lineNumber,
        column: expected,
        fix: function() {
            var newWhitespace = (new Array(expected + 1)).join(indentChar);

            this._updateWhitespaceByLine(token, function(lines) {
                lines[lines.length - 1] = newWhitespace;
                return lines;
            });

            if (token.isComment) {
                this._updateCommentWhitespace(token, indentChar, actual, expected);
            }
        }.bind(this)
    });

    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var previousParam = firstParam;
params.slice(1).forEach(function(param) {
    if (!file.isOnTheSameLine(previousParam, param)) {
        var paramColumn = getNodeColumn(param);
        if (paramColumn !== referenceColumn) {
            errors.assert.<span class="apidocCodeKeywordSpan">indentation</span>({
                token: param.getFirstToken(),
                actual: paramColumn,
                expected: referenceColumn,
                indentChar: &#x27; &#x27;
            });
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype.linesBetween" id="apidoc.element.jscs.token_assert.prototype.linesBetween">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>linesBetween
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">linesBetween = function (options) {
    var token = options.token;
    var nextToken = options.nextToken;
    var atLeast = options.atLeast;
    var atMost = options.atMost;
    var exactly = options.exactly;

    if (!token || !nextToken) {
        return false;
    }

    this._validateOptions(options);

    // Only attempt to remove or add lines if there are no comments between the two nodes
    // as this prevents accidentally moving a valid token onto a line comment ed line
    var fixed = !options.token.getNextNonWhitespaceToken().isComment;

    var linesBetween = this._file.getLineCountBetween(token, nextToken);

    var emitError = function(countPrefix, lineCount) {
        var msgPrefix = token.value + &#x27; and &#x27; + nextToken.value;

        var fix = function() {
            this._augmentLineCount(options, lineCount);
        }.bind(this);

        if (!options.message) {
            if (exactly === 0) {
                // support sameLine
                options.message = msgPrefix + &#x27; should be on the same line&#x27;;
            } else if (atLeast === 1 &#x26;&#x26; atMost === undefined) {
                // support differentLine
                options.message = msgPrefix + &#x27; should be on different lines&#x27;;
            } else {
                // support linesBetween
                options.message = msgPrefix + &#x27; should have &#x27; + countPrefix + &#x27; &#x27; + lineCount + &#x27; line(s) between them&#x27;;
            }
        }

        this.emit(&#x27;error&#x27;, {
            message: options.message,
            element: token,
            offset: token.getSourceCodeLength(),
            fix: fixed ? fix : undefined
        });
    }.bind(this);

    if (atLeast !== undefined &#x26;&#x26; linesBetween &#x3c; atLeast) {
        emitError(&#x27;at least&#x27;, atLeast);
        return true;
    }

    if (atMost !== undefined &#x26;&#x26; linesBetween &#x3e; atMost) {
        emitError(&#x27;at most&#x27;, atMost);
        return true;
    }

    if (exactly !== undefined &#x26;&#x26; linesBetween !== exactly) {
        emitError(&#x27;exactly&#x27;, exactly);
        return true;
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Boolean} [options.stickToPreviousToken]
* @param {String} [options.message]
* @return {Boolean} whether an error was found
*/
TokenAssert.prototype.sameLine = function(options) {
   options.exactly = 0;

   return this.<span class="apidocCodeKeywordSpan">linesBetween</span>(options);
};

/**
* Requires tokens to be on different lines.
*
* @param {Object} options
* @param {Object} options.token
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype.noWhitespaceBetween" id="apidoc.element.jscs.token_assert.prototype.noWhitespaceBetween">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>noWhitespaceBetween
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noWhitespaceBetween = function (options) {
    options.exactly = 0;
    return this.spacesBetween(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Comma
if (operators[&#x27;,&#x27;]) {
    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;,&#x27;, function(token) {
        if (file.getNextToken(token).value === &#x27;,&#x27;) {
            return;
        }
        errors.assert.<span class="apidocCodeKeywordSpan">noWhitespaceBetween</span>({
            token: token,
            nextToken: file.getNextToken(token),
            message: &#x27;Operator , should stick to following expression&#x27;
        });
    });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype.sameLine" id="apidoc.element.jscs.token_assert.prototype.sameLine">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>sameLine
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sameLine = function (options) {
    options.exactly = 0;

    return this.linesBetween(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;,&#x27;, function(token) {
var nextToken = token.getNextCodeToken();

if (canSkip(token) || nextToken.value === &#x27;,&#x27;) {
    return;
}

errors.assert.<span class="apidocCodeKeywordSpan">sameLine</span>({
    token: token,
    nextToken: nextToken,
    message: &#x27;Commas should be placed on the same line as value&#x27;
});

errors.assert.differentLine({
    token: token.getPreviousCodeToken(),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype.spacesBetween" id="apidoc.element.jscs.token_assert.prototype.spacesBetween">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>spacesBetween
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spacesBetween = function (options) {
    var token = options.token;
    var nextToken = options.nextToken;
    var atLeast = options.atLeast;
    var atMost = options.atMost;
    var exactly = options.exactly;

    if (!token || !nextToken) {
        return false;
    }

    this._validateOptions(options);

    if (!options.disallowNewLine &#x26;&#x26; !this._file.isOnTheSameLine(token, nextToken)) {
        return false;
    }

    // Only attempt to remove or add lines if there are no comments between the two nodes
    // as this prevents accidentally moving a valid token onto a line comment ed line
    var fixed = !options.token.getNextNonWhitespaceToken().isComment;

    var emitError = function(countPrefix, spaceCount) {
        var fix = function() {
            this._file.setWhitespaceBefore(nextToken, new Array(spaceCount + 1).join(&#x27; &#x27;));
        }.bind(this);

        var msgPostfix = token.value + &#x27; and &#x27; + nextToken.value;

        if (!options.message) {
            if (exactly === 0) {
                // support noWhitespaceBetween
                options.message = &#x27;Unexpected whitespace between &#x27; + msgPostfix;
            } else if (exactly !== undefined) {
                // support whitespaceBetween (spaces option)
                options.message = spaceCount + &#x27; spaces required between &#x27; + msgPostfix;
            } else if (atLeast === 1 &#x26;&#x26; atMost === undefined) {
                // support whitespaceBetween (no spaces option)
                options.message = &#x27;Missing space between &#x27; + msgPostfix;
            } else {
                options.message = countPrefix + &#x27; &#x27; + spaceCount + &#x27; spaces required between &#x27; + msgPostfix;
            }
        }

        this.emit(&#x27;error&#x27;, {
            message: options.message,
            element: token,
            offset: token.getSourceCodeLength(),
            fix: fixed ? fix : undefined
        });
    }.bind(this);

    var spacesBetween = this._file.getDistanceBetween(token, nextToken);

    if (atLeast !== undefined &#x26;&#x26; spacesBetween &#x3c; atLeast) {
        emitError(&#x27;at least&#x27;, atLeast);
        return true;
    }

    if (atMost !== undefined &#x26;&#x26; spacesBetween &#x3e; atMost) {
        emitError(&#x27;at most&#x27;, atMost);
        return true;
    }

    if (exactly !== undefined &#x26;&#x26; spacesBetween !== exactly) {
        emitError(&#x27;exactly&#x27;, exactly);
        return true;
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Object} options.nextToken
* @param {String} [options.message]
* @param {Number} [options.spaces] Amount of spaces between tokens.
* @return {Boolean} whether an error was found
*/
TokenAssert.prototype.whitespaceBetween = function(options) {
   options.atLeast = 1;
   return this.<span class="apidocCodeKeywordSpan">spacesBetween</span>(options);
};

/**
* Requires to have no whitespace between specified tokens.
*
* @param {Object} options
* @param {Object} options.token
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype.whitespaceBetween" id="apidoc.element.jscs.token_assert.prototype.whitespaceBetween">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>whitespaceBetween
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whitespaceBetween = function (options) {
    options.atLeast = 1;
    return this.spacesBetween(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    check: function(file, errors) {
var operators = this._operatorIndex;

// Comma
if (operators[&#x27;,&#x27;]) {
    file.iterateTokensByTypeAndValue(&#x27;Punctuator&#x27;, &#x27;,&#x27;, function(token) {
        errors.assert.<span class="apidocCodeKeywordSpan">whitespaceBetween</span>({
            token: token,
            nextToken: file.getNextToken(token),
            message: &#x27;Operator , should not stick to following expression&#x27;
        });
    });
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.token_categorizer" id="apidoc.module.jscs.token_categorizer">module jscs.token_categorizer</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.token_categorizer.categorizeCloseParen" id="apidoc.element.jscs.token_categorizer.categorizeCloseParen">
        function <span class="apidocSignatureSpan">jscs.token_categorizer.</span>categorizeCloseParen
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">categorizeCloseParen = function (token) {
    assert(token.value === &#x27;)&#x27;, &#x27;Input token must be a parenthesis&#x27;);
    var node = token.parentElement;
    var nodeType = node.type;
    var nextToken = token.getNextCodeToken();

    // Terminal statement
    if (nextToken.type === &#x27;EOF&#x27;) {
        switch (nodeType) {
            case &#x27;DoWhileStatement&#x27;:
                return &#x27;Statement&#x27;;
            case &#x27;CallExpression&#x27;:
            case &#x27;NewExpression&#x27;:
                return &#x27;CallExpression&#x27;;
            default:
                return &#x27;ParenthesizedExpression&#x27;;
        }
    }

    // Part of a parentheses-bearing statement (if, with, while, switch, etc.)
    if (PAREN_KEYWORD_TYPE_RE.test(nodeType) &#x26;&#x26; !NO_PAREN_KEYWORD_TYPE_RE.test(nodeType)) {
        // Closing parentheses for `switch` and `catch` must be followed by &#x22;{&#x22;
        // Closing parentheses for `do..while` may be the last punctuation inside a block
        if (nextToken.value === &#x27;{&#x27; || nextToken.value === &#x27;}&#x27;) {
            return &#x27;Statement&#x27;;
        }

        // Closing parentheses for other statements must be followed by a statement or declaration
        var nextNode = nextToken.parentElement;
        while (!nodeContains(nextNode, token)) {
            if (QUASI_STATEMENT_TYPE_RE.test(nextNode.type)) {
                return &#x27;Statement&#x27;;
            }
            nextNode = nextNode.parentElement;
        }
    }

    // Part of a function definition (declaration, expression, method, etc.)
    if (nextToken.value === &#x27;{&#x27; &#x26;&#x26; FUNCTION_TYPE_RE.test(nodeType)) {
        return &#x27;Function&#x27;;
    }

    // Part of a call expression
    if ((nodeType === &#x27;CallExpression&#x27; || nodeType === &#x27;NewExpression&#x27;)) {
        var openParen = node.callee.getNextToken();
        if (openParen.parentElement === node &#x26;&#x26; node.lastChild === token) {
            return &#x27;CallExpression&#x27;;
        }
    }

    // All remaining cases are grouping parentheses
    return &#x27;ParenthesizedExpression&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Skip empty parentheses and explicit exceptions
if (value === &#x27;(&#x27; || value in exceptions) {
    return;
}

// Skip non-expression parentheses
var type = TokenCategorizer.<span class="apidocCodeKeywordSpan">categorizeCloseParen</span>(token);
if (type !== &#x27;ParenthesizedExpression&#x27;) {
    return;
}

errors.assert.noWhitespaceBetween({
    token: prevToken,
    nextToken: token,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_categorizer.categorizeOpenParen" id="apidoc.element.jscs.token_categorizer.categorizeOpenParen">
        function <span class="apidocSignatureSpan">jscs.token_categorizer.</span>categorizeOpenParen
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">categorizeOpenParen = function (token) {
    assert(token.value === &#x27;(&#x27;, &#x27;Input token must be a parenthesis&#x27;);
    var node = token.parentElement;
    var nodeType = node.type;
    var prevToken = token.getPreviousCodeToken();

    // Outermost grouping parenthesis
    if (!prevToken) {
        return &#x27;ParenthesizedExpression&#x27;;
    }

    // Part of a parentheses-bearing statement (if, with, while, switch, etc.)
    if (prevToken.type === &#x27;Keyword&#x27; &#x26;&#x26; PAREN_KEYWORD_TYPE_RE.test(nodeType) &#x26;&#x26;
        !NO_PAREN_KEYWORD_TYPE_RE.test(nodeType)) {

        return &#x27;Statement&#x27;;
    }

    // Part of a function definition (declaration, expression, method, etc.)
    if (FUNCTION_TYPE_RE.test(nodeType) &#x26;&#x26;

        // Name is optional for function expressions
        (prevToken.type === &#x27;Identifier&#x27; || prevToken.value === &#x27;function&#x27;)) {

        return &#x27;Function&#x27;;
    }

    // Part of a call expression
    var prevNode = prevToken.parentElement;
    if ((nodeType === &#x27;CallExpression&#x27; || nodeType === &#x27;NewExpression&#x27;) &#x26;&#x26;

        // Must not be inside an arguments list or other grouping parentheses
        prevToken.value !== &#x27;,&#x27; &#x26;&#x26; prevToken.value !== &#x27;(&#x27; &#x26;&#x26;

        // If the callee is parenthesized (e.g., `(foo.bar)()`), prevNode will match node
        // Otherwise (e.g., `foo.bar()`), prevToken must be the last token of the callee node
        (prevNode === node || prevToken === node.callee.getLastToken())) {

        return &#x27;CallExpression&#x27;;
    }

    // All remaining cases are grouping parentheses
    return &#x27;ParenthesizedExpression&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Skip empty parentheses and explicit exceptions
if (value === &#x27;)&#x27; || value in exceptions) {
    return;
}

// Skip non-expression parentheses
var type = TokenCategorizer.<span class="apidocCodeKeywordSpan">categorizeOpenParen</span>(token);
if (type !== &#x27;ParenthesizedExpression&#x27;) {
    return;
}

errors.assert.noWhitespaceBetween({
    token: token,
    nextToken: nextToken,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.token_index" id="apidoc.module.jscs.token_index">module jscs.token_index</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.token_index.token_index" id="apidoc.element.jscs.token_index.token_index">
        function <span class="apidocSignatureSpan">jscs.</span>token_index
        <span class="apidocSignatureSpan">(firstToken)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenIndex(firstToken) {
    this._buildIndex(firstToken);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.token_index.prototype" id="apidoc.module.jscs.token_index.prototype">module jscs.token_index.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.token_index.prototype._buildIndex" id="apidoc.element.jscs.token_index.prototype._buildIndex">
        function <span class="apidocSignatureSpan">jscs.token_index.prototype.</span>_buildIndex
        <span class="apidocSignatureSpan">(firstToken)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_buildIndex = function (firstToken) {
    this._hasPragmas = false;

    var tokens = [];
    var index = [];
    var positions = [];
    var currentPosition = 0;
    var currentToken = firstToken;
    var lastBlockState = {&#x27;*&#x27;: true};
    var tokenState;
    var previousLoc = {line: 1, column: 0};

    while (currentToken) {
        tokens.push(currentToken);
        currentToken.__loc = previousLoc;

        var newlineCount = currentToken.getNewlineCount();
        if (newlineCount &#x3e; 0) {
            var lines = currentToken.getSourceCodeLines();
            previousLoc = {
                line: previousLoc.line + newlineCount,
                column: lines[lines.length - 1].length
            };
        } else {
            previousLoc = {
                line: previousLoc.line,
                column: previousLoc.column + currentToken.getSourceCodeLength()
            };
        }

        if (currentToken.isComment) {
            var value = currentToken.value;
            var blockMatch = BLOCK_REGEXP.exec(value);
            if (blockMatch) {
                this._hasPragmas = true;
                lastBlockState = assign({}, lastBlockState, parseRuleNames(blockMatch[2], blockMatch[1] === &#x27;en&#x27;));
                tokenState = lastBlockState;
            } else {
                var lineMatch = LINE_REGEXP.exec(value);
                if (lineMatch) {
                    this._hasPragmas = true;
                    var ignoreState = parseRuleNames(lineMatch[1], false);
                    index.push(null);
                    var ignoreToken = currentToken.getPreviousToken();
                    var i = index.length - 1;
                    while (ignoreToken) {
                        i--;
                        index[i] = assign({}, index[i], ignoreState);
                        if (ignoreToken.getNewlineCount() &#x3e; 0) {
                            break;
                        }
                        ignoreToken = ignoreToken.getPreviousToken();
                    }
                    ignoreToken = currentToken.getNextToken();
                    while (ignoreToken) {
                        index.push(ignoreState);
                        if (ignoreToken.getNewlineCount() &#x3e; 0) {
                            break;
                        }
                        ignoreToken = ignoreToken.getNextToken();
                    }
                    tokenState = assign({}, lastBlockState, ignoreState);
                } else {
                    tokenState = lastBlockState;
                }
            }
        } else {
            tokenState = lastBlockState;
        }

        if (index[currentPosition]) {
            tokenState = assign({}, tokenState, index[currentPosition]);
        }

        index[currentPosition] = tokenState;
        currentPosition++;

        currentToken = currentToken.getNextToken();
    }
    this._tokens = tokens;
    this._index = index;
    this._positions = positions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Pragma index implementation.
* Checks if rule is enabled or disabled for the specified element.
*
* @param {Element} firstToken
* @constructor
*/
function TokenIndex(firstToken) {
   this.<span class="apidocCodeKeywordSpan">_buildIndex</span>(firstToken);
}

/**
* Builds pragma index.
*
* @param {Element} firstToken
* @private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_index.prototype.getElementLoc" id="apidoc.element.jscs.token_index.prototype.getElementLoc">
        function <span class="apidocSignatureSpan">jscs.token_index.prototype.</span>getElementLoc
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getElementLoc = function (element) {
    return element.getFirstToken().__loc ||  {
        line: 1,
        column: 0
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else if (element.getSourceCodeLength() === 1) {
        offset = 0;
    } else {
        offset = (element.getNewlineCount() === 0 &#x26;&#x26; Math.ceil(element.getSourceCodeLength() / 2)) || 0;
    }
}

var pos = tokenIndex ? tokenIndex.<span class="apidocCodeKeywordSpan">getElementLoc</span>(element) : element.getLoc().start;
if (!pos) {
    return EMPTY_POS;
}

if (offset === 0) {
    return pos;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_index.prototype.isRuleEnabled" id="apidoc.element.jscs.token_index.prototype.isRuleEnabled">
        function <span class="apidocSignatureSpan">jscs.token_index.prototype.</span>isRuleEnabled
        <span class="apidocSignatureSpan">(ruleName, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRuleEnabled = function (ruleName, element) {
    if (!this._hasPragmas) {
        return true;
    }
    var pos = this._tokens.indexOf(element.getFirstToken());
    if (pos !== -1) {
        var state = this._index[pos];
        if (ruleName in state) {
            return state[ruleName];
        }

        return state[&#x27;*&#x27;];
    }

    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

var program = file.getProgram();
var tokenIndex = new TokenIndex(program.getFirstToken());
errors.calculateErrorLocations(tokenIndex);
errors.filter(function(error) {
    if (error.element) {
        return tokenIndex.<span class="apidocCodeKeywordSpan">isRuleEnabled</span>(error.rule, error.element);
    } else {
        return true;
    }
});

// sort errors list to show errors as they appear in source
errors.getErrorList().sort(function(a, b) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.tree_iterator" id="apidoc.module.jscs.tree_iterator">module jscs.tree_iterator</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.tree_iterator.iterate" id="apidoc.element.jscs.tree_iterator.iterate">
        function <span class="apidocSignatureSpan">jscs.tree_iterator.</span>iterate
        <span class="apidocSignatureSpan">(node, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function iterate(node, cb) {
    if (&#x27;type&#x27; in node) {
        estraverse.traverse(node, {
            enter: function(node, parent) {
                var parentCollection = [];

                // parentCollection support
                var path = this.path();
                if (path) {
                    var collectionKey;
                    while (path.length &#x3e; 0) {
                        var pathElement = path.pop();
                        if (typeof pathElement === &#x27;string&#x27;) {
                            collectionKey = pathElement;
                            break;
                        }
                    }

                    parentCollection = parent[collectionKey];
                    if (!Array.isArray(parentCollection)) {
                        parentCollection = [parentCollection];
                    }
                }

                if (cb(node, parent, parentCollection) === false) {
                    return estraverse.VisitorOption.Skip;
                }
            },
            keys: VISITOR_KEYS
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Iterates through the token tree using tree iterator.
 * Calls passed function for every token.
 *
 * @param {Function} cb
 * @param {Object} [tree]
 */
iterate: function(cb, tree) {
    return treeIterator.<span class="apidocCodeKeywordSpan">iterate</span>(tree || this._program, cb);
},

/**
 * Returns nodes by type(s) from earlier built index.
 *
 * @param {String|String[]} type
 * @returns {Object[]}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.utils" id="apidoc.module.jscs.utils">module jscs.utils</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.utils.getFunctionNodeFromIIFE" id="apidoc.element.jscs.utils.getFunctionNodeFromIIFE">
        function <span class="apidocSignatureSpan">jscs.utils.</span>getFunctionNodeFromIIFE
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFunctionNodeFromIIFE = function (node) {
    if (node.type !== &#x27;CallExpression&#x27;) {
        return null;
    }

    var callee = node.callee;

    if (callee.type === &#x27;FunctionExpression&#x27;) {
        return callee;
    }

    if (callee.type === &#x27;MemberExpression&#x27; &#x26;&#x26;
        callee.object.type === &#x27;FunctionExpression&#x27; &#x26;&#x26;
        callee.property.type === &#x27;Identifier&#x27; &#x26;&#x26;
        (callee.property.name === &#x27;call&#x27; || callee.property.name === &#x27;apply&#x27;)
    ) {
        return callee.object;
    }

    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var closingParensToken = file.getNextToken(file.getLastNodeToken(node));
var closingTokenValue = closingParensToken ? closingParensToken.value : &#x27;&#x27;;

return openParensToken.value + closingTokenValue === &#x27;()&#x27;;
        }

        file.iterateNodesByType(&#x27;CallExpression&#x27;, function(node) {
var inner = utils.<span class="apidocCodeKeywordSpan">getFunctionNodeFromIIFE</span>(node);

if (inner &#x26;&#x26; !isWrapped(inner) &#x26;&#x26; !isWrapped(node)) {
    errors.add(
        &#x27;Wrap immediately invoked function expressions in parentheses&#x27;,
        node
    );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.utils.isPragma" id="apidoc.element.jscs.utils.isPragma">
        function <span class="apidocSignatureSpan">jscs.utils.</span>isPragma
        <span class="apidocSignatureSpan">(additionalExceptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPragma = function (additionalExceptions) {
    var pragmaKeywords = [
        &#x27;eslint&#x27;,
        &#x27;eslint-env&#x27;,
        &#x27;eslint-enable&#x27;,
        &#x27;eslint-disable&#x27;,
        &#x27;eslint-disable-line&#x27;,
        &#x27;eslint-disable-next-line&#x27;,
        &#x27;global&#x27;,
        &#x27;jshint&#x27;,
        &#x27;jslint&#x27;,
        &#x27;globals&#x27;,
        &#x27;falls through&#x27;,
        &#x27;exported&#x27;,
        &#x27;jscs:&#x27;,
        &#x27;jscs:enable&#x27;,
        &#x27;jscs:disable&#x27;,
        &#x27;jscs:ignore&#x27;,
        &#x27;istanbul&#x27;
    ];
    if (additionalExceptions &#x26;&#x26; Array.isArray(additionalExceptions)) {
        pragmaKeywords = pragmaKeywords.concat(additionalExceptions);
    }

    return function(comment) {
        // pragmaKeywords precede a space or the end of the comment
        var trimmedComment = comment.trim() + &#x27; &#x27;;
        for (var i = 0; i &#x3c; pragmaKeywords.length; i++) {
            if (trimmedComment.indexOf(pragmaKeywords[i] + &#x27; &#x27;) === 0) {
                return true;
            }
        }
        return false;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.utils.isRelativePath" id="apidoc.element.jscs.utils.isRelativePath">
        function <span class="apidocSignatureSpan">jscs.utils.</span>isRelativePath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRelativePath = function (path) {
    // Logic from: https://github.com/joyent/node/blob/4f1ae11a62b97052bc83756f8cb8700cc1f61661/lib/module.js#L237
    var start = path.substring(0, 2);
    return start === &#x27;./&#x27; || start === &#x27;..&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * or just returns the filepath if not relative
 *
 * @param  {String} filepath
 * @param  {String} basePath
 * @return {String}
 */
exports.normalizePath = function(filepath, basePath) {
    if (this.<span class="apidocCodeKeywordSpan">isRelativePath</span>(filepath)) {
        return path.resolve(basePath, filepath);
    }

    return filepath;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.utils.isSnakeCased" id="apidoc.element.jscs.utils.isSnakeCased">
        function <span class="apidocSignatureSpan">jscs.utils.</span>isSnakeCased
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSnakeCased = function (name) {
    return SNAKE_CASE_RE.test(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var value = node.property.value;
if (// allow numbers, nulls, and anything else
    typeof value !== &#x27;string&#x27; ||
    // allow invalid identifiers
    !utils.isValidIdentifierName(value, file.getDialect()) ||
    // allow quoted snake cased identifiers if allExcept: [&#x27;snake_case&#x27;]
    (exceptSnakeCase &#x26;&#x26; utils.<span class="apidocCodeKeywordSpan">isSnakeCased</span>(utils.trimUnderscores(value))) ||
    // allow quoted reserved words if allExcept: [&#x27;keywords&#x27;]
    ((dialect === &#x27;es3&#x27; || exceptKeywords) &#x26;&#x26; reservedWords.check(value, dialect, true))
) {
    return;
}

errors.add(&#x27;Use dot notation instead of brackets for member expressions&#x27;, node.property);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.utils.isValidIdentifierName" id="apidoc.element.jscs.utils.isValidIdentifierName">
        function <span class="apidocSignatureSpan">jscs.utils.</span>isValidIdentifierName
        <span class="apidocSignatureSpan">(name, dialect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidIdentifierName = function (name, dialect) {
    dialect = dialect || &#x27;es5&#x27;;
    var identifierRegex = dialect === &#x27;es5&#x27; ? IDENTIFIER_NAME_ES5_RE : IDENTIFIER_NAME_ES6_RE;
    return !reservedWords.check(name, dialect, true) &#x26;&#x26; identifierRegex.test(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
}

var value = node.property.value;
if (// allow numbers, nulls, and anything else
    typeof value !== &#x27;string&#x27; ||
    // allow invalid identifiers
    !utils.<span class="apidocCodeKeywordSpan">isValidIdentifierName</span>(value, file.getDialect()) ||
    // allow quoted snake cased identifiers if allExcept: [&#x27;snake_case&#x27;]
    (exceptSnakeCase &#x26;&#x26; utils.isSnakeCased(utils.trimUnderscores(value))) ||
    // allow quoted reserved words if allExcept: [&#x27;keywords&#x27;]
    ((dialect === &#x27;es3&#x27; || exceptKeywords) &#x26;&#x26; reservedWords.check(value, dialect, true))
) {
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.utils.normalizePath" id="apidoc.element.jscs.utils.normalizePath">
        function <span class="apidocSignatureSpan">jscs.utils.</span>normalizePath
        <span class="apidocSignatureSpan">(filepath, basePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizePath = function (filepath, basePath) {
    if (this.isRelativePath(filepath)) {
        return path.resolve(basePath, filepath);
    }

    return filepath;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param  {String} path - The path containing file(s) used to guide the configuration
 *
 * @return {Promise} Resolved with the generated, JSCS configuration
 */
Generator.prototype.generate = function(path) {
var checker = getChecker();
var _path = utils.<span class="apidocCodeKeywordSpan">normalizePath</span>(path, checker.getConfiguration().getBasePath());
var presetNames = Object.keys(checker.getConfiguration().getRegisteredPresets());
var statsForPresets;

console.log(&#x27;Checking&#x27;, _path, &#x27;against the presets&#x27;);

return Vow
.all(presetNames.map(this._checkAgainstPreset.bind(this, _path)))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.utils.promisify" id="apidoc.element.jscs.utils.promisify">
        function <span class="apidocSignatureSpan">jscs.utils.</span>promisify
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">promisify = function (fn) {
    return function() {
        var deferred = Vow.defer();
        var args = [].slice.call(arguments);

        args.push(function(err, result) {
            if (err) {
                deferred.reject(err);
            } else {
                deferred.resolve(result);
            }
        });

        fn.apply(null, args);

        return deferred.promise();
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Promise}
 */
Generator.prototype._getUserViolationChoices = function(errorPrompts) {
    return this._showPrompt(errorPrompts);
};

/** @private */
Generator.prototype._showPrompt = utils.<span class="apidocCodeKeywordSpan">promisify</span>(prompt.get.bind(prompt));

/**
 * @private
 * @param  {Object[]} errorPrompts
 * @param  {Object} choices
 */
Generator.prototype._handleViolatedRules = function(errorPrompts, choices) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.utils.trimUnderscores" id="apidoc.element.jscs.utils.trimUnderscores">
        function <span class="apidocSignatureSpan">jscs.utils.</span>trimUnderscores
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trimUnderscores = function (name) {
    var res = name.replace(TRAILING_UNDERSCORES_RE, &#x27;&#x27;);
    return res ? res : name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var value = node.property.value;
if (// allow numbers, nulls, and anything else
    typeof value !== &#x27;string&#x27; ||
    // allow invalid identifiers
    !utils.isValidIdentifierName(value, file.getDialect()) ||
    // allow quoted snake cased identifiers if allExcept: [&#x27;snake_case&#x27;]
    (exceptSnakeCase &#x26;&#x26; utils.isSnakeCased(utils.<span class="apidocCodeKeywordSpan">trimUnderscores</span>(value))) ||
    // allow quoted reserved words if allExcept: [&#x27;keywords&#x27;]
    ((dialect === &#x27;es3&#x27; || exceptKeywords) &#x26;&#x26; reservedWords.check(value, dialect, true))
) {
    return;
}

errors.add(&#x27;Use dot notation instead of brackets for member expressions&#x27;, node.property);
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_aligned_function_parameters" id="apidoc.module.jscs.validate_aligned_function_parameters">module jscs.validate_aligned_function_parameters</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_aligned_function_parameters.validate_aligned_function_parameters" id="apidoc.element.jscs.validate_aligned_function_parameters.validate_aligned_function_parameters">
        function <span class="apidocSignatureSpan">jscs.</span>validate_aligned_function_parameters
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_aligned_function_parameters = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_aligned_function_parameters.prototype" id="apidoc.module.jscs.validate_aligned_function_parameters.prototype">module jscs.validate_aligned_function_parameters.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_aligned_function_parameters.prototype.check" id="apidoc.element.jscs.validate_aligned_function_parameters.prototype.check">
        function <span class="apidocSignatureSpan">jscs.validate_aligned_function_parameters.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var lineBreakAfterOpeningBrace = this._lineBreakAfterOpeningBrace;
    var lineBreakBeforeClosingBrace = this._lineBreakBeforeClosingBrace;

    file.iterateNodesByType([
        &#x27;FunctionDeclaration&#x27;,
        &#x27;FunctionExpression&#x27;,
        &#x27;ArrowFunctionExpression&#x27;
    ], function(node) {

        // ignore this rule if there are no parameters
        if (node.params.length === 0) {
            return;
        }

        // ignore this rule if the parameters are not multi-line
        var firstParameter = file.getFirstNodeToken(node.params[0]);
        var lastParameter = node.params[node.params.length - 1];
        if (file.isOnTheSameLine(firstParameter, lastParameter)) {
            return;
        }

        // look for the furthest parameter start position
        var maxParamStartPos = 0;
        node.params.forEach(function(parameter) {
            maxParamStartPos = Math.max(maxParamStartPos, parameter.getLoc().start.column);
        });

        // make sure all parameters are lined up
        node.params.forEach(function(parameter) {
            if (parameter.getLoc().start.column !== maxParamStartPos) {
                errors.add(&#x27;Multi-line parameters are not aligned.&#x27;, parameter);
            }
        });

        // make sure the first parameter is on a new line
        if (lineBreakAfterOpeningBrace) {
            var openingBrace = file.getPrevToken(firstParameter);
            errors.assert.differentLine({
                token: openingBrace,
                nextToken: firstParameter,
                message: &#x27;There is no line break after the opening brace&#x27;
            });
        }

        // make sure the closing brace is on a new line
        if (lineBreakBeforeClosingBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            var closingBrace = file.getPrevToken(bodyToken);
            errors.assert.differentLine({
                token: lastParameter,
                nextToken: closingBrace,
                message: &#x27;There is no line break before the closing brace&#x27;
            });
        }

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_aligned_function_parameters.prototype.configure" id="apidoc.element.jscs.validate_aligned_function_parameters.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.validate_aligned_function_parameters.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var validProperties = [
        &#x27;lineBreakAfterOpeningBrace&#x27;,
        &#x27;lineBreakBeforeClosingBrace&#x27;
    ];
    var optionName = this.getOptionName();

    assert(
        typeof options === &#x27;object&#x27; || options === true,
        optionName + &#x27; option must be an object or boolean true&#x27;
    );

    if (typeof options === &#x27;object&#x27;) {
        validProperties.forEach(function(key) {
            var isPresent = key in options;

            if (isPresent) {
                assert(
                    options[key] === true,
                    optionName + &#x27;.&#x27; + key + &#x27; property requires true value or should be removed&#x27;
                );
            }
        });

        validProperties.forEach(function(property) {
            this[&#x27;_&#x27; + property] = Boolean(options[property]);
        }.bind(this));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_aligned_function_parameters.prototype.getOptionName" id="apidoc.element.jscs.validate_aligned_function_parameters.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.validate_aligned_function_parameters.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;validateAlignedFunctionParameters&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_comment_position" id="apidoc.module.jscs.validate_comment_position">module jscs.validate_comment_position</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_comment_position.validate_comment_position" id="apidoc.element.jscs.validate_comment_position.validate_comment_position">
        function <span class="apidocSignatureSpan">jscs.</span>validate_comment_position
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_comment_position = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_comment_position.prototype" id="apidoc.module.jscs.validate_comment_position.prototype">module jscs.validate_comment_position.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_comment_position.prototype.check" id="apidoc.element.jscs.validate_comment_position.prototype.check">
        function <span class="apidocSignatureSpan">jscs.validate_comment_position.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var position = this._position;
    var isExcepted = this._isExcepted;
    file.iterateTokensByType(&#x27;CommentLine&#x27;, function(comment) {
        if (isExcepted(comment.value)) {
            return;
        }

        var isFirstToken = true;
        var currentToken = comment.getPreviousToken();
        while (currentToken) {
            if (currentToken.isWhitespace) {
                if (currentToken.getNewlineCount() &#x3e; 0) {
                    break;
                }
            } else {
                isFirstToken = false;
            }

            currentToken = currentToken.getPreviousToken();
        }

        if (position === &#x27;above&#x27; &#x26;&#x26; !isFirstToken) {
            errors.add(&#x27;Expected comments to be above the code not beside&#x27;, comment);
        }
        if (position === &#x27;beside&#x27; &#x26;&#x26; isFirstToken) {
            errors.add(&#x27;Expected comments to be beside the code not above&#x27;, comment);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_comment_position.prototype.configure" id="apidoc.element.jscs.validate_comment_position.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.validate_comment_position.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var validPositions = {
        &#x27;above&#x27;: &#x27;above&#x27;,
        &#x27;beside&#x27;: &#x27;beside&#x27;
    };
    var allExcept = options.allExcept;
    assert(
        typeof options === &#x27;object&#x27; &#x26;&#x26; validPositions[options.position],
        this.getOptionName() + &#x27; requires one of the following values: &#x27; + Object.keys(validPositions).join(&#x27;, &#x27;)
    );
    if (Array.isArray(allExcept)) {
        assert(
            allExcept.every(function(el) { return typeof el === &#x27;string&#x27;; }),
            &#x27;Property `allExcept` in &#x27; + allExcept + &#x27; should be an array of strings&#x27;
        );
        this._isExcepted = isPragma(allExcept);
    } else {
        this._isExcepted  = isPragma();
    }
    this._position = options.position;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_comment_position.prototype.getOptionName" id="apidoc.element.jscs.validate_comment_position.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.validate_comment_position.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;validateCommentPosition&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_indentation" id="apidoc.module.jscs.validate_indentation">module jscs.validate_indentation</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.validate_indentation" id="apidoc.element.jscs.validate_indentation.validate_indentation">
        function <span class="apidocSignatureSpan">jscs.</span>validate_indentation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_indentation = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_indentation.prototype" id="apidoc.module.jscs.validate_indentation.prototype">module jscs.validate_indentation.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.prototype._checkNode" id="apidoc.element.jscs.validate_indentation.prototype._checkNode">
        function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_checkNode
        <span class="apidocSignatureSpan">(parentElement, errors, initialIndent, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkNode = function (parentElement, errors, initialIndent, options) {
    var moduleBody = options.moduleBody;
    var firstWhitespace = options.firstWhitespace;
    var isBlock = false;
    var isModuleBody = false;
    var checkBlockIndentation = false;
    var indent = initialIndent;
    var isSwitchStatement = parentElement.type === &#x27;SwitchStatement&#x27;;
    var calculateFunctionExpressionIndent = null;
    var indentCases = null;

    if (isSwitchStatement) {
        indent++;
        isBlock = true;
        checkBlockIndentation = true;
    }
    if (parentElement.type === &#x27;Program&#x27;) {
        checkBlockIndentation = true;
    }
    if (parentElement.type === &#x27;BlockStatement&#x27;) {
        indent++;
        isBlock = true;
        checkBlockIndentation = true;
        isModuleBody = parentElement === moduleBody;
        if (isModuleBody &#x26;&#x26; this._indentModuleBodies === false) {
            indent--;
        } else if (parentElement.parentElement.type === &#x27;SwitchCase&#x27;) {
            // Avoiding additional indentation if `{` is on the same line with case block start
            if (isBlockOnTheSameLineWithCase(parentElement)) {
                indent--;
            }
        } else {
            // Calculating indentation for function expressions.
            calculateFunctionExpressionIndent = isFunctionExpression(parentElement.parentElement);
            if (calculateFunctionExpressionIndent) {
                indent = this._getFunctionIndent(parentElement.parentElement, indent);
            }
        }
    }
    if (parentElement.type === &#x27;ClassBody&#x27;) {
        indent++;
        isBlock = true;
        checkBlockIndentation = true;
    }
    if (parentElement.type === &#x27;SwitchCase&#x27;) {
        indent++;
        checkBlockIndentation = true;
    }
    if (parentElement.type === &#x27;ObjectExpression&#x27;) {
        indent++;
        indent = this._getObjectExpressionIndent(parentElement, indent);
        isBlock = true;
        checkBlockIndentation = true;
    }
    var nonBlockChecks = nonBlockIndentChecks[parentElement.type];
    var statementsToCheck;
    if (nonBlockChecks) {
        statementsToCheck = nonBlockChecks.filter(function(propName) {
            return parentElement[propName] &#x26;&#x26; parentElement[propName].type !== &#x27;BlockStatement&#x27;;
        });
    }

    var element = parentElement.firstChild;
    while (element) {
        if (element.isToken) {
            var isFirstWhitespace = element === firstWhitespace;
            if (element.isWhitespace &#x26;&#x26; (element.getNewlineCount() &#x3e; 0 || isFirstWhitespace)) {
                var lines = getLineData(element.getSourceCode());
                var lineOffset = this._includeEmptyLines ?
                    (isFirstWhitespace ? 0 : 1) :
                    lines.length - 1;
                lines = lines.slice(lineOffset);

                for (var i = 0; i &#x3c; lines.length; i++) {
                    var line = lines[i].line;
                    if (line.indexOf(this._nonIndentChar) !== -1) {
                        errors.add(
                            &#x27;Invalid indentation character: &#x27; + this._nonIndentChar,
                            element,
                            lines[i].offset
                        );
                    }
                    var nextSibling = element.nextSibling;
                    var checkForStatement = false;
                    var checkForKeyword = false;
                    if (!checkBlockIndentation) {
                        if (statementsToCheck &#x26;&#x26; statementsToCheck.length &#x3e; 0) {
                            if (statementsToCheck.indexOf(nextSibling) !== -1) {
                                checkForStatement = true;
                            }
                        }
                        var nextToken = element.getNextToken();
                        if (nextToken &#x26;&#x26;
                            nextToken.isToken &#x26;&#x26;
                            nextToken.type === &#x27;Keyword&#x27; &#x26;&#x26;
                            keywordsToCheck[nextToken.value]
                        ) {
                            checkForKeyword = true;
                        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                                }
                            });
                        }
                    }
                }
            }
        } else {
            this.<span class="apidocCodeKeywordSpan">_checkNode</span>(element, errors, indent, options);
        }
        element = element.nextSibling;
    }
},

check: function(file, errors) {
    var program = file.getProgram();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.prototype._fix" id="apidoc.element.jscs.validate_indentation.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var indentChar = this._indentChar;
    var whitespaceToken = error.element;

    var fixData = error.additional;
    var indentDiff = fixData.indentDiff;

    var lineItemsData = getLineData(whitespaceToken.value);
    var lineItemToFix = lineItemsData[fixData.line];
    if (lineItemToFix) {
        var originalIndentLength = lineItemToFix.line.length;
        var finalIndentLength = originalIndentLength + indentDiff;
        lineItemToFix.line = new Array(finalIndentLength + 1).join(indentChar);
        var newWhitespaceToken = new cst.Token(
            &#x27;Whitespace&#x27;,
            convertLinesToString(lineItemsData)
        );
        whitespaceToken.parentElement.replaceChild(newWhitespaceToken, whitespaceToken);

        var adjustElement = fixData.adjustElement;
        if (adjustElement &#x26;&#x26; adjustElement.getNewlineCount() &#x3e; 0) {
            var currentToken = adjustElement.getFirstToken();
            var lastToken = adjustElement.getLastToken();
            while (true) {
                var nextToken = currentToken.getNextToken();
                if (currentToken.isWhitespace &#x26;&#x26; currentToken.getNewlineCount() &#x3e; 0) {
                    var newSubWhitespaceToken = new cst.Token(
                        currentToken.type,
                        applyIndentationDiff(currentToken.value, indentDiff, indentChar, this._includeEmptyLines)
                    );
                    currentToken.parentElement.replaceChild(newSubWhitespaceToken, currentToken);
                }
                if (currentToken.isComment &#x26;&#x26; currentToken.getNewlineCount() &#x3e; 0) {
                    var prev = currentToken.getPreviousToken();
                    var commentIndent = 0;
                    if (prev.isWhitespace &#x26;&#x26; prev.getNewlineCount() &#x3e; 0) {
                        commentIndent = prev.getSourceCodeLines().concat().pop().length;
                    }
                    var commentDiff = indentDiff &#x3c; 0 &#x26;&#x26; commentIndent &#x3c; -indentDiff ?
                        -commentIndent :
                        indentDiff;
                    var newCommentToken = new cst.Token(
                        currentToken.type,
                        applyIndentationDiff(
                            currentToken.value,
                            commentDiff,
                            indentChar,
                            this._includeEmptyLines
                        )
                    );
                    currentToken.parentElement.replaceChild(newCommentToken, currentToken);
                }
                if (currentToken === lastToken) {
                    break;
                }
                currentToken = nextToken;
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &#x26;&#x26; instance._fix) {
        // &#x22;error.fixed = true&#x22; should go first, so rule can
        // decide for itself (with &#x22;error.fixed = false&#x22;)
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.prototype._getElementDirectIndent" id="apidoc.element.jscs.validate_indentation.prototype._getElementDirectIndent">
        function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_getElementDirectIndent
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getElementDirectIndent = function (node) {
    var whitespaceToken = node.getPreviousToken();
    if (whitespaceToken.isWhitespace &#x26;&#x26; whitespaceToken.getNewlineCount() &#x3e; 0) {
        var endTokenLines = whitespaceToken.getSourceCodeLines();
        return Math.floor(endTokenLines[endTokenLines.length - 1].length / this._indentSize);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {FunctionExpression|ArrowFunctionExpression} functionExpression
 * @param {Number} indent
 * @returns {Number}
 * @private
 */
_getFunctionIndent: function(functionExpression, indent) {
    var functionIndent = 0;
    var indentBeforeClosingBrace = this.<span class="apidocCodeKeywordSpan">_getElementDirectIndent</span>(functionExpression.body
.lastChild);
    if (indentBeforeClosingBrace !== null) {
        functionIndent = indentBeforeClosingBrace + 1;
    }
    var indentBeforeFunction = this._getElementDirectIndent(functionExpression);
    if (indentBeforeFunction !== null) {
        functionIndent = Math.min(functionIndent, indentBeforeFunction  + 1);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.prototype._getFunctionIndent" id="apidoc.element.jscs.validate_indentation.prototype._getFunctionIndent">
        function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_getFunctionIndent
        <span class="apidocSignatureSpan">(functionExpression, indent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getFunctionIndent = function (functionExpression, indent) {
    var functionIndent = 0;
    var indentBeforeClosingBrace = this._getElementDirectIndent(functionExpression.body.lastChild);
    if (indentBeforeClosingBrace !== null) {
        functionIndent = indentBeforeClosingBrace + 1;
    }
    var indentBeforeFunction = this._getElementDirectIndent(functionExpression);
    if (indentBeforeFunction !== null) {
        functionIndent = Math.min(functionIndent, indentBeforeFunction  + 1);
    }
    return Math.max(indent, functionIndent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (isBlockOnTheSameLineWithCase(parentElement)) {
            indent--;
        }
    } else {
        // Calculating indentation for function expressions.
        calculateFunctionExpressionIndent = isFunctionExpression(parentElement.parentElement);
        if (calculateFunctionExpressionIndent) {
            indent = this.<span class="apidocCodeKeywordSpan">_getFunctionIndent</span>(parentElement.parentElement, indent);
        }
    }
}
if (parentElement.type === &#x27;ClassBody&#x27;) {
    indent++;
    isBlock = true;
    checkBlockIndentation = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.prototype._getObjectExpressionIndent" id="apidoc.element.jscs.validate_indentation.prototype._getObjectExpressionIndent">
        function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_getObjectExpressionIndent
        <span class="apidocSignatureSpan">(objectExpression, indent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getObjectExpressionIndent = function (objectExpression, indent) {
    var objectIndent = 0;
    var properties = objectExpression.properties;

    // Handling nested one-line objects, i.e. `{prop: {\n`
    if (objectExpression.parentElement.type === &#x27;ObjectProperty&#x27;) {
        var parentObjectExpressionBrace = objectExpression.parentElement.parentElement.firstChild;
        var currentToken = objectExpression.getPreviousToken();
        while (currentToken) {
            if (currentToken === parentObjectExpressionBrace) {
                indent--;
                break;
            }
            if (currentToken.getNewlineCount() &#x3e; 0) {
                break;
            }
            currentToken = currentToken.getPreviousToken();
        }
    }
    for (var i = 0; i &#x3c; properties.length; i++) {
        var property = properties[i];
        objectIndent = this._getElementDirectIndent(property);
        if (objectIndent !== null) {
            break;
        }

    }
    return Math.max(indent, objectIndent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (parentElement.type === &#x27;SwitchCase&#x27;) {
    indent++;
    checkBlockIndentation = true;
}
if (parentElement.type === &#x27;ObjectExpression&#x27;) {
    indent++;
    indent = this.<span class="apidocCodeKeywordSpan">_getObjectExpressionIndent</span>(parentElement, indent);
    isBlock = true;
    checkBlockIndentation = true;
}
var nonBlockChecks = nonBlockIndentChecks[parentElement.type];
var statementsToCheck;
if (nonBlockChecks) {
    statementsToCheck = nonBlockChecks.filter(function(propName) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.prototype.check" id="apidoc.element.jscs.validate_indentation.prototype.check">
        function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var program = file.getProgram();
    var firstWhitespace;
    if (program.getFirstToken().isWhitespace) {
        firstWhitespace = program.getFirstToken();
    }
    this._checkNode(program, errors, 0, {
        moduleBody: getModuleBody(program),
        firstWhitespace: firstWhitespace
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.prototype.configure" id="apidoc.element.jscs.validate_indentation.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    this._includeEmptyLines = false;
    this._exceptComments = false;

    if (typeof options === &#x27;object&#x27;) {
        this._includeEmptyLines = (options.includeEmptyLines === true);
        if (Array.isArray(options.allExcept)) {
            this._exceptComments = options.allExcept.indexOf(&#x27;comments&#x27;) &#x3e; -1;
            this._includeEmptyLines = options.allExcept.indexOf(&#x27;emptyLines&#x27;) === -1;
        }

        options = options.value;
    }

    assert(
        options === &#x27;\t&#x27; ||
            (typeof options === &#x27;number&#x27; &#x26;&#x26; options &#x3e; 0),
        this.getOptionName() + &#x27; option requires a positive number of spaces or &#x22;\\t&#x22;&#x27; +
        &#x27; or options object with &#x22;value&#x22; property&#x27;
    );

    if (typeof options === &#x27;number&#x27;) {
        this._indentChar = &#x27; &#x27;;
        this._nonIndentChar = &#x27;\t&#x27;;
        this._indentSize = options;
    } else {
        this._nonIndentChar = &#x27; &#x27;;
        this._indentChar = &#x27;\t&#x27;;
        this._indentSize = 1;
    }

    this._indentBreaks = null;
    this._indentModuleBodies = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.prototype.getOptionName" id="apidoc.element.jscs.validate_indentation.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;validateIndentation&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_line_breaks" id="apidoc.module.jscs.validate_line_breaks">module jscs.validate_line_breaks</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_line_breaks.validate_line_breaks" id="apidoc.element.jscs.validate_line_breaks.validate_line_breaks">
        function <span class="apidocSignatureSpan">jscs.</span>validate_line_breaks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_line_breaks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_line_breaks.prototype" id="apidoc.module.jscs.validate_line_breaks.prototype">module jscs.validate_line_breaks.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_line_breaks.prototype.check" id="apidoc.element.jscs.validate_line_breaks.prototype.check">
        function <span class="apidocSignatureSpan">jscs.validate_line_breaks.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var lines = file.getLines();
    if (lines.length &#x3c; 2) {
        return;
    }

    file.getProgram().selectTokensByType(&#x27;Whitespace&#x27;).some(function(whitespace) {
        LINE_BREAKS.lastIndex = 0;
        var match;
        while ((match = LINE_BREAKS.exec(whitespace.value)) !== null) {
            if (match[0] !== this._allowedLineBreak) {
                errors.add(&#x27;Invalid line break&#x27;, whitespace, match.index);
                return this._reportOncePerFile;
            }
        }
    }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_line_breaks.prototype.configure" id="apidoc.element.jscs.validate_line_breaks.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.validate_line_breaks.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === &#x27;string&#x27; || typeof options === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option requires string or object value&#x27;
    );

    if (typeof options === &#x27;string&#x27;) {
        options = { character: options };
    }

    var lineBreaks = {
        CR: &#x27;\r&#x27;,
        LF: &#x27;\n&#x27;,
        CRLF: &#x27;\r\n&#x27;
    };
    this._allowedLineBreak = lineBreaks[options.character];

    this._reportOncePerFile = options.reportOncePerFile !== false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_line_breaks.prototype.getOptionName" id="apidoc.element.jscs.validate_line_breaks.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.validate_line_breaks.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;validateLineBreaks&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_newline_after_array_elements" id="apidoc.module.jscs.validate_newline_after_array_elements">module jscs.validate_newline_after_array_elements</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_newline_after_array_elements.validate_newline_after_array_elements" id="apidoc.element.jscs.validate_newline_after_array_elements.validate_newline_after_array_elements">
        function <span class="apidocSignatureSpan">jscs.</span>validate_newline_after_array_elements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_newline_after_array_elements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_newline_after_array_elements.prototype" id="apidoc.module.jscs.validate_newline_after_array_elements.prototype">module jscs.validate_newline_after_array_elements.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_newline_after_array_elements.prototype.check" id="apidoc.element.jscs.validate_newline_after_array_elements.prototype.check">
        function <span class="apidocSignatureSpan">jscs.validate_newline_after_array_elements.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var maximum = this._options.maximum;
    var ignoreBrackets = this._options.ignoreBrackets;

    file.iterateNodesByType([&#x27;ArrayExpression&#x27;], function(node) {
        var els = node.elements;
        var firstEl = els[0];
        var lastEl = els[els.length - 1];
        var bracket;
        var elToken;

        if (els.length &#x3c;= maximum &#x26;&#x26; node.getLoc().start.line === node.getLoc().end.line) {
            return;
        }

        if (!ignoreBrackets) {
            if (firstEl &#x26;&#x26; firstEl.getLoc().start.line === node.getLoc().start.line) {
                bracket = file.getFirstNodeToken(node);
                elToken = file.getNextToken(bracket);

                errors.assert.differentLine({
                    token: bracket,
                    nextToken: elToken,
                    message: &#x27;First element should be placed on new line&#x27;
                });
            }
            if (lastEl &#x26;&#x26; lastEl.getLoc().end.line === node.getLoc().end.line) {
                bracket = file.getLastNodeToken(node);
                elToken = file.getPrevToken(bracket);

                errors.assert.differentLine({
                    token: elToken,
                    nextToken: bracket,
                    message: &#x27;Closing bracket should be placed on new line&#x27;
                });
            }
        }

        els.forEach(function(elem) {
            var elToken;
            var comma;

            if (!elem) {
                // skip holes
                return;
            }

            if (firstEl !== elem) {
                elToken = file.getFirstNodeToken(elem);
                comma = file.getPrevToken(elToken);

                errors.assert.differentLine({
                    token: comma,
                    nextToken: elToken,
                    message: &#x27;Multiple elements at a single line in multiline array&#x27;
                });
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_newline_after_array_elements.prototype.configure" id="apidoc.element.jscs.validate_newline_after_array_elements.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.validate_newline_after_array_elements.prototype.</span>configure
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (opts) {
    assert(
        opts === true ||
        typeof opts === &#x27;number&#x27; &#x26;&#x26; opts &#x3e;= 1 ||
        typeof opts === &#x27;object&#x27;,
        this.getOptionName() + &#x27; option requires maximal number of items &#x27; +
            &#x27;or true value either should be removed&#x27;
    );
    if (typeof opts === &#x27;object&#x27;) {
        this._options = {
            maximum: Infinity,
            ignoreBrackets: false
        };

        if (&#x27;maximum&#x27; in opts) {
            assert(typeof opts.maximum === &#x27;number&#x27; &#x26;&#x26; opts.maximum &#x3e;= 1,
                &#x27;maximum property requires a positive number or should be removed&#x27;);
            this._options.maximum = opts.maximum;
        }

        if (&#x27;ignoreBrackets&#x27; in opts) {
            assert(opts.ignoreBrackets === true,
                &#x27;ignoreBrackets property requires true value or should be removed&#x27;);
            this._options.ignoreBrackets = true;
        }
    } else {
        this._options = {
            maximum: opts === true ? Infinity : opts,
            ignoreBrackets: false
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_newline_after_array_elements.prototype.getOptionName" id="apidoc.element.jscs.validate_newline_after_array_elements.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.validate_newline_after_array_elements.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;validateNewlineAfterArrayElements&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_order_in_object_keys" id="apidoc.module.jscs.validate_order_in_object_keys">module jscs.validate_order_in_object_keys</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_order_in_object_keys.validate_order_in_object_keys" id="apidoc.element.jscs.validate_order_in_object_keys.validate_order_in_object_keys">
        function <span class="apidocSignatureSpan">jscs.</span>validate_order_in_object_keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_order_in_object_keys = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_order_in_object_keys.prototype" id="apidoc.module.jscs.validate_order_in_object_keys.prototype">module jscs.validate_order_in_object_keys.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_order_in_object_keys.prototype.check" id="apidoc.element.jscs.validate_order_in_object_keys.prototype.check">
        function <span class="apidocSignatureSpan">jscs.validate_order_in_object_keys.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var sort = this._sort;

    file.iterateNodesByType(&#x27;ObjectExpression&#x27;, function(node) {
        var keys = node.properties.map(function(property) {
            return (property.key.name || property.key.value);
        });

        var sorted = keys.slice(0).sort(sort);
        var unsorted;

        for (var i = 0; i &#x3c; keys.length; i++) {
            if (keys[i] !== sorted[i]) {
                unsorted = i;

                break;
            }
        }

        if (undefined !== unsorted) {
            errors.add(
                &#x27;Object keys must be in &#x27; + (/asc/.test(sort.name) ? &#x27;ascending&#x27; : &#x27;descending&#x27;) + &#x27; order&#x27;,
                node.properties[unsorted]
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_order_in_object_keys.prototype.configure" id="apidoc.element.jscs.validate_order_in_object_keys.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.validate_order_in_object_keys.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || Object.keys(methods).indexOf(options) !== -1,
        this.getOptionName() + &#x27; option requires a true value or should be removed&#x27;
    );

    this._sort = methods[options] || methods.asc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_order_in_object_keys.prototype.getOptionName" id="apidoc.element.jscs.validate_order_in_object_keys.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.validate_order_in_object_keys.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;validateOrderInObjectKeys&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_parameter_separator" id="apidoc.module.jscs.validate_parameter_separator">module jscs.validate_parameter_separator</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_parameter_separator.validate_parameter_separator" id="apidoc.element.jscs.validate_parameter_separator.validate_parameter_separator">
        function <span class="apidocSignatureSpan">jscs.</span>validate_parameter_separator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_parameter_separator = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_parameter_separator.prototype" id="apidoc.module.jscs.validate_parameter_separator.prototype">module jscs.validate_parameter_separator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_parameter_separator.prototype.check" id="apidoc.element.jscs.validate_parameter_separator.prototype.check">
        function <span class="apidocSignatureSpan">jscs.validate_parameter_separator.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {

    var separators = this._separator.split(&#x27;,&#x27;);
    var whitespaceBeforeComma = Boolean(separators.shift());
    var whitespaceAfterComma = Boolean(separators.pop());

    file.iterateNodesByType([
        &#x27;FunctionDeclaration&#x27;,
        &#x27;FunctionExpression&#x27;,
        &#x27;ClassMethod&#x27;
    ], function(node) {

        node.params.forEach(function(paramNode) {

            var prevParamToken = file.getFirstNodeToken(paramNode);
            var punctuatorToken = file.getNextToken(prevParamToken);

            if (punctuatorToken.value === &#x27;,&#x27;) {

                if (whitespaceBeforeComma) {
                    errors.assert.spacesBetween({
                        token: prevParamToken,
                        nextToken: punctuatorToken,
                        exactly: 1,
                        message: &#x27;One space required after function parameter \&#x27;&#x27; + prevParamToken.value + &#x27;\&#x27;&#x27;
                    });
                } else {
                    errors.assert.noWhitespaceBetween({
                        token: prevParamToken,
                        nextToken: punctuatorToken,
                        message: &#x27;Unexpected space after function parameter \&#x27;&#x27; + prevParamToken.value + &#x27;\&#x27;&#x27;
                    });
                }

                var nextParamToken = file.getNextToken(punctuatorToken);

                if (whitespaceAfterComma) {
                    errors.assert.spacesBetween({
                        token: punctuatorToken,
                        nextToken: nextParamToken,
                        exactly: 1,
                        message: &#x27;One space required before function parameter \&#x27;&#x27; + nextParamToken.value + &#x27;\&#x27;&#x27;
                    });
                } else {
                    errors.assert.noWhitespaceBetween({
                        token: punctuatorToken,
                        nextToken: nextParamToken,
                        message: &#x27;Unexpected space before function parameter \&#x27;&#x27; + nextParamToken.value + &#x27;\&#x27;&#x27;
                    });
                }
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_parameter_separator.prototype.configure" id="apidoc.element.jscs.validate_parameter_separator.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.validate_parameter_separator.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === &#x27;string&#x27; &#x26;&#x26; /^[ ]?,[ ]?$/.test(options),
        this.getOptionName() + &#x27; option requires string value containing only a comma and optional spaces&#x27;
    );

    this._separator = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_parameter_separator.prototype.getOptionName" id="apidoc.element.jscs.validate_parameter_separator.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.validate_parameter_separator.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;validateParameterSeparator&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_quote_marks" id="apidoc.module.jscs.validate_quote_marks">module jscs.validate_quote_marks</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_quote_marks.validate_quote_marks" id="apidoc.element.jscs.validate_quote_marks.validate_quote_marks">
        function <span class="apidocSignatureSpan">jscs.</span>validate_quote_marks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_quote_marks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_quote_marks.prototype" id="apidoc.module.jscs.validate_quote_marks.prototype">module jscs.validate_quote_marks.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_quote_marks.prototype._fix" id="apidoc.element.jscs.validate_quote_marks.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.validate_quote_marks.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var token = error.additional;

    var fixer = require(this._quoteMark === &#x27;&#x22;&#x27; ? &#x27;to-double-quotes&#x27; : &#x27;to-single-quotes&#x27;);
    var newToken = cst.Token.createFromToken({
        type: &#x27;String&#x27;,
        value: token.value,
        sourceCode: fixer(token.getSourceCode())
    });

    token.parentElement.replaceChild(newToken, token);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &#x26;&#x26; instance._fix) {
        // &#x22;error.fixed = true&#x22; should go first, so rule can
        // decide for itself (with &#x22;error.fixed = false&#x22;)
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_quote_marks.prototype.check" id="apidoc.element.jscs.validate_quote_marks.prototype.check">
        function <span class="apidocSignatureSpan">jscs.validate_quote_marks.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var quoteMark = this._quoteMark;
    var allowEscape = this._allowEscape;
    var ignoreJSX = this._ignoreJSX;

    var opposite = {
        &#x27;&#x22;&#x27;: &#x27;\&#x27;&#x27;,
        &#x27;\&#x27;&#x27;: &#x27;&#x22;&#x27;
    };
    file.iterateTokensByType(&#x27;String&#x27;, function(token) {
        if (
            ignoreJSX &#x26;&#x26;
            token.parentElement.type === &#x27;StringLiteral&#x27; &#x26;&#x26;
            token.parentElement.parentElement.type === &#x27;JSXAttribute&#x27;
        ) {
            return;
        }

        var str = token.getSourceCode();
        var mark = str[0];
        var stripped = str.substring(1, str.length - 1);

        if (quoteMark === true) {
            quoteMark = mark;
        }

        if (mark !== quoteMark) {
            if (allowEscape &#x26;&#x26; stripped.indexOf(opposite[mark]) &#x3e; -1) {
                return;
            }

            errors.cast({
                message: &#x27;Invalid quote mark found&#x27;,
                element: token,
                additional: token
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule(&#x27;internalError&#x27;);
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_quote_marks.prototype.configure" id="apidoc.element.jscs.validate_quote_marks.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.validate_quote_marks.prototype.</span>configure
        <span class="apidocSignatureSpan">(quoteMark)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (quoteMark) {
    this._allowEscape = false;
    this._ignoreJSX = false;

    if (typeof quoteMark === &#x27;object&#x27;) {
        assert(
            typeof quoteMark.escape === &#x27;boolean&#x27; &#x26;&#x26; quoteMark.mark !== undefined,
            this.getOptionName() + &#x27; option requires the &#x22;escape&#x22; and &#x22;mark&#x22; property to be defined&#x27;
        );
        this._allowEscape = quoteMark.escape;

        if (quoteMark.ignoreJSX) {
            this._ignoreJSX = quoteMark.ignoreJSX;
        }

        quoteMark = quoteMark.mark;
    }

    assert(
        quoteMark === &#x27;&#x22;&#x27; || quoteMark === &#x27;\&#x27;&#x27; || quoteMark === true,
        this.getOptionName() + &#x27; option requires \&#x27;&#x22;\&#x27;, &#x22;\&#x27;&#x22;, or boolean true&#x27;
    );

    assert(
        quoteMark === &#x27;&#x22;&#x27; || quoteMark === &#x27;\&#x27;&#x27; || quoteMark === true,
        this.getOptionName() + &#x27; option requires \&#x27;&#x22;\&#x27;, &#x22;\&#x27;&#x22;, or boolean true&#x27;
    );

    this._quoteMark = quoteMark;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_quote_marks.prototype.getOptionName" id="apidoc.element.jscs.validate_quote_marks.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.validate_quote_marks.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return &#x27;validateQuoteMarks&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don&#x27;t trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
