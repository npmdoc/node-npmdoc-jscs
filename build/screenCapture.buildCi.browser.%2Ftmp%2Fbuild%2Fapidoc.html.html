<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://jscs.info">jscs (v3.0.7)</a>
</h1>
<h4>JavaScript Code Style</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs">module jscs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.jscs">
            function <span class="apidocSignatureSpan"></span>jscs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration">
            function <span class="apidocSignatureSpan">jscs.</span>configuration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_anonymous_functions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_anonymous_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_array_destructuring_return">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_array_destructuring_return
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_arrow_functions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_arrow_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_capitalized_comments">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_capitalized_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_comma_before_line_break">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_comma_before_line_break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_curly_braces">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_curly_braces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_dangling_underscores">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_dangling_underscores
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_empty_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_empty_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_function_declarations">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_function_declarations
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identical_destructuring_names">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_identical_destructuring_names
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identifier_names">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_identifier_names
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_implicit_type_conversion">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_implicit_type_conversion
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_in_comments">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_in_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_on_new_line">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_on_new_line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_mixed_spaces_and_tabs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multi_line_ternary">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multi_line_ternary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_breaks">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_breaks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_strings">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_strings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_spaces">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_spaces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_var_decl">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_var_decl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_named_unassigned_functions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_named_unassigned_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_nested_ternaries">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_nested_ternaries
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_newline_before_block_statements">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_newline_before_block_statements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_node_types">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_node_types
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_not_operators_in_conditionals">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_not_operators_in_conditionals
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_object_keys_on_new_line">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_object_keys_on_new_line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_operator_before_line_break">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_operator_before_line_break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_use_strict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_export">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_export
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_line_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_objects">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_objects
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_parentheses_around_arrow_param
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_quoted_keys_in_objects">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_quoted_keys_in_objects
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_semicolons">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_semicolons
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_shorthand_arrow_functions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_shorthand_arrow_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_binary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_binary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_comma">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_line_comment">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_line_comment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_object_keys">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_object_keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_prefix_unary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_binary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_binary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_block_statements">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_block_statements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_comma">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_object_values">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_object_values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_postfix_unary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_semicolon">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_semicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_between_arguments">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_between_arguments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_anonymous_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_call_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_call_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_conditional_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_for_statement">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_for_statement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_declaration">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_declaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_generator">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_generator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_named_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_array_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_imported_object_braces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_object_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parentheses">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parentheses
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parenthesized_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_template_string_placeholders
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_tabs">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_tabs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_comma">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_whitespace">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_whitespace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_params">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_unused_params
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_variables">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_unused_variables
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_var">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_var
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_yoda_conditions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_yoda_conditions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors">
            function <span class="apidocSignatureSpan">jscs.</span>errors
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator">
            function <span class="apidocSignatureSpan">jscs.</span>generator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file">
            function <span class="apidocSignatureSpan">jscs.</span>js_file
            <span class="apidocSignatureSpan">(params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.jsdoc">
            function <span class="apidocSignatureSpan">jscs.</span>jsdoc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_line_length">
            function <span class="apidocSignatureSpan">jscs.</span>maximum_line_length
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_number_of_lines">
            function <span class="apidocSignatureSpan">jscs.</span>maximum_number_of_lines
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration">
            function <span class="apidocSignatureSpan">jscs.</span>node_configuration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_multiline_params">
            function <span class="apidocSignatureSpan">jscs.</span>require_aligned_multiline_params
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_object_values">
            function <span class="apidocSignatureSpan">jscs.</span>require_aligned_object_values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_anonymous_functions">
            function <span class="apidocSignatureSpan">jscs.</span>require_anonymous_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_array_destructuring">
            function <span class="apidocSignatureSpan">jscs.</span>require_array_destructuring
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_arrow_functions">
            function <span class="apidocSignatureSpan">jscs.</span>require_arrow_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_blocks_on_newline">
            function <span class="apidocSignatureSpan">jscs.</span>require_blocks_on_newline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers">
            function <span class="apidocSignatureSpan">jscs.</span>require_camelcase_or_uppercase_identifiers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments">
            function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors">
            function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors_new">
            function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors_new
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_comma_before_line_break">
            function <span class="apidocSignatureSpan">jscs.</span>require_comma_before_line_break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_curly_braces">
            function <span class="apidocSignatureSpan">jscs.</span>require_curly_braces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dollar_before_jquery_assignment">
            function <span class="apidocSignatureSpan">jscs.</span>require_dollar_before_jquery_assignment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dot_notation">
            function <span class="apidocSignatureSpan">jscs.</span>require_dot_notation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_early_return">
            function <span class="apidocSignatureSpan">jscs.</span>require_early_return
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_enhanced_object_literals">
            function <span class="apidocSignatureSpan">jscs.</span>require_enhanced_object_literals
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_function_declarations">
            function <span class="apidocSignatureSpan">jscs.</span>require_function_declarations
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_imports_alphabetized">
            function <span class="apidocSignatureSpan">jscs.</span>require_imports_alphabetized
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_keywords_on_new_line">
            function <span class="apidocSignatureSpan">jscs.</span>require_keywords_on_new_line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_break_after_variable_assignment">
            function <span class="apidocSignatureSpan">jscs.</span>require_line_break_after_variable_assignment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_feed_at_file_end">
            function <span class="apidocSignatureSpan">jscs.</span>require_line_feed_at_file_end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_matching_function_name">
            function <span class="apidocSignatureSpan">jscs.</span>require_matching_function_name
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multi_line_ternary">
            function <span class="apidocSignatureSpan">jscs.</span>require_multi_line_ternary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multiple_var_decl">
            function <span class="apidocSignatureSpan">jscs.</span>require_multiple_var_decl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_named_unassigned_functions">
            function <span class="apidocSignatureSpan">jscs.</span>require_named_unassigned_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_block_statements">
            function <span class="apidocSignatureSpan">jscs.</span>require_newline_before_block_statements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_single_statements_in_if">
            function <span class="apidocSignatureSpan">jscs.</span>require_newline_before_single_statements_in_if
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_numeric_literals">
            function <span class="apidocSignatureSpan">jscs.</span>require_numeric_literals
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_destructuring">
            function <span class="apidocSignatureSpan">jscs.</span>require_object_destructuring
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_keys_on_new_line">
            function <span class="apidocSignatureSpan">jscs.</span>require_object_keys_on_new_line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_operator_before_line_break">
            function <span class="apidocSignatureSpan">jscs.</span>require_operator_before_line_break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newline_after_variable_declaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_use_strict">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_use_strict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_export">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_export
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_line_comments">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_line_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_objects">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_objects
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_arrow_param">
            function <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_arrow_param
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_iife">
            function <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_iife
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_quoted_keys_in_objects">
            function <span class="apidocSignatureSpan">jscs.</span>require_quoted_keys_in_objects
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_semicolons">
            function <span class="apidocSignatureSpan">jscs.</span>require_semicolons
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_shorthand_arrow_functions">
            function <span class="apidocSignatureSpan">jscs.</span>require_shorthand_arrow_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_binary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_binary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_comma">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_line_comment">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_line_comment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_object_keys">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_object_keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_prefix_unary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_prefix_unary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_binary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_binary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_block_statements">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_block_statements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_comma">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_destructured_values">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_destructured_values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_object_values">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_object_values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_postfix_unary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_postfix_unary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_between_arguments">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_between_arguments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_anonymous_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_call_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_call_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_conditional_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_conditional_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_for_statement">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_for_statement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_declaration">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_declaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_generator">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_generator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_named_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_named_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_array_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_array_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_imported_object_braces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_object_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_object_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parentheses">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parentheses
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parenthesized_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spread">
            function <span class="apidocSignatureSpan">jscs.</span>require_spread
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_template_strings">
            function <span class="apidocSignatureSpan">jscs.</span>require_template_strings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_trailing_comma">
            function <span class="apidocSignatureSpan">jscs.</span>require_trailing_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_use_strict">
            function <span class="apidocSignatureSpan">jscs.</span>require_use_strict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_var_decl_first">
            function <span class="apidocSignatureSpan">jscs.</span>require_var_decl_first
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_yoda_conditions">
            function <span class="apidocSignatureSpan">jscs.</span>require_yoda_conditions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.safe_context_keyword">
            function <span class="apidocSignatureSpan">jscs.</span>safe_context_keyword
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_">
            function <span class="apidocSignatureSpan">jscs.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert">
            function <span class="apidocSignatureSpan">jscs.</span>token_assert
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_index">
            function <span class="apidocSignatureSpan">jscs.</span>token_index
            <span class="apidocSignatureSpan">(firstToken)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_aligned_function_parameters">
            function <span class="apidocSignatureSpan">jscs.</span>validate_aligned_function_parameters
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_comment_position">
            function <span class="apidocSignatureSpan">jscs.</span>validate_comment_position
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation">
            function <span class="apidocSignatureSpan">jscs.</span>validate_indentation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_line_breaks">
            function <span class="apidocSignatureSpan">jscs.</span>validate_line_breaks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_newline_after_array_elements">
            function <span class="apidocSignatureSpan">jscs.</span>validate_newline_after_array_elements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_order_in_object_keys">
            function <span class="apidocSignatureSpan">jscs.</span>validate_order_in_object_keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_parameter_separator">
            function <span class="apidocSignatureSpan">jscs.</span>validate_parameter_separator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_quote_marks">
            function <span class="apidocSignatureSpan">jscs.</span>validate_quote_marks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>cli_config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>configuration.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_anonymous_functions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_array_destructuring_return.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_arrow_functions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_capitalized_comments.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_comma_before_line_break.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_curly_braces.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_dangling_underscores.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_empty_blocks.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_function_declarations.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_identical_destructuring_names.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_identifier_names.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_implicit_type_conversion.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_keywords.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_in_comments.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_on_new_line.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_mixed_spaces_and_tabs.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_multi_line_ternary.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_breaks.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_strings.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_spaces.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_var_decl.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_named_unassigned_functions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_nested_ternaries.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_newline_before_block_statements.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_node_types.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_not_operators_in_conditionals.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_object_keys_on_new_line.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_operator_before_line_break.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_blocks.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_use_strict.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_export.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_keywords.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_line_comments.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_blocks.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_objects.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_parentheses_around_arrow_param.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_quoted_keys_in_objects.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_semicolons.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_shorthand_arrow_functions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_binary_operators.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_comma.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_keywords.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_line_comment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_object_keys.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_prefix_unary_operators.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_binary_operators.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_block_statements.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_comma.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_keywords.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_object_values.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_postfix_unary_operators.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_semicolon.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_space_between_arguments.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_anonymous_function_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_call_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_conditional_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_for_statement.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_declaration.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_generator.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_named_function_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_array_brackets.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_brackets.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_imported_object_braces.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_object_brackets.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parentheses.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parenthesized_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_template_string_placeholders.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_tabs.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_comma.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_whitespace.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_unused_params.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_unused_variables.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_var.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>disallow_yoda_conditions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>errors.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>generator.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>js_file.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>jsdoc.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>maximum_line_length.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>maximum_number_of_lines.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>node_configuration.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_aligned_multiline_params.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_aligned_object_values.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_anonymous_functions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_array_destructuring.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_arrow_functions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_blocks_on_newline.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_camelcase_or_uppercase_identifiers.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_capitalized_comments.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors_new.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_comma_before_line_break.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_curly_braces.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_dollar_before_jquery_assignment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_dot_notation.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_early_return.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_enhanced_object_literals.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_function_declarations.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_imports_alphabetized.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_keywords_on_new_line.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_line_break_after_variable_assignment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_line_feed_at_file_end.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_matching_function_name.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_multi_line_ternary.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_multiple_var_decl.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_named_unassigned_functions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_newline_before_block_statements.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_newline_before_single_statements_in_if.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_numeric_literals.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_object_destructuring.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_object_keys_on_new_line.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_operator_before_line_break.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_padding_newline_after_variable_declaration.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_blocks.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_use_strict.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_export.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_keywords.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_line_comments.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_blocks.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_objects.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_arrow_param.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_iife.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_quoted_keys_in_objects.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_semicolons.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_shorthand_arrow_functions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_after_binary_operators.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_after_comma.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_after_keywords.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_after_line_comment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_after_object_keys.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_after_prefix_unary_operators.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_before_binary_operators.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_before_block_statements.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_before_comma.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_before_destructured_values.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_before_keywords.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_before_object_values.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_before_postfix_unary_operators.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_space_between_arguments.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_anonymous_function_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_call_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_conditional_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_for_statement.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_declaration.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_generator.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_named_function_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_array_brackets.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_brackets.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_imported_object_braces.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_object_brackets.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parentheses.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parenthesized_expression.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_spread.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_template_strings.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_trailing_comma.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_use_strict.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_var_decl_first.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>require_yoda_conditions.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>safe_context_keyword.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>token_assert.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>token_categorizer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>token_index.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>tree_iterator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>validate_aligned_function_parameters.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>validate_comment_position.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>validate_indentation.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>validate_line_breaks.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>validate_newline_after_array_elements.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>validate_order_in_object_keys.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>validate_parameter_separator.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.</span>validate_quote_marks.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.cli_config">module jscs.cli_config</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.cli_config.getContent">
            function <span class="apidocSignatureSpan">jscs.cli_config.</span>getContent
            <span class="apidocSignatureSpan">(config, directory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.cli_config.getReporter">
            function <span class="apidocSignatureSpan">jscs.cli_config.</span>getReporter
            <span class="apidocSignatureSpan">(reporter, colors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.cli_config.load">
            function <span class="apidocSignatureSpan">jscs.cli_config.</span>load
            <span class="apidocSignatureSpan">(config, cwd)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.configuration">module jscs.configuration</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.configuration">
            function <span class="apidocSignatureSpan">jscs.</span>configuration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.configuration.prototype">module jscs.configuration.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._errorOnRemovedOptions">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_errorOnRemovedOptions
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._getOptionsFromConfig">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_getOptionsFromConfig
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._isDefined">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_isDefined
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadAdditionalRule">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadAdditionalRule
            <span class="apidocSignatureSpan">(additionalRule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadDefaults">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadDefaults
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadES3">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadES3
            <span class="apidocSignatureSpan">(es3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadErrorFilter">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadErrorFilter
            <span class="apidocSignatureSpan">(errorFilter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadExcludedFiles">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadExcludedFiles
            <span class="apidocSignatureSpan">(masks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadExtract">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadExtract
            <span class="apidocSignatureSpan">(masks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadFileExtensions">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadFileExtensions
            <span class="apidocSignatureSpan">(extensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadFix">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadFix
            <span class="apidocSignatureSpan">(fix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadMaxError">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadMaxError
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadPlugin">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadPlugin
            <span class="apidocSignatureSpan">(plugin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadPreset">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadPreset
            <span class="apidocSignatureSpan">(preset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._loadRules">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadRules
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._processConfig">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_processConfig
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype._useRules">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_useRules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getBasePath">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getBasePath
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getConfiguredRule">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getConfiguredRule
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getConfiguredRules">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getConfiguredRules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getErrorFilter">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getErrorFilter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getExcludedFileMasks">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getExcludedFileMasks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getExtractFileMasks">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getExtractFileMasks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getFileExtensions">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getFileExtensions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getFix">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getFix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getMaxErrors">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getMaxErrors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getPresetName">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getPresetName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getProcessedConfig">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getProcessedConfig
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getRegisteredPresets">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getRegisteredPresets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getRegisteredRules">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getRegisteredRules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.getUnsupportedRuleNames">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getUnsupportedRuleNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.hasCorrectExtension">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>hasCorrectExtension
            <span class="apidocSignatureSpan">(testPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.hasPreset">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>hasPreset
            <span class="apidocSignatureSpan">(presetName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.isES3Enabled">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>isES3Enabled
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.isFileExcluded">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>isFileExcluded
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.load">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>load
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.override">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>override
            <span class="apidocSignatureSpan">(overrides)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.registerDefaultPresets">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>registerDefaultPresets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.registerDefaultRules">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>registerDefaultRules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.registerPreset">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>registerPreset
            <span class="apidocSignatureSpan">(presetName, presetConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.registerRule">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>registerRule
            <span class="apidocSignatureSpan">(rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.shouldExtractFile">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>shouldExtractFile
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.configuration.prototype.usePlugin">
            function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>usePlugin
            <span class="apidocSignatureSpan">(plugin)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_anonymous_functions">module jscs.disallow_anonymous_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_anonymous_functions.disallow_anonymous_functions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_anonymous_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_anonymous_functions.prototype">module jscs.disallow_anonymous_functions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_anonymous_functions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_anonymous_functions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_anonymous_functions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_anonymous_functions.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_anonymous_functions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_anonymous_functions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_array_destructuring_return">module jscs.disallow_array_destructuring_return</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_array_destructuring_return.disallow_array_destructuring_return">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_array_destructuring_return
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_array_destructuring_return.prototype">module jscs.disallow_array_destructuring_return.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_array_destructuring_return.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_array_destructuring_return.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_array_destructuring_return.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_array_destructuring_return.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_array_destructuring_return.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_array_destructuring_return.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_arrow_functions">module jscs.disallow_arrow_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_arrow_functions.disallow_arrow_functions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_arrow_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_arrow_functions.prototype">module jscs.disallow_arrow_functions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_arrow_functions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_arrow_functions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_arrow_functions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_arrow_functions.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_arrow_functions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_arrow_functions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_capitalized_comments">module jscs.disallow_capitalized_comments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_capitalized_comments.disallow_capitalized_comments">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_capitalized_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_capitalized_comments.prototype">module jscs.disallow_capitalized_comments.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_capitalized_comments.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_capitalized_comments.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_capitalized_comments.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_capitalized_comments.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_capitalized_comments.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_capitalized_comments.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_comma_before_line_break">module jscs.disallow_comma_before_line_break</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_comma_before_line_break.disallow_comma_before_line_break">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_comma_before_line_break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_comma_before_line_break.prototype">module jscs.disallow_comma_before_line_break.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_comma_before_line_break.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_comma_before_line_break.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_comma_before_line_break.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_comma_before_line_break.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_comma_before_line_break.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_comma_before_line_break.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_curly_braces">module jscs.disallow_curly_braces</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_curly_braces.disallow_curly_braces">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_curly_braces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_curly_braces.prototype">module jscs.disallow_curly_braces.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_curly_braces.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_curly_braces.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_curly_braces.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_curly_braces.prototype.</span>configure
            <span class="apidocSignatureSpan">(statementTypes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_curly_braces.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_curly_braces.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_dangling_underscores">module jscs.disallow_dangling_underscores</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_dangling_underscores.disallow_dangling_underscores">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_dangling_underscores
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_dangling_underscores.prototype">module jscs.disallow_dangling_underscores.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_dangling_underscores.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_dangling_underscores.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_dangling_underscores.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_dangling_underscores.prototype.</span>configure
            <span class="apidocSignatureSpan">(identifiers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_dangling_underscores.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_dangling_underscores.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_empty_blocks">module jscs.disallow_empty_blocks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_empty_blocks.disallow_empty_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_empty_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_empty_blocks.prototype">module jscs.disallow_empty_blocks.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_empty_blocks.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_empty_blocks.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_empty_blocks.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_empty_blocks.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_empty_blocks.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_empty_blocks.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_function_declarations">module jscs.disallow_function_declarations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_function_declarations.disallow_function_declarations">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_function_declarations
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_function_declarations.prototype">module jscs.disallow_function_declarations.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_function_declarations.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_function_declarations.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_function_declarations.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_function_declarations.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_function_declarations.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_function_declarations.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_identical_destructuring_names">module jscs.disallow_identical_destructuring_names</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identical_destructuring_names.disallow_identical_destructuring_names">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_identical_destructuring_names
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_identical_destructuring_names.prototype">module jscs.disallow_identical_destructuring_names.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identical_destructuring_names.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_identical_destructuring_names.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identical_destructuring_names.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_identical_destructuring_names.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identical_destructuring_names.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_identical_destructuring_names.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_identifier_names">module jscs.disallow_identifier_names</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identifier_names.disallow_identifier_names">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_identifier_names
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_identifier_names.prototype">module jscs.disallow_identifier_names.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identifier_names.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_identifier_names.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identifier_names.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_identifier_names.prototype.</span>configure
            <span class="apidocSignatureSpan">(identifiers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_identifier_names.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_identifier_names.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_implicit_type_conversion">module jscs.disallow_implicit_type_conversion</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_implicit_type_conversion.disallow_implicit_type_conversion">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_implicit_type_conversion
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_implicit_type_conversion.prototype">module jscs.disallow_implicit_type_conversion.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_implicit_type_conversion.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_implicit_type_conversion.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_implicit_type_conversion.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_implicit_type_conversion.prototype.</span>configure
            <span class="apidocSignatureSpan">(types)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_implicit_type_conversion.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_implicit_type_conversion.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_keywords">module jscs.disallow_keywords</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords.disallow_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_keywords.prototype">module jscs.disallow_keywords.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_keywords_in_comments">module jscs.disallow_keywords_in_comments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_in_comments.disallow_keywords_in_comments">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_in_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_keywords_in_comments.prototype">module jscs.disallow_keywords_in_comments.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_in_comments.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords_in_comments.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_in_comments.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords_in_comments.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_in_comments.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords_in_comments.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_keywords_on_new_line">module jscs.disallow_keywords_on_new_line</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_on_new_line.disallow_keywords_on_new_line">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_on_new_line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_keywords_on_new_line.prototype">module jscs.disallow_keywords_on_new_line.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_on_new_line.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords_on_new_line.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_on_new_line.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords_on_new_line.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_keywords_on_new_line.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_keywords_on_new_line.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_mixed_spaces_and_tabs">module jscs.disallow_mixed_spaces_and_tabs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs.disallow_mixed_spaces_and_tabs">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_mixed_spaces_and_tabs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_mixed_spaces_and_tabs.prototype">module jscs.disallow_mixed_spaces_and_tabs.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_mixed_spaces_and_tabs.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_mixed_spaces_and_tabs.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_mixed_spaces_and_tabs.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multi_line_ternary">module jscs.disallow_multi_line_ternary</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multi_line_ternary.disallow_multi_line_ternary">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multi_line_ternary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multi_line_ternary.prototype">module jscs.disallow_multi_line_ternary.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multi_line_ternary.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_multi_line_ternary.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multi_line_ternary.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_multi_line_ternary.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multi_line_ternary.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_multi_line_ternary.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multiple_line_breaks">module jscs.disallow_multiple_line_breaks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_breaks.disallow_multiple_line_breaks">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_breaks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multiple_line_breaks.prototype">module jscs.disallow_multiple_line_breaks.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_breaks.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_breaks.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_breaks.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_breaks.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_breaks.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_breaks.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multiple_line_strings">module jscs.disallow_multiple_line_strings</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_strings.disallow_multiple_line_strings">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_strings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multiple_line_strings.prototype">module jscs.disallow_multiple_line_strings.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_strings.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_strings.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_strings.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_strings.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_line_strings.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_strings.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multiple_spaces">module jscs.disallow_multiple_spaces</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_spaces.disallow_multiple_spaces">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_spaces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multiple_spaces.prototype">module jscs.disallow_multiple_spaces.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_spaces.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_spaces.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_spaces.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_spaces.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_spaces.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_spaces.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multiple_var_decl">module jscs.disallow_multiple_var_decl</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_var_decl.disallow_multiple_var_decl">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_var_decl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_multiple_var_decl.prototype">module jscs.disallow_multiple_var_decl.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_var_decl.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_var_decl.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_var_decl.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_var_decl.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_multiple_var_decl.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_multiple_var_decl.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_named_unassigned_functions">module jscs.disallow_named_unassigned_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_named_unassigned_functions.disallow_named_unassigned_functions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_named_unassigned_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_named_unassigned_functions.prototype">module jscs.disallow_named_unassigned_functions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_named_unassigned_functions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_named_unassigned_functions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_named_unassigned_functions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_named_unassigned_functions.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_named_unassigned_functions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_named_unassigned_functions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_nested_ternaries">module jscs.disallow_nested_ternaries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_nested_ternaries.disallow_nested_ternaries">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_nested_ternaries
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_nested_ternaries.prototype">module jscs.disallow_nested_ternaries.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_nested_ternaries.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_nested_ternaries.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_nested_ternaries.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_nested_ternaries.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_nested_ternaries.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_nested_ternaries.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_newline_before_block_statements">module jscs.disallow_newline_before_block_statements</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_newline_before_block_statements.disallow_newline_before_block_statements">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_newline_before_block_statements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_newline_before_block_statements.prototype">module jscs.disallow_newline_before_block_statements.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_newline_before_block_statements.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_newline_before_block_statements.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_newline_before_block_statements.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_newline_before_block_statements.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_newline_before_block_statements.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_newline_before_block_statements.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_node_types">module jscs.disallow_node_types</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_node_types.disallow_node_types">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_node_types
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_node_types.prototype">module jscs.disallow_node_types.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_node_types.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_node_types.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_node_types.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_node_types.prototype.</span>configure
            <span class="apidocSignatureSpan">(nodeTypes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_node_types.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_node_types.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_not_operators_in_conditionals">module jscs.disallow_not_operators_in_conditionals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_not_operators_in_conditionals.disallow_not_operators_in_conditionals">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_not_operators_in_conditionals
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_not_operators_in_conditionals.prototype">module jscs.disallow_not_operators_in_conditionals.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_not_operators_in_conditionals.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_not_operators_in_conditionals.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_not_operators_in_conditionals.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_object_keys_on_new_line">module jscs.disallow_object_keys_on_new_line</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_object_keys_on_new_line.disallow_object_keys_on_new_line">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_object_keys_on_new_line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_object_keys_on_new_line.prototype">module jscs.disallow_object_keys_on_new_line.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_object_keys_on_new_line.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_object_keys_on_new_line.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_object_keys_on_new_line.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_operator_before_line_break">module jscs.disallow_operator_before_line_break</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_operator_before_line_break.disallow_operator_before_line_break">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_operator_before_line_break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_operator_before_line_break.prototype">module jscs.disallow_operator_before_line_break.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_operator_before_line_break.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_operator_before_line_break.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_operator_before_line_break.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_operator_before_line_break.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_operator_before_line_break.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_operator_before_line_break.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_after_blocks">module jscs.disallow_padding_newlines_after_blocks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks.disallow_padding_newlines_after_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_after_blocks.prototype">module jscs.disallow_padding_newlines_after_blocks.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_blocks.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_blocks.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_blocks.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_after_use_strict">module jscs.disallow_padding_newlines_after_use_strict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict.disallow_padding_newlines_after_use_strict">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_use_strict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_after_use_strict.prototype">module jscs.disallow_padding_newlines_after_use_strict.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_use_strict.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_use_strict.prototype.</span>configure
            <span class="apidocSignatureSpan">(disallowPaddingNewLinesAfterUseStrict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_use_strict.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_before_export">module jscs.disallow_padding_newlines_before_export</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_export.disallow_padding_newlines_before_export">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_export
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_before_export.prototype">module jscs.disallow_padding_newlines_before_export.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_export.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_export.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_export.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_before_keywords">module jscs.disallow_padding_newlines_before_keywords</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords.disallow_padding_newlines_before_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_before_keywords.prototype">module jscs.disallow_padding_newlines_before_keywords.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_keywords.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_keywords.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_keywords.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_before_line_comments">module jscs.disallow_padding_newlines_before_line_comments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments.disallow_padding_newlines_before_line_comments">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_line_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_before_line_comments.prototype">module jscs.disallow_padding_newlines_before_line_comments.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_line_comments.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_line_comments.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_line_comments.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_in_blocks">module jscs.disallow_padding_newlines_in_blocks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks.disallow_padding_newlines_in_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_in_blocks.prototype">module jscs.disallow_padding_newlines_in_blocks.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_blocks.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_blocks.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_blocks.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_in_objects">module jscs.disallow_padding_newlines_in_objects</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_objects.disallow_padding_newlines_in_objects">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_objects
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_padding_newlines_in_objects.prototype">module jscs.disallow_padding_newlines_in_objects.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_objects.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_objects.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_objects.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_parentheses_around_arrow_param">module jscs.disallow_parentheses_around_arrow_param</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param.disallow_parentheses_around_arrow_param">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_parentheses_around_arrow_param
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_parentheses_around_arrow_param.prototype">module jscs.disallow_parentheses_around_arrow_param.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_parentheses_around_arrow_param.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_parentheses_around_arrow_param.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_parentheses_around_arrow_param.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_quoted_keys_in_objects">module jscs.disallow_quoted_keys_in_objects</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.disallow_quoted_keys_in_objects">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_quoted_keys_in_objects
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_quoted_keys_in_objects.prototype">module jscs.disallow_quoted_keys_in_objects.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.disallow_quoted_keys_in_objects.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_quoted_keys_in_objects.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_quoted_keys_in_objects.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_quoted_keys_in_objects.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_semicolons">module jscs.disallow_semicolons</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_semicolons.disallow_semicolons">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_semicolons
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_semicolons.prototype">module jscs.disallow_semicolons.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_semicolons.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.disallow_semicolons.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_semicolons.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_semicolons.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_semicolons.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_semicolons.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_semicolons.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_semicolons.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_shorthand_arrow_functions">module jscs.disallow_shorthand_arrow_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_shorthand_arrow_functions.disallow_shorthand_arrow_functions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_shorthand_arrow_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_shorthand_arrow_functions.prototype">module jscs.disallow_shorthand_arrow_functions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_shorthand_arrow_functions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_shorthand_arrow_functions.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_shorthand_arrow_functions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_binary_operators">module jscs.disallow_space_after_binary_operators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_binary_operators.disallow_space_after_binary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_binary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_binary_operators.prototype">module jscs.disallow_space_after_binary_operators.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_binary_operators.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_binary_operators.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_binary_operators.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_binary_operators.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_binary_operators.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_binary_operators.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_comma">module jscs.disallow_space_after_comma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_comma.disallow_space_after_comma">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_comma.prototype">module jscs.disallow_space_after_comma.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_comma.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_comma.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_comma.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_comma.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_comma.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_comma.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_keywords">module jscs.disallow_space_after_keywords</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_keywords.disallow_space_after_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_keywords.prototype">module jscs.disallow_space_after_keywords.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_keywords.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_keywords.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_keywords.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_keywords.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_keywords.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_keywords.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_line_comment">module jscs.disallow_space_after_line_comment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_line_comment.disallow_space_after_line_comment">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_line_comment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_line_comment.prototype">module jscs.disallow_space_after_line_comment.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_line_comment.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_line_comment.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_line_comment.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_line_comment.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_line_comment.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_line_comment.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_object_keys">module jscs.disallow_space_after_object_keys</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_object_keys.disallow_space_after_object_keys">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_object_keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_object_keys.prototype">module jscs.disallow_space_after_object_keys.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_object_keys.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_object_keys.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_object_keys.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_object_keys.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_object_keys.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_object_keys.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_prefix_unary_operators">module jscs.disallow_space_after_prefix_unary_operators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators.disallow_space_after_prefix_unary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_prefix_unary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_after_prefix_unary_operators.prototype">module jscs.disallow_space_after_prefix_unary_operators.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_prefix_unary_operators.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_prefix_unary_operators.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_after_prefix_unary_operators.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_binary_operators">module jscs.disallow_space_before_binary_operators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_binary_operators.disallow_space_before_binary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_binary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_binary_operators.prototype">module jscs.disallow_space_before_binary_operators.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_binary_operators.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_binary_operators.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_binary_operators.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_binary_operators.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_binary_operators.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_binary_operators.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_block_statements">module jscs.disallow_space_before_block_statements</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_block_statements.disallow_space_before_block_statements">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_block_statements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_block_statements.prototype">module jscs.disallow_space_before_block_statements.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_block_statements.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_block_statements.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_block_statements.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_block_statements.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_block_statements.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_block_statements.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_comma">module jscs.disallow_space_before_comma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_comma.disallow_space_before_comma">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_comma.prototype">module jscs.disallow_space_before_comma.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_comma.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_comma.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_comma.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_comma.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_comma.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_comma.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_keywords">module jscs.disallow_space_before_keywords</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_keywords.disallow_space_before_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_keywords.prototype">module jscs.disallow_space_before_keywords.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_keywords.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_keywords.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_keywords.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_keywords.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_keywords.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_keywords.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_object_values">module jscs.disallow_space_before_object_values</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_object_values.disallow_space_before_object_values">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_object_values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_object_values.prototype">module jscs.disallow_space_before_object_values.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_object_values.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_object_values.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_object_values.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_object_values.prototype.</span>configure
            <span class="apidocSignatureSpan">(disallow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_object_values.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_object_values.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_postfix_unary_operators">module jscs.disallow_space_before_postfix_unary_operators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators.disallow_space_before_postfix_unary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_postfix_unary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_postfix_unary_operators.prototype">module jscs.disallow_space_before_postfix_unary_operators.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_postfix_unary_operators.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_postfix_unary_operators.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_postfix_unary_operators.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_semicolon">module jscs.disallow_space_before_semicolon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_semicolon.disallow_space_before_semicolon">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_semicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_before_semicolon.prototype">module jscs.disallow_space_before_semicolon.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_semicolon.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_semicolon.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_semicolon.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_semicolon.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_before_semicolon.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_before_semicolon.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_between_arguments">module jscs.disallow_space_between_arguments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_between_arguments.disallow_space_between_arguments">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_space_between_arguments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_space_between_arguments.prototype">module jscs.disallow_space_between_arguments.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_between_arguments.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_space_between_arguments.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_between_arguments.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_space_between_arguments.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_space_between_arguments.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_space_between_arguments.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_anonymous_function_expression">module jscs.disallow_spaces_in_anonymous_function_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.disallow_spaces_in_anonymous_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_anonymous_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_anonymous_function_expression.prototype">module jscs.disallow_spaces_in_anonymous_function_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_anonymous_function_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_anonymous_function_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_anonymous_function_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_call_expression">module jscs.disallow_spaces_in_call_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_call_expression.disallow_spaces_in_call_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_call_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_call_expression.prototype">module jscs.disallow_spaces_in_call_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_call_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_call_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_call_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_conditional_expression">module jscs.disallow_spaces_in_conditional_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression.disallow_spaces_in_conditional_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_conditional_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_conditional_expression.prototype">module jscs.disallow_spaces_in_conditional_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_conditional_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_conditional_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_conditional_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_for_statement">module jscs.disallow_spaces_in_for_statement</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_for_statement.disallow_spaces_in_for_statement">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_for_statement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_for_statement.prototype">module jscs.disallow_spaces_in_for_statement.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_for_statement.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_for_statement.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_for_statement.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_function">module jscs.disallow_spaces_in_function</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function.disallow_spaces_in_function">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_function.prototype">module jscs.disallow_spaces_in_function.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_function_declaration">module jscs.disallow_spaces_in_function_declaration</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_declaration.disallow_spaces_in_function_declaration">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_declaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_function_declaration.prototype">module jscs.disallow_spaces_in_function_declaration.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_declaration.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_declaration.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_declaration.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_function_expression">module jscs.disallow_spaces_in_function_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_expression.disallow_spaces_in_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_function_expression.prototype">module jscs.disallow_spaces_in_function_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_generator">module jscs.disallow_spaces_in_generator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_generator.disallow_spaces_in_generator">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_generator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_generator.prototype">module jscs.disallow_spaces_in_generator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_generator.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_generator.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_generator.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_generator.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_generator.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_generator.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_named_function_expression">module jscs.disallow_spaces_in_named_function_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression.disallow_spaces_in_named_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_named_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_in_named_function_expression.prototype">module jscs.disallow_spaces_in_named_function_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_named_function_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_named_function_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_named_function_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_array_brackets">module jscs.disallow_spaces_inside_array_brackets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets.disallow_spaces_inside_array_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_array_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_array_brackets.prototype">module jscs.disallow_spaces_inside_array_brackets.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_array_brackets.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_array_brackets.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_array_brackets.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_brackets">module jscs.disallow_spaces_inside_brackets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_brackets.disallow_spaces_inside_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_brackets.prototype">module jscs.disallow_spaces_inside_brackets.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_brackets.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_brackets.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_brackets.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_imported_object_braces">module jscs.disallow_spaces_inside_imported_object_braces</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.disallow_spaces_inside_imported_object_braces">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_imported_object_braces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_imported_object_braces.prototype">module jscs.disallow_spaces_inside_imported_object_braces.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_imported_object_braces.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_imported_object_braces.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_imported_object_braces.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_object_brackets">module jscs.disallow_spaces_inside_object_brackets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets.disallow_spaces_inside_object_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_object_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_object_brackets.prototype">module jscs.disallow_spaces_inside_object_brackets.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_object_brackets.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_object_brackets.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_object_brackets.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_parentheses">module jscs.disallow_spaces_inside_parentheses</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parentheses.disallow_spaces_inside_parentheses">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parentheses
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_parentheses.prototype">module jscs.disallow_spaces_inside_parentheses.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parentheses.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parentheses.prototype.</span>configure
            <span class="apidocSignatureSpan">(option)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parentheses.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_parenthesized_expression">module jscs.disallow_spaces_inside_parenthesized_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.disallow_spaces_inside_parenthesized_expression">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parenthesized_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_parenthesized_expression.prototype">module jscs.disallow_spaces_inside_parenthesized_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parenthesized_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parenthesized_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parenthesized_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_template_string_placeholders">module jscs.disallow_spaces_inside_template_string_placeholders</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.disallow_spaces_inside_template_string_placeholders">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_template_string_placeholders
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_spaces_inside_template_string_placeholders.prototype">module jscs.disallow_spaces_inside_template_string_placeholders.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_template_string_placeholders.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_template_string_placeholders.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_template_string_placeholders.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_tabs">module jscs.disallow_tabs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_tabs.disallow_tabs">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_tabs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_tabs.prototype">module jscs.disallow_tabs.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_tabs.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_tabs.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_tabs.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_tabs.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_tabs.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_tabs.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_trailing_comma">module jscs.disallow_trailing_comma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_comma.disallow_trailing_comma">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_trailing_comma.prototype">module jscs.disallow_trailing_comma.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_comma.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.disallow_trailing_comma.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_comma.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_trailing_comma.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_comma.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_trailing_comma.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_comma.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_trailing_comma.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_trailing_whitespace">module jscs.disallow_trailing_whitespace</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_whitespace.disallow_trailing_whitespace">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_whitespace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_trailing_whitespace.prototype">module jscs.disallow_trailing_whitespace.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_whitespace.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.disallow_trailing_whitespace.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_whitespace.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_trailing_whitespace.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_whitespace.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_trailing_whitespace.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_trailing_whitespace.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_trailing_whitespace.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_unused_params">module jscs.disallow_unused_params</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_params.disallow_unused_params">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_unused_params
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_unused_params.prototype">module jscs.disallow_unused_params.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_params.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.disallow_unused_params.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_params.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_unused_params.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_params.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_unused_params.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_params.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_unused_params.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_unused_variables">module jscs.disallow_unused_variables</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_variables.disallow_unused_variables">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_unused_variables
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_unused_variables.prototype">module jscs.disallow_unused_variables.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_variables.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.disallow_unused_variables.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_variables.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_unused_variables.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_variables.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_unused_variables.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_unused_variables.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_unused_variables.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_var">module jscs.disallow_var</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_var.disallow_var">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_var
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_var.prototype">module jscs.disallow_var.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_var.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_var.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_var.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_var.prototype.</span>configure
            <span class="apidocSignatureSpan">(option)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_var.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_var.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_yoda_conditions">module jscs.disallow_yoda_conditions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_yoda_conditions.disallow_yoda_conditions">
            function <span class="apidocSignatureSpan">jscs.</span>disallow_yoda_conditions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.disallow_yoda_conditions.prototype">module jscs.disallow_yoda_conditions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_yoda_conditions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.disallow_yoda_conditions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_yoda_conditions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.disallow_yoda_conditions.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.disallow_yoda_conditions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.disallow_yoda_conditions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.errors">module jscs.errors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.errors">
            function <span class="apidocSignatureSpan">jscs.</span>errors
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.getPosition">
            function <span class="apidocSignatureSpan">jscs.errors.</span>getPosition
            <span class="apidocSignatureSpan">(error, tokenIndex)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.errors.prototype">module jscs.errors.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype._addError">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>_addError
            <span class="apidocSignatureSpan">(errorInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype._addParseError">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>_addParseError
            <span class="apidocSignatureSpan">(errorInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype._prepareMessage">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>_prepareMessage
            <span class="apidocSignatureSpan">(errorInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.add">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>add
            <span class="apidocSignatureSpan">(message, element, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.calculateErrorLocations">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>calculateErrorLocations
            <span class="apidocSignatureSpan">(tokenIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.cast">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>cast
            <span class="apidocSignatureSpan">(errorInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.explainError">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>explainError
            <span class="apidocSignatureSpan">(error, colorize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.filter">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>filter
            <span class="apidocSignatureSpan">(filter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.getErrorCount">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>getErrorCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.getErrorList">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>getErrorList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.getFilename">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>getFilename
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.getValidationErrorCount">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>getValidationErrorCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.isEmpty">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.setCurrentRule">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>setCurrentRule
            <span class="apidocSignatureSpan">(rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.errors.prototype.stripErrorList">
            function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>stripErrorList
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.generator">module jscs.generator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.generator">
            function <span class="apidocSignatureSpan">jscs.</span>generator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.generator.prototype">module jscs.generator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.prototype._checkAgainstPreset">
            function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_checkAgainstPreset
            <span class="apidocSignatureSpan">(path, presetName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.prototype._generateStatsForPresets">
            function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_generateStatsForPresets
            <span class="apidocSignatureSpan">(resultsPerPreset, presetNames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.prototype._getUserPresetChoice">
            function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_getUserPresetChoice
            <span class="apidocSignatureSpan">(prompt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.prototype._getUserViolationChoices">
            function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_getUserViolationChoices
            <span class="apidocSignatureSpan">(errorPrompts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.prototype._handleViolatedRules">
            function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_handleViolatedRules
            <span class="apidocSignatureSpan">(errorPrompts, choices)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.prototype._showErrorCounts">
            function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_showErrorCounts
            <span class="apidocSignatureSpan">(statsForPresets)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.prototype._showPrompt">
            function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_showPrompt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.generator.prototype.generate">
            function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>generate
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.js_file">module jscs.js_file</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.js_file">
            function <span class="apidocSignatureSpan">jscs.</span>js_file
            <span class="apidocSignatureSpan">(params)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.js_file.prototype">module jscs.js_file.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype._setTokenBefore">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>_setTokenBefore
            <span class="apidocSignatureSpan">(token, fragment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.findNextOperatorToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>findNextOperatorToken
            <span class="apidocSignatureSpan">(token, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.findNextToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>findNextToken
            <span class="apidocSignatureSpan">(token, type, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.findPrevOperatorToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>findPrevOperatorToken
            <span class="apidocSignatureSpan">(token, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.findPrevToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>findPrevToken
            <span class="apidocSignatureSpan">(token, type, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getComments">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getComments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getDialect">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getDialect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getDistanceBetween">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getDistanceBetween
            <span class="apidocSignatureSpan">(tokenBefore, tokenAfter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getFilename">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getFilename
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getFirstNodeToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getFirstNodeToken
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getFirstToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getFirstToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getFirstTokenOnLineWith">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getFirstTokenOnLineWith
            <span class="apidocSignatureSpan">(element, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getLastNodeToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLastNodeToken
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getLastToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLastToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getLastTokenOnLine">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLastTokenOnLine
            <span class="apidocSignatureSpan">(lineNumber, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getLineBreakStyle">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLineBreakStyle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getLineBreaks">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLineBreaks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getLineCountBetween">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLineCountBetween
            <span class="apidocSignatureSpan">(tokenBefore, tokenAfter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getLines">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLines
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getLinesWithCommentsRemoved">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLinesWithCommentsRemoved
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getNextToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getNextToken
            <span class="apidocSignatureSpan">(token, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getNodesByType">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getNodesByType
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getParseErrors">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getParseErrors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getPrevToken">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getPrevToken
            <span class="apidocSignatureSpan">(token, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getProgram">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getProgram
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getScopes">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getScopes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getSource">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getTree">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getTree
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.getWhitespaceBefore">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getWhitespaceBefore
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.isOnTheSameLine">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>isOnTheSameLine
            <span class="apidocSignatureSpan">(tokenBefore, tokenAfter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.iterate">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>iterate
            <span class="apidocSignatureSpan">(cb, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.iterateNodesByType">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>iterateNodesByType
            <span class="apidocSignatureSpan">(type, cb, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.iterateTokensByType">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>iterateTokensByType
            <span class="apidocSignatureSpan">(type, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.iterateTokensByTypeAndValue">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>iterateTokensByTypeAndValue
            <span class="apidocSignatureSpan">(type, value, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.render">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>render
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.js_file.prototype.setWhitespaceBefore">
            function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>setWhitespaceBefore
            <span class="apidocSignatureSpan">(token, whitespace)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.jsdoc">module jscs.jsdoc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.jsdoc.jsdoc">
            function <span class="apidocSignatureSpan">jscs.</span>jsdoc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.jsdoc.prototype">module jscs.jsdoc.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.jsdoc.prototype._getReturnStatementsForNode">
            function <span class="apidocSignatureSpan">jscs.jsdoc.prototype.</span>_getReturnStatementsForNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.jsdoc.prototype.check">
            function <span class="apidocSignatureSpan">jscs.jsdoc.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.jsdoc.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.jsdoc.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.jsdoc.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.jsdoc.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.maximum_line_length">module jscs.maximum_line_length</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_line_length.maximum_line_length">
            function <span class="apidocSignatureSpan">jscs.</span>maximum_line_length
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.maximum_line_length.prototype">module jscs.maximum_line_length.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_line_length.prototype.check">
            function <span class="apidocSignatureSpan">jscs.maximum_line_length.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_line_length.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.maximum_line_length.prototype.</span>configure
            <span class="apidocSignatureSpan">(maximumLineLength)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_line_length.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.maximum_line_length.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.maximum_number_of_lines">module jscs.maximum_number_of_lines</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_number_of_lines.maximum_number_of_lines">
            function <span class="apidocSignatureSpan">jscs.</span>maximum_number_of_lines
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.maximum_number_of_lines.prototype">module jscs.maximum_number_of_lines.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_number_of_lines.prototype.check">
            function <span class="apidocSignatureSpan">jscs.maximum_number_of_lines.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_number_of_lines.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.maximum_number_of_lines.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.maximum_number_of_lines.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.maximum_number_of_lines.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.node_configuration">module jscs.node_configuration</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration.node_configuration">
            function <span class="apidocSignatureSpan">jscs.</span>node_configuration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration.super_">
            function <span class="apidocSignatureSpan">jscs.node_configuration.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.node_configuration.prototype">module jscs.node_configuration.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration.prototype._loadAdditionalRule">
            function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>_loadAdditionalRule
            <span class="apidocSignatureSpan">(additionalRule, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration.prototype._loadErrorFilter">
            function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>_loadErrorFilter
            <span class="apidocSignatureSpan">(filter, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration.prototype._loadPlugin">
            function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>_loadPlugin
            <span class="apidocSignatureSpan">(plugin, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration.prototype._loadPreset">
            function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>_loadPreset
            <span class="apidocSignatureSpan">(preset, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration.prototype.loadExternal">
            function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>loadExternal
            <span class="apidocSignatureSpan">(external, type, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.node_configuration.prototype.overrideFromCLI">
            function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>overrideFromCLI
            <span class="apidocSignatureSpan">(program)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_aligned_multiline_params">module jscs.require_aligned_multiline_params</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_multiline_params.require_aligned_multiline_params">
            function <span class="apidocSignatureSpan">jscs.</span>require_aligned_multiline_params
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_aligned_multiline_params.prototype">module jscs.require_aligned_multiline_params.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_multiline_params.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_aligned_multiline_params.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_multiline_params.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_aligned_multiline_params.prototype.</span>configure
            <span class="apidocSignatureSpan">(option)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_multiline_params.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_aligned_multiline_params.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_aligned_object_values">module jscs.require_aligned_object_values</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_object_values.require_aligned_object_values">
            function <span class="apidocSignatureSpan">jscs.</span>require_aligned_object_values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_aligned_object_values.prototype">module jscs.require_aligned_object_values.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_object_values.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_aligned_object_values.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_object_values.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_aligned_object_values.prototype.</span>configure
            <span class="apidocSignatureSpan">(mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_aligned_object_values.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_aligned_object_values.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_anonymous_functions">module jscs.require_anonymous_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_anonymous_functions.require_anonymous_functions">
            function <span class="apidocSignatureSpan">jscs.</span>require_anonymous_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_anonymous_functions.prototype">module jscs.require_anonymous_functions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_anonymous_functions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_anonymous_functions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_anonymous_functions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_anonymous_functions.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_anonymous_functions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_anonymous_functions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_array_destructuring">module jscs.require_array_destructuring</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_array_destructuring.require_array_destructuring">
            function <span class="apidocSignatureSpan">jscs.</span>require_array_destructuring
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_array_destructuring.prototype">module jscs.require_array_destructuring.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_array_destructuring.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_array_destructuring.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_array_destructuring.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_array_destructuring.prototype.</span>configure
            <span class="apidocSignatureSpan">(option)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_array_destructuring.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_array_destructuring.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_arrow_functions">module jscs.require_arrow_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_arrow_functions.require_arrow_functions">
            function <span class="apidocSignatureSpan">jscs.</span>require_arrow_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_arrow_functions.prototype">module jscs.require_arrow_functions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_arrow_functions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_arrow_functions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_arrow_functions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_arrow_functions.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_arrow_functions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_arrow_functions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_blocks_on_newline">module jscs.require_blocks_on_newline</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_blocks_on_newline.require_blocks_on_newline">
            function <span class="apidocSignatureSpan">jscs.</span>require_blocks_on_newline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_blocks_on_newline.prototype">module jscs.require_blocks_on_newline.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_blocks_on_newline.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_blocks_on_newline.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_blocks_on_newline.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_blocks_on_newline.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_blocks_on_newline.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_blocks_on_newline.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_camelcase_or_uppercase_identifiers">module jscs.require_camelcase_or_uppercase_identifiers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.require_camelcase_or_uppercase_identifiers">
            function <span class="apidocSignatureSpan">jscs.</span>require_camelcase_or_uppercase_identifiers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_camelcase_or_uppercase_identifiers.prototype">module jscs.require_camelcase_or_uppercase_identifiers.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_camelcase_or_uppercase_identifiers.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_camelcase_or_uppercase_identifiers.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_camelcase_or_uppercase_identifiers.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_capitalized_comments">module jscs.require_capitalized_comments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.require_capitalized_comments">
            function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_capitalized_comments.prototype">module jscs.require_capitalized_comments.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype._getFirstChar">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_getFirstChar
            <span class="apidocSignatureSpan">(comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype._isException">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isException
            <span class="apidocSignatureSpan">(comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype._isLetter">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isLetter
            <span class="apidocSignatureSpan">(comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype._isTextBlock">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isTextBlock
            <span class="apidocSignatureSpan">(file, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype._isUrl">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isUrl
            <span class="apidocSignatureSpan">(comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype._isValid">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isValid
            <span class="apidocSignatureSpan">(comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype._shouldIgnoreIfInTheMiddle">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_shouldIgnoreIfInTheMiddle
            <span class="apidocSignatureSpan">(file, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_comments.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_capitalized_constructors">module jscs.require_capitalized_constructors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors.require_capitalized_constructors">
            function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_capitalized_constructors.prototype">module jscs.require_capitalized_constructors.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_capitalized_constructors_new">module jscs.require_capitalized_constructors_new</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors_new.require_capitalized_constructors_new">
            function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors_new
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_capitalized_constructors_new.prototype">module jscs.require_capitalized_constructors_new.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors_new.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors_new.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors_new.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors_new.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_capitalized_constructors_new.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors_new.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_comma_before_line_break">module jscs.require_comma_before_line_break</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_comma_before_line_break.require_comma_before_line_break">
            function <span class="apidocSignatureSpan">jscs.</span>require_comma_before_line_break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_comma_before_line_break.prototype">module jscs.require_comma_before_line_break.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_comma_before_line_break.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_comma_before_line_break.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_comma_before_line_break.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_comma_before_line_break.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_comma_before_line_break.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_comma_before_line_break.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_curly_braces">module jscs.require_curly_braces</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_curly_braces.require_curly_braces">
            function <span class="apidocSignatureSpan">jscs.</span>require_curly_braces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_curly_braces.prototype">module jscs.require_curly_braces.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_curly_braces.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_curly_braces.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_curly_braces.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_curly_braces.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_curly_braces.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_curly_braces.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_dollar_before_jquery_assignment">module jscs.require_dollar_before_jquery_assignment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dollar_before_jquery_assignment.require_dollar_before_jquery_assignment">
            function <span class="apidocSignatureSpan">jscs.</span>require_dollar_before_jquery_assignment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_dollar_before_jquery_assignment.prototype">module jscs.require_dollar_before_jquery_assignment.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">jscs.require_dollar_before_jquery_assignment.prototype.</span>_ignoreProperties</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_dollar_before_jquery_assignment.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_dollar_before_jquery_assignment.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_dollar_before_jquery_assignment.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_dot_notation">module jscs.require_dot_notation</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dot_notation.require_dot_notation">
            function <span class="apidocSignatureSpan">jscs.</span>require_dot_notation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_dot_notation.prototype">module jscs.require_dot_notation.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dot_notation.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_dot_notation.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dot_notation.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_dot_notation.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_dot_notation.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_dot_notation.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_early_return">module jscs.require_early_return</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_early_return.require_early_return">
            function <span class="apidocSignatureSpan">jscs.</span>require_early_return
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_early_return.prototype">module jscs.require_early_return.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_early_return.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_early_return.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_early_return.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_early_return.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_early_return.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_early_return.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_enhanced_object_literals">module jscs.require_enhanced_object_literals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_enhanced_object_literals.require_enhanced_object_literals">
            function <span class="apidocSignatureSpan">jscs.</span>require_enhanced_object_literals
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_enhanced_object_literals.prototype">module jscs.require_enhanced_object_literals.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_enhanced_object_literals.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.require_enhanced_object_literals.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_enhanced_object_literals.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_enhanced_object_literals.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_enhanced_object_literals.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_enhanced_object_literals.prototype.</span>configure
            <span class="apidocSignatureSpan">(option)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_enhanced_object_literals.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_enhanced_object_literals.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_function_declarations">module jscs.require_function_declarations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_function_declarations.require_function_declarations">
            function <span class="apidocSignatureSpan">jscs.</span>require_function_declarations
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_function_declarations.prototype">module jscs.require_function_declarations.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_function_declarations.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_function_declarations.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_function_declarations.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_function_declarations.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_function_declarations.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_function_declarations.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_imports_alphabetized">module jscs.require_imports_alphabetized</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_imports_alphabetized.require_imports_alphabetized">
            function <span class="apidocSignatureSpan">jscs.</span>require_imports_alphabetized
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_imports_alphabetized.prototype">module jscs.require_imports_alphabetized.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_imports_alphabetized.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_imports_alphabetized.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_imports_alphabetized.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_imports_alphabetized.prototype.</span>configure
            <span class="apidocSignatureSpan">(option)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_imports_alphabetized.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_imports_alphabetized.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_keywords_on_new_line">module jscs.require_keywords_on_new_line</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_keywords_on_new_line.require_keywords_on_new_line">
            function <span class="apidocSignatureSpan">jscs.</span>require_keywords_on_new_line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_keywords_on_new_line.prototype">module jscs.require_keywords_on_new_line.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_keywords_on_new_line.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_keywords_on_new_line.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_keywords_on_new_line.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_keywords_on_new_line.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_keywords_on_new_line.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_keywords_on_new_line.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_line_break_after_variable_assignment">module jscs.require_line_break_after_variable_assignment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_break_after_variable_assignment.require_line_break_after_variable_assignment">
            function <span class="apidocSignatureSpan">jscs.</span>require_line_break_after_variable_assignment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_line_break_after_variable_assignment.prototype">module jscs.require_line_break_after_variable_assignment.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_line_break_after_variable_assignment.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_line_break_after_variable_assignment.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_line_break_after_variable_assignment.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_line_feed_at_file_end">module jscs.require_line_feed_at_file_end</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_feed_at_file_end.require_line_feed_at_file_end">
            function <span class="apidocSignatureSpan">jscs.</span>require_line_feed_at_file_end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_line_feed_at_file_end.prototype">module jscs.require_line_feed_at_file_end.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_feed_at_file_end.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_line_feed_at_file_end.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_feed_at_file_end.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_line_feed_at_file_end.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_line_feed_at_file_end.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_line_feed_at_file_end.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_matching_function_name">module jscs.require_matching_function_name</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_matching_function_name.require_matching_function_name">
            function <span class="apidocSignatureSpan">jscs.</span>require_matching_function_name
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_matching_function_name.prototype">module jscs.require_matching_function_name.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_matching_function_name.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_matching_function_name.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_matching_function_name.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_matching_function_name.prototype.</span>configure
            <span class="apidocSignatureSpan">(requireMatchingFunctionName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_matching_function_name.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_matching_function_name.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_multi_line_ternary">module jscs.require_multi_line_ternary</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multi_line_ternary.require_multi_line_ternary">
            function <span class="apidocSignatureSpan">jscs.</span>require_multi_line_ternary
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_multi_line_ternary.prototype">module jscs.require_multi_line_ternary.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multi_line_ternary.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_multi_line_ternary.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multi_line_ternary.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_multi_line_ternary.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multi_line_ternary.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_multi_line_ternary.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_multiple_var_decl">module jscs.require_multiple_var_decl</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multiple_var_decl.require_multiple_var_decl">
            function <span class="apidocSignatureSpan">jscs.</span>require_multiple_var_decl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_multiple_var_decl.prototype">module jscs.require_multiple_var_decl.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multiple_var_decl.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_multiple_var_decl.prototype.</span>check
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multiple_var_decl.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_multiple_var_decl.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_multiple_var_decl.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_multiple_var_decl.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_named_unassigned_functions">module jscs.require_named_unassigned_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_named_unassigned_functions.require_named_unassigned_functions">
            function <span class="apidocSignatureSpan">jscs.</span>require_named_unassigned_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_named_unassigned_functions.prototype">module jscs.require_named_unassigned_functions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_named_unassigned_functions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_named_unassigned_functions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_named_unassigned_functions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_named_unassigned_functions.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_named_unassigned_functions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_named_unassigned_functions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_newline_before_block_statements">module jscs.require_newline_before_block_statements</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_block_statements.require_newline_before_block_statements">
            function <span class="apidocSignatureSpan">jscs.</span>require_newline_before_block_statements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_newline_before_block_statements.prototype">module jscs.require_newline_before_block_statements.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_block_statements.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_newline_before_block_statements.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_block_statements.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_newline_before_block_statements.prototype.</span>configure
            <span class="apidocSignatureSpan">(settingValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_block_statements.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_newline_before_block_statements.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_newline_before_single_statements_in_if">module jscs.require_newline_before_single_statements_in_if</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_single_statements_in_if.require_newline_before_single_statements_in_if">
            function <span class="apidocSignatureSpan">jscs.</span>require_newline_before_single_statements_in_if
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_newline_before_single_statements_in_if.prototype">module jscs.require_newline_before_single_statements_in_if.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_newline_before_single_statements_in_if.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_newline_before_single_statements_in_if.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_newline_before_single_statements_in_if.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_numeric_literals">module jscs.require_numeric_literals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_numeric_literals.require_numeric_literals">
            function <span class="apidocSignatureSpan">jscs.</span>require_numeric_literals
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_numeric_literals.prototype">module jscs.require_numeric_literals.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_numeric_literals.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_numeric_literals.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_numeric_literals.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_numeric_literals.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_numeric_literals.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_numeric_literals.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_object_destructuring">module jscs.require_object_destructuring</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_destructuring.require_object_destructuring">
            function <span class="apidocSignatureSpan">jscs.</span>require_object_destructuring
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_object_destructuring.prototype">module jscs.require_object_destructuring.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_destructuring.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_object_destructuring.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_destructuring.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_object_destructuring.prototype.</span>configure
            <span class="apidocSignatureSpan">(option)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_destructuring.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_object_destructuring.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_object_keys_on_new_line">module jscs.require_object_keys_on_new_line</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_keys_on_new_line.require_object_keys_on_new_line">
            function <span class="apidocSignatureSpan">jscs.</span>require_object_keys_on_new_line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_object_keys_on_new_line.prototype">module jscs.require_object_keys_on_new_line.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_keys_on_new_line.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_object_keys_on_new_line.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_keys_on_new_line.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_object_keys_on_new_line.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_object_keys_on_new_line.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_object_keys_on_new_line.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_operator_before_line_break">module jscs.require_operator_before_line_break</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_operator_before_line_break.require_operator_before_line_break">
            function <span class="apidocSignatureSpan">jscs.</span>require_operator_before_line_break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_operator_before_line_break.prototype">module jscs.require_operator_before_line_break.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_operator_before_line_break.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_operator_before_line_break.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_operator_before_line_break.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_operator_before_line_break.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_operator_before_line_break.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_operator_before_line_break.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newline_after_variable_declaration">module jscs.require_padding_newline_after_variable_declaration</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration.require_padding_newline_after_variable_declaration">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newline_after_variable_declaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newline_after_variable_declaration.prototype">module jscs.require_padding_newline_after_variable_declaration.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_padding_newline_after_variable_declaration.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_padding_newline_after_variable_declaration.prototype.</span>configure
            <span class="apidocSignatureSpan">(requirePaddingNewLineAfterVariableDeclaration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_padding_newline_after_variable_declaration.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_after_blocks">module jscs.require_padding_newlines_after_blocks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_blocks.require_padding_newlines_after_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_after_blocks.prototype">module jscs.require_padding_newlines_after_blocks.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_blocks.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_blocks.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_blocks.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_after_use_strict">module jscs.require_padding_newlines_after_use_strict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_use_strict.require_padding_newlines_after_use_strict">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_use_strict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_after_use_strict.prototype">module jscs.require_padding_newlines_after_use_strict.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_use_strict.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_use_strict.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_use_strict.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_before_export">module jscs.require_padding_newlines_before_export</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_export.require_padding_newlines_before_export">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_export
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_before_export.prototype">module jscs.require_padding_newlines_before_export.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_export.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_export.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_export.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_export.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_export.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_export.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_before_keywords">module jscs.require_padding_newlines_before_keywords</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_keywords.require_padding_newlines_before_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_before_keywords.prototype">module jscs.require_padding_newlines_before_keywords.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_keywords.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_keywords.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_keywords.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_before_line_comments">module jscs.require_padding_newlines_before_line_comments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_line_comments.require_padding_newlines_before_line_comments">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_line_comments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_before_line_comments.prototype">module jscs.require_padding_newlines_before_line_comments.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_line_comments.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_line_comments.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_line_comments.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_in_blocks">module jscs.require_padding_newlines_in_blocks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_blocks.require_padding_newlines_in_blocks">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_blocks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_in_blocks.prototype">module jscs.require_padding_newlines_in_blocks.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_blocks.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_blocks.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_blocks.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_in_objects">module jscs.require_padding_newlines_in_objects</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_objects.require_padding_newlines_in_objects">
            function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_objects
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_padding_newlines_in_objects.prototype">module jscs.require_padding_newlines_in_objects.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_objects.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_objects.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_objects.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_objects.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_padding_newlines_in_objects.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_objects.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_parentheses_around_arrow_param">module jscs.require_parentheses_around_arrow_param</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_arrow_param.require_parentheses_around_arrow_param">
            function <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_arrow_param
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_parentheses_around_arrow_param.prototype">module jscs.require_parentheses_around_arrow_param.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_parentheses_around_arrow_param.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_parentheses_around_arrow_param.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_parentheses_around_arrow_param.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_parentheses_around_iife">module jscs.require_parentheses_around_iife</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_iife.require_parentheses_around_iife">
            function <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_iife
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_parentheses_around_iife.prototype">module jscs.require_parentheses_around_iife.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_iife.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_parentheses_around_iife.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_iife.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_parentheses_around_iife.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_parentheses_around_iife.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_parentheses_around_iife.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_quoted_keys_in_objects">module jscs.require_quoted_keys_in_objects</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_quoted_keys_in_objects.require_quoted_keys_in_objects">
            function <span class="apidocSignatureSpan">jscs.</span>require_quoted_keys_in_objects
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_quoted_keys_in_objects.prototype">module jscs.require_quoted_keys_in_objects.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_quoted_keys_in_objects.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.require_quoted_keys_in_objects.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_quoted_keys_in_objects.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_quoted_keys_in_objects.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_quoted_keys_in_objects.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_quoted_keys_in_objects.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_quoted_keys_in_objects.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_quoted_keys_in_objects.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_semicolons">module jscs.require_semicolons</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_semicolons.require_semicolons">
            function <span class="apidocSignatureSpan">jscs.</span>require_semicolons
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_semicolons.prototype">module jscs.require_semicolons.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_semicolons.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.require_semicolons.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_semicolons.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_semicolons.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_semicolons.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_semicolons.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_semicolons.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_semicolons.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_shorthand_arrow_functions">module jscs.require_shorthand_arrow_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_shorthand_arrow_functions.require_shorthand_arrow_functions">
            function <span class="apidocSignatureSpan">jscs.</span>require_shorthand_arrow_functions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_shorthand_arrow_functions.prototype">module jscs.require_shorthand_arrow_functions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_shorthand_arrow_functions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_shorthand_arrow_functions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_shorthand_arrow_functions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_shorthand_arrow_functions.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_shorthand_arrow_functions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_shorthand_arrow_functions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_binary_operators">module jscs.require_space_after_binary_operators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_binary_operators.require_space_after_binary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_binary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_binary_operators.prototype">module jscs.require_space_after_binary_operators.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_binary_operators.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_after_binary_operators.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_binary_operators.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_after_binary_operators.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_binary_operators.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_after_binary_operators.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_comma">module jscs.require_space_after_comma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_comma.require_space_after_comma">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_comma.prototype">module jscs.require_space_after_comma.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_comma.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_after_comma.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_comma.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_after_comma.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_comma.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_after_comma.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_keywords">module jscs.require_space_after_keywords</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_keywords.require_space_after_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_keywords.prototype">module jscs.require_space_after_keywords.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_keywords.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_after_keywords.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_keywords.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_after_keywords.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_keywords.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_after_keywords.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_line_comment">module jscs.require_space_after_line_comment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_line_comment.require_space_after_line_comment">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_line_comment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_line_comment.prototype">module jscs.require_space_after_line_comment.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_line_comment.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_after_line_comment.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_line_comment.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_after_line_comment.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_line_comment.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_after_line_comment.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_object_keys">module jscs.require_space_after_object_keys</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_object_keys.require_space_after_object_keys">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_object_keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_object_keys.prototype">module jscs.require_space_after_object_keys.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_object_keys.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_after_object_keys.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_object_keys.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_after_object_keys.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_object_keys.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_after_object_keys.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_prefix_unary_operators">module jscs.require_space_after_prefix_unary_operators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_prefix_unary_operators.require_space_after_prefix_unary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_after_prefix_unary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_after_prefix_unary_operators.prototype">module jscs.require_space_after_prefix_unary_operators.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_after_prefix_unary_operators.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_after_prefix_unary_operators.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_after_prefix_unary_operators.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_binary_operators">module jscs.require_space_before_binary_operators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_binary_operators.require_space_before_binary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_binary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_binary_operators.prototype">module jscs.require_space_before_binary_operators.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_binary_operators.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_before_binary_operators.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_binary_operators.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_before_binary_operators.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_binary_operators.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_before_binary_operators.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_block_statements">module jscs.require_space_before_block_statements</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_block_statements.require_space_before_block_statements">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_block_statements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_block_statements.prototype">module jscs.require_space_before_block_statements.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_block_statements.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_before_block_statements.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_block_statements.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_before_block_statements.prototype.</span>configure
            <span class="apidocSignatureSpan">(requireSpaceBeforeBlockStatements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_block_statements.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_before_block_statements.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_comma">module jscs.require_space_before_comma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_comma.require_space_before_comma">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_comma.prototype">module jscs.require_space_before_comma.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_comma.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_before_comma.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_comma.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_before_comma.prototype.</span>configure
            <span class="apidocSignatureSpan">(option)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_comma.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_before_comma.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_destructured_values">module jscs.require_space_before_destructured_values</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_destructured_values.require_space_before_destructured_values">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_destructured_values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_destructured_values.prototype">module jscs.require_space_before_destructured_values.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_destructured_values.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_before_destructured_values.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_destructured_values.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_before_destructured_values.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_destructured_values.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_before_destructured_values.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_keywords">module jscs.require_space_before_keywords</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_keywords.require_space_before_keywords">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_keywords
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_keywords.prototype">module jscs.require_space_before_keywords.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_keywords.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_before_keywords.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_keywords.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_before_keywords.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_keywords.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_before_keywords.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_object_values">module jscs.require_space_before_object_values</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_object_values.require_space_before_object_values">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_object_values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_object_values.prototype">module jscs.require_space_before_object_values.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_object_values.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_before_object_values.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_object_values.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_before_object_values.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_object_values.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_before_object_values.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_postfix_unary_operators">module jscs.require_space_before_postfix_unary_operators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_postfix_unary_operators.require_space_before_postfix_unary_operators">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_before_postfix_unary_operators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_before_postfix_unary_operators.prototype">module jscs.require_space_before_postfix_unary_operators.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_before_postfix_unary_operators.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_before_postfix_unary_operators.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_before_postfix_unary_operators.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_between_arguments">module jscs.require_space_between_arguments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_between_arguments.require_space_between_arguments">
            function <span class="apidocSignatureSpan">jscs.</span>require_space_between_arguments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_space_between_arguments.prototype">module jscs.require_space_between_arguments.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_between_arguments.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_space_between_arguments.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_between_arguments.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_space_between_arguments.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_space_between_arguments.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_space_between_arguments.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_anonymous_function_expression">module jscs.require_spaces_in_anonymous_function_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression.require_spaces_in_anonymous_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_anonymous_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_anonymous_function_expression.prototype">module jscs.require_spaces_in_anonymous_function_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_anonymous_function_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_anonymous_function_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_anonymous_function_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_call_expression">module jscs.require_spaces_in_call_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_call_expression.require_spaces_in_call_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_call_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_call_expression.prototype">module jscs.require_spaces_in_call_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_call_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_call_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_call_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_call_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_call_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_call_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_conditional_expression">module jscs.require_spaces_in_conditional_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_conditional_expression.require_spaces_in_conditional_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_conditional_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_conditional_expression.prototype">module jscs.require_spaces_in_conditional_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_conditional_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_conditional_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_conditional_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_for_statement">module jscs.require_spaces_in_for_statement</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_for_statement.require_spaces_in_for_statement">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_for_statement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_for_statement.prototype">module jscs.require_spaces_in_for_statement.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_for_statement.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_for_statement.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_for_statement.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_for_statement.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_for_statement.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_for_statement.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_function">module jscs.require_spaces_in_function</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function.require_spaces_in_function">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_function.prototype">module jscs.require_spaces_in_function.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_function_declaration">module jscs.require_spaces_in_function_declaration</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_declaration.require_spaces_in_function_declaration">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_declaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_function_declaration.prototype">module jscs.require_spaces_in_function_declaration.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_declaration.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_declaration.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_declaration.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_declaration.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_declaration.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_declaration.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_function_expression">module jscs.require_spaces_in_function_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_expression.require_spaces_in_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_function_expression.prototype">module jscs.require_spaces_in_function_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_function_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_generator">module jscs.require_spaces_in_generator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_generator.require_spaces_in_generator">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_generator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_generator.prototype">module jscs.require_spaces_in_generator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_generator.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_generator.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_generator.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_generator.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_generator.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_generator.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_named_function_expression">module jscs.require_spaces_in_named_function_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_named_function_expression.require_spaces_in_named_function_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_named_function_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_in_named_function_expression.prototype">module jscs.require_spaces_in_named_function_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_named_function_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_named_function_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_in_named_function_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_array_brackets">module jscs.require_spaces_inside_array_brackets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_array_brackets.require_spaces_inside_array_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_array_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_array_brackets.prototype">module jscs.require_spaces_inside_array_brackets.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_array_brackets.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_array_brackets.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_array_brackets.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_brackets">module jscs.require_spaces_inside_brackets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_brackets.require_spaces_inside_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_brackets.prototype">module jscs.require_spaces_inside_brackets.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_brackets.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_brackets.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_brackets.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_brackets.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_brackets.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_brackets.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_imported_object_braces">module jscs.require_spaces_inside_imported_object_braces</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces.require_spaces_inside_imported_object_braces">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_imported_object_braces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_imported_object_braces.prototype">module jscs.require_spaces_inside_imported_object_braces.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_imported_object_braces.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_imported_object_braces.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_imported_object_braces.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_object_brackets">module jscs.require_spaces_inside_object_brackets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_object_brackets.require_spaces_inside_object_brackets">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_object_brackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_object_brackets.prototype">module jscs.require_spaces_inside_object_brackets.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_object_brackets.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_object_brackets.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_object_brackets.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_parentheses">module jscs.require_spaces_inside_parentheses</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parentheses.require_spaces_inside_parentheses">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parentheses
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_parentheses.prototype">module jscs.require_spaces_inside_parentheses.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parentheses.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parentheses.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parentheses.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parentheses.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parentheses.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parentheses.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_parenthesized_expression">module jscs.require_spaces_inside_parenthesized_expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression.require_spaces_inside_parenthesized_expression">
            function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parenthesized_expression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spaces_inside_parenthesized_expression.prototype">module jscs.require_spaces_inside_parenthesized_expression.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parenthesized_expression.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parenthesized_expression.prototype.</span>configure
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parenthesized_expression.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spread">module jscs.require_spread</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spread.require_spread">
            function <span class="apidocSignatureSpan">jscs.</span>require_spread
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_spread.prototype">module jscs.require_spread.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spread.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_spread.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spread.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_spread.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_spread.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_spread.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_template_strings">module jscs.require_template_strings</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_template_strings.require_template_strings">
            function <span class="apidocSignatureSpan">jscs.</span>require_template_strings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_template_strings.prototype">module jscs.require_template_strings.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_template_strings.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_template_strings.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_template_strings.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_template_strings.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_template_strings.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_template_strings.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_trailing_comma">module jscs.require_trailing_comma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_trailing_comma.require_trailing_comma">
            function <span class="apidocSignatureSpan">jscs.</span>require_trailing_comma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_trailing_comma.prototype">module jscs.require_trailing_comma.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_trailing_comma.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.require_trailing_comma.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_trailing_comma.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_trailing_comma.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_trailing_comma.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_trailing_comma.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_trailing_comma.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_trailing_comma.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_use_strict">module jscs.require_use_strict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_use_strict.require_use_strict">
            function <span class="apidocSignatureSpan">jscs.</span>require_use_strict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_use_strict.prototype">module jscs.require_use_strict.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_use_strict.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_use_strict.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_use_strict.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_use_strict.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_use_strict.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_use_strict.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_var_decl_first">module jscs.require_var_decl_first</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_var_decl_first.require_var_decl_first">
            function <span class="apidocSignatureSpan">jscs.</span>require_var_decl_first
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_var_decl_first.prototype">module jscs.require_var_decl_first.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_var_decl_first.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_var_decl_first.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_var_decl_first.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_var_decl_first.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_var_decl_first.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_var_decl_first.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_yoda_conditions">module jscs.require_yoda_conditions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_yoda_conditions.require_yoda_conditions">
            function <span class="apidocSignatureSpan">jscs.</span>require_yoda_conditions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.require_yoda_conditions.prototype">module jscs.require_yoda_conditions.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_yoda_conditions.prototype.check">
            function <span class="apidocSignatureSpan">jscs.require_yoda_conditions.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_yoda_conditions.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.require_yoda_conditions.prototype.</span>configure
            <span class="apidocSignatureSpan">(operators)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.require_yoda_conditions.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.require_yoda_conditions.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.safe_context_keyword">module jscs.safe_context_keyword</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.safe_context_keyword.safe_context_keyword">
            function <span class="apidocSignatureSpan">jscs.</span>safe_context_keyword
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.safe_context_keyword.prototype">module jscs.safe_context_keyword.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.safe_context_keyword.prototype.check">
            function <span class="apidocSignatureSpan">jscs.safe_context_keyword.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.safe_context_keyword.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.safe_context_keyword.prototype.</span>configure
            <span class="apidocSignatureSpan">(keywords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.safe_context_keyword.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.safe_context_keyword.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.super_">module jscs.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.super_">
            function <span class="apidocSignatureSpan">jscs.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.super_.prototype">module jscs.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype._addParseError">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_addParseError
            <span class="apidocSignatureSpan">(errors, parseError, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype._checkJsFile">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_checkJsFile
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype._createConfiguration">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_createConfiguration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype._createJsFileInstance">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_createJsFileInstance
            <span class="apidocSignatureSpan">(filename, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype._fixCommonError">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_fixCommonError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype._fixJsFile">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_fixJsFile
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype._fixSpecificError">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_fixSpecificError
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.checkString">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>checkString
            <span class="apidocSignatureSpan">(source, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>configure
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.fixString">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>fixString
            <span class="apidocSignatureSpan">(source, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.getConfiguration">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>getConfiguration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.getProcessedConfig">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>getProcessedConfig
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.maxErrorsEnabled">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>maxErrorsEnabled
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.maxErrorsExceeded">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>maxErrorsExceeded
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.registerDefaultRules">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>registerDefaultRules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.super_.prototype.registerRule">
            function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>registerRule
            <span class="apidocSignatureSpan">(rule)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.token_assert">module jscs.token_assert</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.token_assert">
            function <span class="apidocSignatureSpan">jscs.</span>token_assert
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.super_">
            function <span class="apidocSignatureSpan">jscs.token_assert.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.token_assert.prototype">module jscs.token_assert.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype._augmentLineCount">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>_augmentLineCount
            <span class="apidocSignatureSpan">(options, lineCount)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype._updateCommentWhitespace">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>_updateCommentWhitespace
            <span class="apidocSignatureSpan">(token, indentChar, actual, expected)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype._updateWhitespaceByLine">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>_updateWhitespaceByLine
            <span class="apidocSignatureSpan">(token, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype._validateOptions">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>_validateOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype.differentLine">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>differentLine
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype.indentation">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>indentation
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype.linesBetween">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>linesBetween
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype.noWhitespaceBetween">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>noWhitespaceBetween
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype.sameLine">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>sameLine
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype.spacesBetween">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>spacesBetween
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_assert.prototype.whitespaceBetween">
            function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>whitespaceBetween
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.token_categorizer">module jscs.token_categorizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_categorizer.categorizeCloseParen">
            function <span class="apidocSignatureSpan">jscs.token_categorizer.</span>categorizeCloseParen
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_categorizer.categorizeOpenParen">
            function <span class="apidocSignatureSpan">jscs.token_categorizer.</span>categorizeOpenParen
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.token_index">module jscs.token_index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_index.token_index">
            function <span class="apidocSignatureSpan">jscs.</span>token_index
            <span class="apidocSignatureSpan">(firstToken)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.token_index.prototype">module jscs.token_index.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_index.prototype._buildIndex">
            function <span class="apidocSignatureSpan">jscs.token_index.prototype.</span>_buildIndex
            <span class="apidocSignatureSpan">(firstToken)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_index.prototype.getElementLoc">
            function <span class="apidocSignatureSpan">jscs.token_index.prototype.</span>getElementLoc
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.token_index.prototype.isRuleEnabled">
            function <span class="apidocSignatureSpan">jscs.token_index.prototype.</span>isRuleEnabled
            <span class="apidocSignatureSpan">(ruleName, element)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.tree_iterator">module jscs.tree_iterator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.tree_iterator.iterate">
            function <span class="apidocSignatureSpan">jscs.tree_iterator.</span>iterate
            <span class="apidocSignatureSpan">(node, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.utils">module jscs.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.utils.getFunctionNodeFromIIFE">
            function <span class="apidocSignatureSpan">jscs.utils.</span>getFunctionNodeFromIIFE
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.utils.isPragma">
            function <span class="apidocSignatureSpan">jscs.utils.</span>isPragma
            <span class="apidocSignatureSpan">(additionalExceptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.utils.isRelativePath">
            function <span class="apidocSignatureSpan">jscs.utils.</span>isRelativePath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.utils.isSnakeCased">
            function <span class="apidocSignatureSpan">jscs.utils.</span>isSnakeCased
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.utils.isValidIdentifierName">
            function <span class="apidocSignatureSpan">jscs.utils.</span>isValidIdentifierName
            <span class="apidocSignatureSpan">(name, dialect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.utils.normalizePath">
            function <span class="apidocSignatureSpan">jscs.utils.</span>normalizePath
            <span class="apidocSignatureSpan">(filepath, basePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.utils.promisify">
            function <span class="apidocSignatureSpan">jscs.utils.</span>promisify
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.utils.trimUnderscores">
            function <span class="apidocSignatureSpan">jscs.utils.</span>trimUnderscores
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.utils.</span>binaryOperators</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.utils.</span>curlyBracedKeywords</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.utils.</span>incrementAndDecrementOperators</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.utils.</span>operators</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.utils.</span>spacedKeywords</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jscs.utils.</span>unaryOperators</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_aligned_function_parameters">module jscs.validate_aligned_function_parameters</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_aligned_function_parameters.validate_aligned_function_parameters">
            function <span class="apidocSignatureSpan">jscs.</span>validate_aligned_function_parameters
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_aligned_function_parameters.prototype">module jscs.validate_aligned_function_parameters.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_aligned_function_parameters.prototype.check">
            function <span class="apidocSignatureSpan">jscs.validate_aligned_function_parameters.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_aligned_function_parameters.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.validate_aligned_function_parameters.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_aligned_function_parameters.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.validate_aligned_function_parameters.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_comment_position">module jscs.validate_comment_position</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_comment_position.validate_comment_position">
            function <span class="apidocSignatureSpan">jscs.</span>validate_comment_position
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_comment_position.prototype">module jscs.validate_comment_position.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_comment_position.prototype.check">
            function <span class="apidocSignatureSpan">jscs.validate_comment_position.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_comment_position.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.validate_comment_position.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_comment_position.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.validate_comment_position.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_indentation">module jscs.validate_indentation</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.validate_indentation">
            function <span class="apidocSignatureSpan">jscs.</span>validate_indentation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_indentation.prototype">module jscs.validate_indentation.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.prototype._checkNode">
            function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_checkNode
            <span class="apidocSignatureSpan">(parentElement, errors, initialIndent, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.prototype._getElementDirectIndent">
            function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_getElementDirectIndent
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.prototype._getFunctionIndent">
            function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_getFunctionIndent
            <span class="apidocSignatureSpan">(functionExpression, indent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.prototype._getObjectExpressionIndent">
            function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_getObjectExpressionIndent
            <span class="apidocSignatureSpan">(objectExpression, indent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.prototype.check">
            function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_indentation.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_line_breaks">module jscs.validate_line_breaks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_line_breaks.validate_line_breaks">
            function <span class="apidocSignatureSpan">jscs.</span>validate_line_breaks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_line_breaks.prototype">module jscs.validate_line_breaks.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_line_breaks.prototype.check">
            function <span class="apidocSignatureSpan">jscs.validate_line_breaks.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_line_breaks.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.validate_line_breaks.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_line_breaks.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.validate_line_breaks.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_newline_after_array_elements">module jscs.validate_newline_after_array_elements</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_newline_after_array_elements.validate_newline_after_array_elements">
            function <span class="apidocSignatureSpan">jscs.</span>validate_newline_after_array_elements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_newline_after_array_elements.prototype">module jscs.validate_newline_after_array_elements.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_newline_after_array_elements.prototype.check">
            function <span class="apidocSignatureSpan">jscs.validate_newline_after_array_elements.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_newline_after_array_elements.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.validate_newline_after_array_elements.prototype.</span>configure
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_newline_after_array_elements.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.validate_newline_after_array_elements.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_order_in_object_keys">module jscs.validate_order_in_object_keys</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_order_in_object_keys.validate_order_in_object_keys">
            function <span class="apidocSignatureSpan">jscs.</span>validate_order_in_object_keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_order_in_object_keys.prototype">module jscs.validate_order_in_object_keys.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_order_in_object_keys.prototype.check">
            function <span class="apidocSignatureSpan">jscs.validate_order_in_object_keys.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_order_in_object_keys.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.validate_order_in_object_keys.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_order_in_object_keys.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.validate_order_in_object_keys.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_parameter_separator">module jscs.validate_parameter_separator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_parameter_separator.validate_parameter_separator">
            function <span class="apidocSignatureSpan">jscs.</span>validate_parameter_separator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_parameter_separator.prototype">module jscs.validate_parameter_separator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_parameter_separator.prototype.check">
            function <span class="apidocSignatureSpan">jscs.validate_parameter_separator.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_parameter_separator.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.validate_parameter_separator.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_parameter_separator.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.validate_parameter_separator.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_quote_marks">module jscs.validate_quote_marks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_quote_marks.validate_quote_marks">
            function <span class="apidocSignatureSpan">jscs.</span>validate_quote_marks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jscs.validate_quote_marks.prototype">module jscs.validate_quote_marks.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_quote_marks.prototype._fix">
            function <span class="apidocSignatureSpan">jscs.validate_quote_marks.prototype.</span>_fix
            <span class="apidocSignatureSpan">(file, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_quote_marks.prototype.check">
            function <span class="apidocSignatureSpan">jscs.validate_quote_marks.prototype.</span>check
            <span class="apidocSignatureSpan">(file, errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_quote_marks.prototype.configure">
            function <span class="apidocSignatureSpan">jscs.validate_quote_marks.prototype.</span>configure
            <span class="apidocSignatureSpan">(quoteMark)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jscs.validate_quote_marks.prototype.getOptionName">
            function <span class="apidocSignatureSpan">jscs.validate_quote_marks.prototype.</span>getOptionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs" id="apidoc.module.jscs">module jscs</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.jscs" id="apidoc.element.jscs.jscs">
        function <span class="apidocSignatureSpan"></span>jscs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jscs = function () {
    StringChecker.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration" id="apidoc.element.jscs.configuration">
        function <span class="apidocSignatureSpan">jscs.</span>configuration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Configuration() {
<span class="apidocCodeCommentSpan">    /**
     * List of the registered (not used) presets.
     *
     * @protected
     * @type {Object}
     */
</span>    this._presets = {};

    /**
     * Name of the preset (if used).
     *
     * @protected
     * @type {String|null}
     */
    this._presetName = null;

    /**
     * List of loaded presets.
     *
     * @protected
     * @type {String|null}
     */
    this._loadedPresets = [];

    /**
     * List of rules instances.
     *
     * @protected
     * @type {Object}
     */
    this._rules = {};

    /**
     * List of configurated rule instances.
     *
     * @protected
     * @type {Object}
     */
    this._ruleSettings = {};

    /**
     * List of configured rules.
     *
     * @protected
     * @type {Array}
     */
    this._configuredRules = [];

    /**
     * List of unsupported rules.
     *
     * @protected
     * @type {Array}
     */
    this._unsupportedRuleNames = [];

    /**
     * File extensions that would be checked.
     *
     * @protected
     * @type {Array}
     */
    this._fileExtensions = [];

    /**
     * List of defined options (not complete).
     *
     * @protected
     * @type {Array}
     */
    this._definedOptions = [];

    /**
     * Default file extensions that would be checked.
     *
     * @protected
     * @type {Array}
     */
    this._defaultFileExtensions = ['.js'];

    /**
     * Exclusion masks.
     *
     * @protected
     * @type {Array}
     */
    this._excludedFileMasks = [];

    /**
     * Default exclusion masks, will be rewritten if user has their own masks.
     *
     * @protected
     * @type {Array}
     */
    this._defaultExcludedFileMasks = ['.git/**', 'node_modules/**'];

    /**
     * List of existing files that falls under exclusion masks.
     *
     * @protected
     * @type {Array}
     */
    this._excludedFileMatchers = [];

    /**
     * Extraction masks.
     *
     * @protected
     * @type {Array}
     */
    this._extractFileMasks = [];

    /**
     * Default extractions masks.
     *
     * @protected
     * @type {Array}
     */
    this._defaultExtractFileMasks = ['**/*.+(htm|html|xhtml)'];

    /**
     * List of file matchers from which to extract JavaScript.
     *
     * @protected
     * @type {Array}
     */
    this._extractFileMatchers = [];

    /**
     * Maxixum amount of error that would be reportered.
     *
     * @protected
     * @type {Number}
     */
    this._maxErrors = defaults.maxErrors;

    /**
     * JSCS CWD.
     *
     * @protected
     * @type {String}
     */
    this._basePath = defaults.cwd;

    /**
     * List of overrided options (usually from CLI).
     *
     * @protected
     * @type {Object}
     */
    this._overrides = {};

    /**
     * Is "ES3" mode enabled?.
     *
     * @protected
     * @type {Boolean}
     */
    this._es3Enabled = false;

    /**
     * A filter function that determines whether or not to report an error.
     *
     * @protected
     * @type {Function|null}
     */
    this._errorFilter = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_anonymous_functions" id="apidoc.element.jscs.disallow_anonymous_functions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_anonymous_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_anonymous_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_array_destructuring_return" id="apidoc.element.jscs.disallow_array_destructuring_return">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_array_destructuring_return
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_array_destructuring_return = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_arrow_functions" id="apidoc.element.jscs.disallow_arrow_functions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_arrow_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_arrow_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_capitalized_comments" id="apidoc.element.jscs.disallow_capitalized_comments">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_capitalized_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_capitalized_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_comma_before_line_break" id="apidoc.element.jscs.disallow_comma_before_line_break">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_comma_before_line_break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_comma_before_line_break = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_curly_braces" id="apidoc.element.jscs.disallow_curly_braces">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_curly_braces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_curly_braces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_dangling_underscores" id="apidoc.element.jscs.disallow_dangling_underscores">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_dangling_underscores
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_dangling_underscores = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_empty_blocks" id="apidoc.element.jscs.disallow_empty_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_empty_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_empty_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_function_declarations" id="apidoc.element.jscs.disallow_function_declarations">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_function_declarations
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_function_declarations = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_identical_destructuring_names" id="apidoc.element.jscs.disallow_identical_destructuring_names">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_identical_destructuring_names
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_identical_destructuring_names = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_identifier_names" id="apidoc.element.jscs.disallow_identifier_names">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_identifier_names
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_identifier_names = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_implicit_type_conversion" id="apidoc.element.jscs.disallow_implicit_type_conversion">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_implicit_type_conversion
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_implicit_type_conversion = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords" id="apidoc.element.jscs.disallow_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_in_comments" id="apidoc.element.jscs.disallow_keywords_in_comments">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_in_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_keywords_in_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_on_new_line" id="apidoc.element.jscs.disallow_keywords_on_new_line">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_on_new_line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_keywords_on_new_line = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs" id="apidoc.element.jscs.disallow_mixed_spaces_and_tabs">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_mixed_spaces_and_tabs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_mixed_spaces_and_tabs = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multi_line_ternary" id="apidoc.element.jscs.disallow_multi_line_ternary">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multi_line_ternary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multi_line_ternary = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_breaks" id="apidoc.element.jscs.disallow_multiple_line_breaks">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_breaks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multiple_line_breaks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_strings" id="apidoc.element.jscs.disallow_multiple_line_strings">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_strings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multiple_line_strings = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_spaces" id="apidoc.element.jscs.disallow_multiple_spaces">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_spaces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multiple_spaces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_var_decl" id="apidoc.element.jscs.disallow_multiple_var_decl">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_var_decl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multiple_var_decl = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_named_unassigned_functions" id="apidoc.element.jscs.disallow_named_unassigned_functions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_named_unassigned_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_named_unassigned_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_nested_ternaries" id="apidoc.element.jscs.disallow_nested_ternaries">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_nested_ternaries
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_nested_ternaries = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_newline_before_block_statements" id="apidoc.element.jscs.disallow_newline_before_block_statements">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_newline_before_block_statements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_newline_before_block_statements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_node_types" id="apidoc.element.jscs.disallow_node_types">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_node_types
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_node_types = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_not_operators_in_conditionals" id="apidoc.element.jscs.disallow_not_operators_in_conditionals">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_not_operators_in_conditionals
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_not_operators_in_conditionals = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_object_keys_on_new_line" id="apidoc.element.jscs.disallow_object_keys_on_new_line">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_object_keys_on_new_line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_object_keys_on_new_line = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_operator_before_line_break" id="apidoc.element.jscs.disallow_operator_before_line_break">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_operator_before_line_break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_operator_before_line_break = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks" id="apidoc.element.jscs.disallow_padding_newlines_after_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_after_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict" id="apidoc.element.jscs.disallow_padding_newlines_after_use_strict">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_use_strict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_after_use_strict = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_export" id="apidoc.element.jscs.disallow_padding_newlines_before_export">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_export
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_before_export = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords" id="apidoc.element.jscs.disallow_padding_newlines_before_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_before_keywords = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments" id="apidoc.element.jscs.disallow_padding_newlines_before_line_comments">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_line_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_before_line_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks" id="apidoc.element.jscs.disallow_padding_newlines_in_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_in_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_objects" id="apidoc.element.jscs.disallow_padding_newlines_in_objects">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_objects
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_in_objects = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param" id="apidoc.element.jscs.disallow_parentheses_around_arrow_param">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_parentheses_around_arrow_param
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_parentheses_around_arrow_param = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_quoted_keys_in_objects" id="apidoc.element.jscs.disallow_quoted_keys_in_objects">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_quoted_keys_in_objects
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_quoted_keys_in_objects = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_semicolons" id="apidoc.element.jscs.disallow_semicolons">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_semicolons
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_semicolons = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_shorthand_arrow_functions" id="apidoc.element.jscs.disallow_shorthand_arrow_functions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_shorthand_arrow_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_shorthand_arrow_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_binary_operators" id="apidoc.element.jscs.disallow_space_after_binary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_binary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_binary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_comma" id="apidoc.element.jscs.disallow_space_after_comma">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_comma = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_keywords" id="apidoc.element.jscs.disallow_space_after_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_line_comment" id="apidoc.element.jscs.disallow_space_after_line_comment">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_line_comment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_line_comment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_object_keys" id="apidoc.element.jscs.disallow_space_after_object_keys">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_object_keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_object_keys = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators" id="apidoc.element.jscs.disallow_space_after_prefix_unary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_prefix_unary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_prefix_unary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_binary_operators" id="apidoc.element.jscs.disallow_space_before_binary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_binary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_binary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_block_statements" id="apidoc.element.jscs.disallow_space_before_block_statements">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_block_statements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_block_statements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_comma" id="apidoc.element.jscs.disallow_space_before_comma">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_comma = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_keywords" id="apidoc.element.jscs.disallow_space_before_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_object_values" id="apidoc.element.jscs.disallow_space_before_object_values">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_object_values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_object_values = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators" id="apidoc.element.jscs.disallow_space_before_postfix_unary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_postfix_unary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_postfix_unary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_semicolon" id="apidoc.element.jscs.disallow_space_before_semicolon">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_semicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_semicolon = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_between_arguments" id="apidoc.element.jscs.disallow_space_between_arguments">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_between_arguments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_between_arguments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression" id="apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_anonymous_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_anonymous_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_call_expression" id="apidoc.element.jscs.disallow_spaces_in_call_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_call_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_call_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression" id="apidoc.element.jscs.disallow_spaces_in_conditional_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_conditional_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_conditional_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_for_statement" id="apidoc.element.jscs.disallow_spaces_in_for_statement">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_for_statement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_for_statement = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function" id="apidoc.element.jscs.disallow_spaces_in_function">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_function = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_declaration" id="apidoc.element.jscs.disallow_spaces_in_function_declaration">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_declaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_function_declaration = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_expression" id="apidoc.element.jscs.disallow_spaces_in_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_generator" id="apidoc.element.jscs.disallow_spaces_in_generator">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_generator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_generator = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression" id="apidoc.element.jscs.disallow_spaces_in_named_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_named_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_named_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets" id="apidoc.element.jscs.disallow_spaces_inside_array_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_array_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_array_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_brackets" id="apidoc.element.jscs.disallow_spaces_inside_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces" id="apidoc.element.jscs.disallow_spaces_inside_imported_object_braces">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_imported_object_braces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_imported_object_braces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets" id="apidoc.element.jscs.disallow_spaces_inside_object_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_object_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_object_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parentheses" id="apidoc.element.jscs.disallow_spaces_inside_parentheses">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parentheses
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_parentheses = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression" id="apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parenthesized_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_parenthesized_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders" id="apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_template_string_placeholders
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_template_string_placeholders = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_tabs" id="apidoc.element.jscs.disallow_tabs">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_tabs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_tabs = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_comma" id="apidoc.element.jscs.disallow_trailing_comma">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_trailing_comma = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_whitespace" id="apidoc.element.jscs.disallow_trailing_whitespace">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_whitespace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_trailing_whitespace = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_params" id="apidoc.element.jscs.disallow_unused_params">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_unused_params
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_unused_params = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_variables" id="apidoc.element.jscs.disallow_unused_variables">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_unused_variables
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_unused_variables = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_var" id="apidoc.element.jscs.disallow_var">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_var
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_var = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_yoda_conditions" id="apidoc.element.jscs.disallow_yoda_conditions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_yoda_conditions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_yoda_conditions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors" id="apidoc.element.jscs.errors">
        function <span class="apidocSignatureSpan">jscs.</span>errors
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errors = function (file) {
    this._errorList = [];
    this._file = file;
    this._currentRule = '';

<span class="apidocCodeCommentSpan">    /**
     * @type {TokenAssert}
     * @public
     */
</span>    this.assert = new TokenAssert(file);
    this.assert.on('error', this._addError.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.generator" id="apidoc.element.jscs.generator">
        function <span class="apidocSignatureSpan">jscs.</span>generator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Generator() {
    this._config = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file" id="apidoc.element.jscs.js_file">
        function <span class="apidocSignatureSpan">jscs.</span>js_file
        <span class="apidocSignatureSpan">(params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">js_file = function (params) {
    params = params || {};
    this._parseErrors = [];
    this._filename = params.filename;
    this._source = params.source;

    this._es3 = params.es3 || false;

    this._lineBreaks = null;
    this._lines = this._source.split(/\r\n|\r|\n/);

    var parser = new Parser({
        strictMode: false,
        languageExtensions: {
            gritDirectives: true,
            appleInstrumentationDirectives: true
        }
    });

    try {
        this._program = parser.parse(this._source);
    } catch (e) {
        this._parseErrors.push(e);
        this._program = new Program([
            new Token('EOF', '')
        ]);
    }

    // Lazy initialization
    this._scopes = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.jsdoc" id="apidoc.element.jscs.jsdoc">
        function <span class="apidocSignatureSpan">jscs.</span>jsdoc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsdoc = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.maximum_line_length" id="apidoc.element.jscs.maximum_line_length">
        function <span class="apidocSignatureSpan">jscs.</span>maximum_line_length
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maximum_line_length = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.maximum_number_of_lines" id="apidoc.element.jscs.maximum_number_of_lines">
        function <span class="apidocSignatureSpan">jscs.</span>maximum_number_of_lines
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maximum_number_of_lines = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.node_configuration" id="apidoc.element.jscs.node_configuration">
        function <span class="apidocSignatureSpan">jscs.</span>node_configuration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodeConfiguration() {
    Configuration.call(this);
    this._basePath = process.cwd();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_aligned_multiline_params" id="apidoc.element.jscs.require_aligned_multiline_params">
        function <span class="apidocSignatureSpan">jscs.</span>require_aligned_multiline_params
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_aligned_multiline_params = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_aligned_object_values" id="apidoc.element.jscs.require_aligned_object_values">
        function <span class="apidocSignatureSpan">jscs.</span>require_aligned_object_values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_aligned_object_values = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_anonymous_functions" id="apidoc.element.jscs.require_anonymous_functions">
        function <span class="apidocSignatureSpan">jscs.</span>require_anonymous_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_anonymous_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_array_destructuring" id="apidoc.element.jscs.require_array_destructuring">
        function <span class="apidocSignatureSpan">jscs.</span>require_array_destructuring
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_array_destructuring = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_arrow_functions" id="apidoc.element.jscs.require_arrow_functions">
        function <span class="apidocSignatureSpan">jscs.</span>require_arrow_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_arrow_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_blocks_on_newline" id="apidoc.element.jscs.require_blocks_on_newline">
        function <span class="apidocSignatureSpan">jscs.</span>require_blocks_on_newline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_blocks_on_newline = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers" id="apidoc.element.jscs.require_camelcase_or_uppercase_identifiers">
        function <span class="apidocSignatureSpan">jscs.</span>require_camelcase_or_uppercase_identifiers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_camelcase_or_uppercase_identifiers = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments" id="apidoc.element.jscs.require_capitalized_comments">
        function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_capitalized_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors" id="apidoc.element.jscs.require_capitalized_constructors">
        function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_capitalized_constructors = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors_new" id="apidoc.element.jscs.require_capitalized_constructors_new">
        function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors_new
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_capitalized_constructors_new = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_comma_before_line_break" id="apidoc.element.jscs.require_comma_before_line_break">
        function <span class="apidocSignatureSpan">jscs.</span>require_comma_before_line_break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_comma_before_line_break = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_curly_braces" id="apidoc.element.jscs.require_curly_braces">
        function <span class="apidocSignatureSpan">jscs.</span>require_curly_braces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_curly_braces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_dollar_before_jquery_assignment" id="apidoc.element.jscs.require_dollar_before_jquery_assignment">
        function <span class="apidocSignatureSpan">jscs.</span>require_dollar_before_jquery_assignment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_dollar_before_jquery_assignment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_dot_notation" id="apidoc.element.jscs.require_dot_notation">
        function <span class="apidocSignatureSpan">jscs.</span>require_dot_notation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_dot_notation = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_early_return" id="apidoc.element.jscs.require_early_return">
        function <span class="apidocSignatureSpan">jscs.</span>require_early_return
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_early_return = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_enhanced_object_literals" id="apidoc.element.jscs.require_enhanced_object_literals">
        function <span class="apidocSignatureSpan">jscs.</span>require_enhanced_object_literals
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_enhanced_object_literals = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_function_declarations" id="apidoc.element.jscs.require_function_declarations">
        function <span class="apidocSignatureSpan">jscs.</span>require_function_declarations
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_function_declarations = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_imports_alphabetized" id="apidoc.element.jscs.require_imports_alphabetized">
        function <span class="apidocSignatureSpan">jscs.</span>require_imports_alphabetized
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_imports_alphabetized = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_keywords_on_new_line" id="apidoc.element.jscs.require_keywords_on_new_line">
        function <span class="apidocSignatureSpan">jscs.</span>require_keywords_on_new_line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_keywords_on_new_line = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_line_break_after_variable_assignment" id="apidoc.element.jscs.require_line_break_after_variable_assignment">
        function <span class="apidocSignatureSpan">jscs.</span>require_line_break_after_variable_assignment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_line_break_after_variable_assignment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_line_feed_at_file_end" id="apidoc.element.jscs.require_line_feed_at_file_end">
        function <span class="apidocSignatureSpan">jscs.</span>require_line_feed_at_file_end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_line_feed_at_file_end = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_matching_function_name" id="apidoc.element.jscs.require_matching_function_name">
        function <span class="apidocSignatureSpan">jscs.</span>require_matching_function_name
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_matching_function_name = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_multi_line_ternary" id="apidoc.element.jscs.require_multi_line_ternary">
        function <span class="apidocSignatureSpan">jscs.</span>require_multi_line_ternary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_multi_line_ternary = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_multiple_var_decl" id="apidoc.element.jscs.require_multiple_var_decl">
        function <span class="apidocSignatureSpan">jscs.</span>require_multiple_var_decl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_multiple_var_decl = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_named_unassigned_functions" id="apidoc.element.jscs.require_named_unassigned_functions">
        function <span class="apidocSignatureSpan">jscs.</span>require_named_unassigned_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_named_unassigned_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_block_statements" id="apidoc.element.jscs.require_newline_before_block_statements">
        function <span class="apidocSignatureSpan">jscs.</span>require_newline_before_block_statements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_newline_before_block_statements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_single_statements_in_if" id="apidoc.element.jscs.require_newline_before_single_statements_in_if">
        function <span class="apidocSignatureSpan">jscs.</span>require_newline_before_single_statements_in_if
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_newline_before_single_statements_in_if = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_numeric_literals" id="apidoc.element.jscs.require_numeric_literals">
        function <span class="apidocSignatureSpan">jscs.</span>require_numeric_literals
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_numeric_literals = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_object_destructuring" id="apidoc.element.jscs.require_object_destructuring">
        function <span class="apidocSignatureSpan">jscs.</span>require_object_destructuring
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_object_destructuring = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_object_keys_on_new_line" id="apidoc.element.jscs.require_object_keys_on_new_line">
        function <span class="apidocSignatureSpan">jscs.</span>require_object_keys_on_new_line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_object_keys_on_new_line = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_operator_before_line_break" id="apidoc.element.jscs.require_operator_before_line_break">
        function <span class="apidocSignatureSpan">jscs.</span>require_operator_before_line_break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_operator_before_line_break = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration" id="apidoc.element.jscs.require_padding_newline_after_variable_declaration">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newline_after_variable_declaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newline_after_variable_declaration = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_blocks" id="apidoc.element.jscs.require_padding_newlines_after_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_after_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_use_strict" id="apidoc.element.jscs.require_padding_newlines_after_use_strict">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_use_strict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_after_use_strict = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_export" id="apidoc.element.jscs.require_padding_newlines_before_export">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_export
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_before_export = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_keywords" id="apidoc.element.jscs.require_padding_newlines_before_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_before_keywords = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_line_comments" id="apidoc.element.jscs.require_padding_newlines_before_line_comments">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_line_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_before_line_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_blocks" id="apidoc.element.jscs.require_padding_newlines_in_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_in_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_objects" id="apidoc.element.jscs.require_padding_newlines_in_objects">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_objects
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_in_objects = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_arrow_param" id="apidoc.element.jscs.require_parentheses_around_arrow_param">
        function <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_arrow_param
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_parentheses_around_arrow_param = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_iife" id="apidoc.element.jscs.require_parentheses_around_iife">
        function <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_iife
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_parentheses_around_iife = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_quoted_keys_in_objects" id="apidoc.element.jscs.require_quoted_keys_in_objects">
        function <span class="apidocSignatureSpan">jscs.</span>require_quoted_keys_in_objects
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_quoted_keys_in_objects = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_semicolons" id="apidoc.element.jscs.require_semicolons">
        function <span class="apidocSignatureSpan">jscs.</span>require_semicolons
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_semicolons = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_shorthand_arrow_functions" id="apidoc.element.jscs.require_shorthand_arrow_functions">
        function <span class="apidocSignatureSpan">jscs.</span>require_shorthand_arrow_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_shorthand_arrow_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_binary_operators" id="apidoc.element.jscs.require_space_after_binary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_binary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_binary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_comma" id="apidoc.element.jscs.require_space_after_comma">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_comma = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_keywords" id="apidoc.element.jscs.require_space_after_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_line_comment" id="apidoc.element.jscs.require_space_after_line_comment">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_line_comment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_line_comment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_object_keys" id="apidoc.element.jscs.require_space_after_object_keys">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_object_keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_object_keys = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_prefix_unary_operators" id="apidoc.element.jscs.require_space_after_prefix_unary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_prefix_unary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_prefix_unary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_binary_operators" id="apidoc.element.jscs.require_space_before_binary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_binary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_binary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_block_statements" id="apidoc.element.jscs.require_space_before_block_statements">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_block_statements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_block_statements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_comma" id="apidoc.element.jscs.require_space_before_comma">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_comma = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_destructured_values" id="apidoc.element.jscs.require_space_before_destructured_values">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_destructured_values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_destructured_values = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_keywords" id="apidoc.element.jscs.require_space_before_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_object_values" id="apidoc.element.jscs.require_space_before_object_values">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_object_values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_object_values = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_postfix_unary_operators" id="apidoc.element.jscs.require_space_before_postfix_unary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_postfix_unary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_postfix_unary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_between_arguments" id="apidoc.element.jscs.require_space_between_arguments">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_between_arguments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_between_arguments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression" id="apidoc.element.jscs.require_spaces_in_anonymous_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_anonymous_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_anonymous_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_call_expression" id="apidoc.element.jscs.require_spaces_in_call_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_call_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_call_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_conditional_expression" id="apidoc.element.jscs.require_spaces_in_conditional_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_conditional_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_conditional_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_for_statement" id="apidoc.element.jscs.require_spaces_in_for_statement">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_for_statement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_for_statement = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function" id="apidoc.element.jscs.require_spaces_in_function">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_function = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_declaration" id="apidoc.element.jscs.require_spaces_in_function_declaration">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_declaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_function_declaration = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_expression" id="apidoc.element.jscs.require_spaces_in_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_generator" id="apidoc.element.jscs.require_spaces_in_generator">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_generator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_generator = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_named_function_expression" id="apidoc.element.jscs.require_spaces_in_named_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_named_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_named_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_array_brackets" id="apidoc.element.jscs.require_spaces_inside_array_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_array_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_array_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_brackets" id="apidoc.element.jscs.require_spaces_inside_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces" id="apidoc.element.jscs.require_spaces_inside_imported_object_braces">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_imported_object_braces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_imported_object_braces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_object_brackets" id="apidoc.element.jscs.require_spaces_inside_object_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_object_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_object_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parentheses" id="apidoc.element.jscs.require_spaces_inside_parentheses">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parentheses
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_parentheses = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression" id="apidoc.element.jscs.require_spaces_inside_parenthesized_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parenthesized_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_parenthesized_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spread" id="apidoc.element.jscs.require_spread">
        function <span class="apidocSignatureSpan">jscs.</span>require_spread
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spread = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_template_strings" id="apidoc.element.jscs.require_template_strings">
        function <span class="apidocSignatureSpan">jscs.</span>require_template_strings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_template_strings = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_trailing_comma" id="apidoc.element.jscs.require_trailing_comma">
        function <span class="apidocSignatureSpan">jscs.</span>require_trailing_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_trailing_comma = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_use_strict" id="apidoc.element.jscs.require_use_strict">
        function <span class="apidocSignatureSpan">jscs.</span>require_use_strict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_use_strict = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_var_decl_first" id="apidoc.element.jscs.require_var_decl_first">
        function <span class="apidocSignatureSpan">jscs.</span>require_var_decl_first
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_var_decl_first = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_yoda_conditions" id="apidoc.element.jscs.require_yoda_conditions">
        function <span class="apidocSignatureSpan">jscs.</span>require_yoda_conditions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_yoda_conditions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.safe_context_keyword" id="apidoc.element.jscs.safe_context_keyword">
        function <span class="apidocSignatureSpan">jscs.</span>safe_context_keyword
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">safe_context_keyword = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_" id="apidoc.element.jscs.super_">
        function <span class="apidocSignatureSpan">jscs.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {
    this._configuredRules = [];

    this._errorsFound = 0;
    this._maxErrorsExceeded = false;

    this._configuration = this._createConfiguration();
    this._configuration.registerDefaultPresets();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert" id="apidoc.element.jscs.token_assert">
        function <span class="apidocSignatureSpan">jscs.</span>token_assert
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenAssert(file) {
    EventEmitter.call(this);

    this._file = file;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_index" id="apidoc.element.jscs.token_index">
        function <span class="apidocSignatureSpan">jscs.</span>token_index
        <span class="apidocSignatureSpan">(firstToken)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenIndex(firstToken) {
    this._buildIndex(firstToken);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_aligned_function_parameters" id="apidoc.element.jscs.validate_aligned_function_parameters">
        function <span class="apidocSignatureSpan">jscs.</span>validate_aligned_function_parameters
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_aligned_function_parameters = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_comment_position" id="apidoc.element.jscs.validate_comment_position">
        function <span class="apidocSignatureSpan">jscs.</span>validate_comment_position
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_comment_position = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_indentation" id="apidoc.element.jscs.validate_indentation">
        function <span class="apidocSignatureSpan">jscs.</span>validate_indentation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_indentation = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_line_breaks" id="apidoc.element.jscs.validate_line_breaks">
        function <span class="apidocSignatureSpan">jscs.</span>validate_line_breaks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_line_breaks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_newline_after_array_elements" id="apidoc.element.jscs.validate_newline_after_array_elements">
        function <span class="apidocSignatureSpan">jscs.</span>validate_newline_after_array_elements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_newline_after_array_elements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_order_in_object_keys" id="apidoc.element.jscs.validate_order_in_object_keys">
        function <span class="apidocSignatureSpan">jscs.</span>validate_order_in_object_keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_order_in_object_keys = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_parameter_separator" id="apidoc.element.jscs.validate_parameter_separator">
        function <span class="apidocSignatureSpan">jscs.</span>validate_parameter_separator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_parameter_separator = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_quote_marks" id="apidoc.element.jscs.validate_quote_marks">
        function <span class="apidocSignatureSpan">jscs.</span>validate_quote_marks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_quote_marks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








































































































































































































































































































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.cli_config" id="apidoc.module.jscs.cli_config">module jscs.cli_config</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.cli_config.getContent" id="apidoc.element.jscs.cli_config.getContent">
        function <span class="apidocSignatureSpan">jscs.cli_config.</span>getContent
        <span class="apidocSignatureSpan">(config, directory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContent = function (config, directory) {
    if (!config) {
        return;
    }

    if (!directory) {
        directory = process.cwd();
    }

    var configPath = path.resolve(directory, config);
    var ext;
    var data;
    var content;
    var requireConfigPath;

    if (fs.existsSync(configPath)) {
        config = path.basename(config);
        ext = path.extname(configPath);

        if (ext === '.js') {
            content = require(configPath);
        } else {
            data = stripBOM(fs.readFileSync(configPath, 'utf8'));

            if (ext === '.json') {
                content = parseJson(stripJSONComments(data));
            } else if (ext === '.yaml') {
                content = yaml.safeLoad(data);
            } else {
                // try both JSON and YAML

                try {
                    content = parseJson(stripJSONComments(data));
                } catch (jsonError) {
                    try {
                        content = yaml.safeLoad(data);
                    } catch (yamlError) {
                        if (stripJSONComments(data).trim()[0] === '{') {
                            // the intention was probably JSON
                            throw jsonError;
                        } else {
                            // assume the intention was YAML
                            throw yamlError;
                        }
                    }
                }
            }
        }
    } else {
        // Try to load it as a node module
        try {
            requireConfigPath = resolve.sync(config, { basedir: directory });
            content = require(requireConfigPath);
        } catch (e) {}
    }

    if (content) {
        // Adding property via Object.defineProperty makes it
        // non-enumerable and avoids warning for unsupported rules
        Object.defineProperty(content, 'configPath', {
            value: requireConfigPath || configPath
        });
    }

    return content &amp;&amp; config === 'package.json' ? content.jscsConfig : content;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
exports.load = function(config, cwd) {
var content;
var directory = cwd || process.cwd();

// If config option is given, attempt to load it
if (config) {
    return this.<span class="apidocCodeKeywordSpan">getContent</span>(config, directory);
}

content = this.getContent(
    findup(configs, { nocase: true, cwd: directory }, function(configPath) {
        if (path.basename(configPath) === 'package.json') {
            return !!this.getContent(configPath);
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.cli_config.getReporter" id="apidoc.element.jscs.cli_config.getReporter">
        function <span class="apidocSignatureSpan">jscs.cli_config.</span>getReporter
        <span class="apidocSignatureSpan">(reporter, colors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getReporter = function (reporter, colors) {
    var writerPath;
    var writer;

    if (colors !== false) {
        colors = true;
    }

    if (reporter) {
        // ensure reporter is a string (and allow non-string types to be coerced)
        reporter = reporter.toString();
        writerPath = path.resolve(process.cwd(), reporter);

        if (!fs.existsSync(writerPath)) {
            writerPath = path.resolve(__dirname, './reporters/' + reporter);
        }
    } else {
        writerPath = path.resolve(
            __dirname, './reporters/', (colors &amp;&amp; supportsColor ? 'console' : 'text')
        );
    }

    try {
        writer = require(writerPath);
    } catch (e) {
        writer = null;
    }

    if (!writer) {
        try {
            writer = require(reporter);
            writerPath = reporter;
        } catch (e) {}
    }

    return {
        path: writerPath,
        writer: writer
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!args.length &amp;&amp; process.stdin.isTTY &amp;&amp; typeof program.autoConfigure !== 'string') {
    console.error('No input files specified. Try option --help for usage information.');
    defer.reject(3);

    return returnArgs;
}

reporter = configFile.<span class="apidocCodeKeywordSpan">getReporter</span>(program.reporter, program.colors);

returnArgs.reporter = reporter.path;

if (!reporter.writer) {
    console.error('Reporter "%s" does not exist.', program.reporter);
    returnArgs.reporter = reporter.path;
    defer.reject(6);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.cli_config.load" id="apidoc.element.jscs.cli_config.load">
        function <span class="apidocSignatureSpan">jscs.cli_config.</span>load
        <span class="apidocSignatureSpan">(config, cwd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (config, cwd) {
    var content;
    var directory = cwd || process.cwd();

    // If config option is given, attempt to load it
    if (config) {
        return this.getContent(config, directory);
    }

    content = this.getContent(
        findup(configs, { nocase: true, cwd: directory }, function(configPath) {
            if (path.basename(configPath) === 'package.json') {
                return !!this.getContent(configPath);
            }

            return true;
        }.bind(this))
    );

    if (content) {
        return content;
    }

    // Try to load standard configs from home dir
    var directoryArr = [process.env.USERPROFILE, process.env.HOMEPATH, process.env.HOME];
    for (var i = 0, dirLen = directoryArr.length; i &lt; dirLen; i++) {
        if (!directoryArr[i]) {
            continue;
        }

        for (var j = 0, len = configs.length; j &lt; len; j++) {
            content = this.getContent(configs[j], directoryArr[i]);

            if (content) {
                return content;
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

promise.always(function(status) {
    exit(status.valueOf());
});

try {
    config = configFile.<span class="apidocCodeKeywordSpan">load</span>(program.config);
} catch (e) {
    console.error('Config source is corrupted -', e.toString());
    defer.reject(5);

    return returnArgs;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.configuration" id="apidoc.module.jscs.configuration">module jscs.configuration</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.configuration.configuration" id="apidoc.element.jscs.configuration.configuration">
        function <span class="apidocSignatureSpan">jscs.</span>configuration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Configuration() {
<span class="apidocCodeCommentSpan">    /**
     * List of the registered (not used) presets.
     *
     * @protected
     * @type {Object}
     */
</span>    this._presets = {};

    /**
     * Name of the preset (if used).
     *
     * @protected
     * @type {String|null}
     */
    this._presetName = null;

    /**
     * List of loaded presets.
     *
     * @protected
     * @type {String|null}
     */
    this._loadedPresets = [];

    /**
     * List of rules instances.
     *
     * @protected
     * @type {Object}
     */
    this._rules = {};

    /**
     * List of configurated rule instances.
     *
     * @protected
     * @type {Object}
     */
    this._ruleSettings = {};

    /**
     * List of configured rules.
     *
     * @protected
     * @type {Array}
     */
    this._configuredRules = [];

    /**
     * List of unsupported rules.
     *
     * @protected
     * @type {Array}
     */
    this._unsupportedRuleNames = [];

    /**
     * File extensions that would be checked.
     *
     * @protected
     * @type {Array}
     */
    this._fileExtensions = [];

    /**
     * List of defined options (not complete).
     *
     * @protected
     * @type {Array}
     */
    this._definedOptions = [];

    /**
     * Default file extensions that would be checked.
     *
     * @protected
     * @type {Array}
     */
    this._defaultFileExtensions = ['.js'];

    /**
     * Exclusion masks.
     *
     * @protected
     * @type {Array}
     */
    this._excludedFileMasks = [];

    /**
     * Default exclusion masks, will be rewritten if user has their own masks.
     *
     * @protected
     * @type {Array}
     */
    this._defaultExcludedFileMasks = ['.git/**', 'node_modules/**'];

    /**
     * List of existing files that falls under exclusion masks.
     *
     * @protected
     * @type {Array}
     */
    this._excludedFileMatchers = [];

    /**
     * Extraction masks.
     *
     * @protected
     * @type {Array}
     */
    this._extractFileMasks = [];

    /**
     * Default extractions masks.
     *
     * @protected
     * @type {Array}
     */
    this._defaultExtractFileMasks = ['**/*.+(htm|html|xhtml)'];

    /**
     * List of file matchers from which to extract JavaScript.
     *
     * @protected
     * @type {Array}
     */
    this._extractFileMatchers = [];

    /**
     * Maxixum amount of error that would be reportered.
     *
     * @protected
     * @type {Number}
     */
    this._maxErrors = defaults.maxErrors;

    /**
     * JSCS CWD.
     *
     * @protected
     * @type {String}
     */
    this._basePath = defaults.cwd;

    /**
     * List of overrided options (usually from CLI).
     *
     * @protected
     * @type {Object}
     */
    this._overrides = {};

    /**
     * Is "ES3" mode enabled?.
     *
     * @protected
     * @type {Boolean}
     */
    this._es3Enabled = false;

    /**
     * A filter function that determines whether or not to report an error.
     *
     * @protected
     * @type {Function|null}
     */
    this._errorFilter = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.configuration.prototype" id="apidoc.module.jscs.configuration.prototype">module jscs.configuration.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._errorOnRemovedOptions" id="apidoc.element.jscs.configuration.prototype._errorOnRemovedOptions">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_errorOnRemovedOptions
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_errorOnRemovedOptions = function (config) {
    var errors = ['Config values to remove in 3.0:'];

    if (config.hasOwnProperty('esprima')) {
        errors.push('The `esprima` option since CST uses babylon (the babel parser) under the hood');
    }

    if (config.hasOwnProperty('esprimaOptions')) {
        errors.push('The `esprimaOptions` option.');
    }

    if (config.hasOwnProperty('esnext')) {
        errors.push('The `esnext` option is enabled by default.');
    }

    if (config.hasOwnProperty('verbose')) {
        errors.push('The `verbose` option is enabled by default.');
    }

    if (errors.length &gt; 1) {
        throw new Error(errors.join('\n'));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Copy configuration so original config would be intact
copyConfiguration(config, currentConfig);

// Override the properties
copyConfiguration(overrides, currentConfig);

this.<span class="apidocCodeKeywordSpan">_errorOnRemovedOptions</span>(currentConfig);

// NOTE: options is a separate object to ensure that future options must be added
// to BUILTIN_OPTIONS to work, which also assures they aren't mistaken for a rule
var options = this._getOptionsFromConfig(currentConfig);

// Base path
if (this._basePath === defaults.cwd &amp;&amp; options.configPath) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._getOptionsFromConfig" id="apidoc.element.jscs.configuration.prototype._getOptionsFromConfig">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_getOptionsFromConfig
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getOptionsFromConfig = function (config) {
    return Object.keys(config).reduce(function(options, key) {
        if (BUILTIN_OPTIONS[key]) {
            options[key] = config[key];
        }
        return options;
    }, {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Override the properties
copyConfiguration(overrides, currentConfig);

this._errorOnRemovedOptions(currentConfig);

// NOTE: options is a separate object to ensure that future options must be added
// to BUILTIN_OPTIONS to work, which also assures they aren't mistaken for a rule
var options = this.<span class="apidocCodeKeywordSpan">_getOptionsFromConfig</span>(currentConfig);

// Base path
if (this._basePath === defaults.cwd &amp;&amp; options.configPath) {
    assert(
        typeof options.configPath === 'string',
        '`configPath` option requires string value'
    );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._isDefined" id="apidoc.element.jscs.configuration.prototype._isDefined">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_isDefined
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isDefined = function (name) {
    return this._definedOptions.indexOf(name) &gt; -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Load default values for options which were not defined
 *
 * @private
 */
Configuration.prototype._loadDefaults = function() {
    if (!this.<span class="apidocCodeKeywordSpan">_isDefined</span>('excludeFiles')) {
        this._loadExcludedFiles(this._defaultExcludedFileMasks);
    }

    if (!this._isDefined('fileExtensions')) {
        this._loadFileExtensions(this._defaultFileExtensions);
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadAdditionalRule" id="apidoc.element.jscs.configuration.prototype._loadAdditionalRule">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadAdditionalRule
        <span class="apidocSignatureSpan">(additionalRule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadAdditionalRule = function (additionalRule) {
    assert(typeof additionalRule === 'object', '`additionalRule` should be an object');
    this.registerRule(additionalRule);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this._definedOptions.push('plugins');
    }
}

if (options.hasOwnProperty('additionalRules')) {
    assert(Array.isArray(options.additionalRules), '`additionalRules` option requires array value');
    options.additionalRules.forEach(function(rule) {
        this.<span class="apidocCodeKeywordSpan">_loadAdditionalRule</span>(rule, options.configPath);
    }, this);

    if (!this._isDefined('additionalRules')) {
        this._definedOptions.push('additionalRules');
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadDefaults" id="apidoc.element.jscs.configuration.prototype._loadDefaults">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadDefaults
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadDefaults = function () {
    if (!this._isDefined('excludeFiles')) {
        this._loadExcludedFiles(this._defaultExcludedFileMasks);
    }

    if (!this._isDefined('fileExtensions')) {
        this._loadFileExtensions(this._defaultFileExtensions);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
Configuration.prototype.load = function(config) {

   // Load all the options
   this._processConfig(config);

   // Load defaults if they weren't set
   this.<span class="apidocCodeKeywordSpan">_loadDefaults</span>(config);

   // Load and apply all the rules
   this._useRules();
};

/**
* Load default values for options which were not defined
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadES3" id="apidoc.element.jscs.configuration.prototype._loadES3">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadES3
        <span class="apidocSignatureSpan">(es3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadES3 = function (es3) {
    assert(
        typeof es3 === 'boolean' || es3 === null,
        '`es3` option requires boolean or null value'
    );
    this._es3Enabled = Boolean(es3);

    if (!this._isDefined('es3')) {
        this._definedOptions.push('es3');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (options.hasOwnProperty('fix')) {
    this._loadFix(options.fix);
}

this._loadMaxError(options);

if (options.hasOwnProperty('es3')) {
    this.<span class="apidocCodeKeywordSpan">_loadES3</span>(options.es3);
}

if (options.hasOwnProperty('errorFilter')) {
    this._loadErrorFilter(options.errorFilter, options.configPath);
}

// Apply presets
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadErrorFilter" id="apidoc.element.jscs.configuration.prototype._loadErrorFilter">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadErrorFilter
        <span class="apidocSignatureSpan">(errorFilter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadErrorFilter = function (errorFilter) {
    assert(
        typeof errorFilter === 'function' ||
        errorFilter === null,
        '`errorFilter` option requires a function or null value'
    );
    this._errorFilter = errorFilter;

    if (!this._isDefined('errorFilter')) {
        this._definedOptions.push('errorFilter');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._loadMaxError(options);

if (options.hasOwnProperty('es3')) {
    this._loadES3(options.es3);
}

if (options.hasOwnProperty('errorFilter')) {
    this.<span class="apidocCodeKeywordSpan">_loadErrorFilter</span>(options.errorFilter, options.configPath);
}

// Apply presets
if (options.hasOwnProperty('preset')) {
    this._loadPreset(options.preset, options.configPath);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadExcludedFiles" id="apidoc.element.jscs.configuration.prototype._loadExcludedFiles">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadExcludedFiles
        <span class="apidocSignatureSpan">(masks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadExcludedFiles = function (masks) {
    assert(Array.isArray(masks), '`excludeFiles` option requires array value');

    this._excludedFileMasks = this._excludedFileMasks.concat(masks);
    this._excludedFileMatchers = this._excludedFileMasks.map(function(fileMask) {
        return new minimatch.Minimatch(path.resolve(this._basePath, fileMask), {
            dot: true
        });
    }, this);

    if (!this._isDefined('excludeFiles')) {
        this._definedOptions.push('excludeFiles');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Load default values for options which were not defined
 *
 * @private
 */
Configuration.prototype._loadDefaults = function() {
    if (!this._isDefined('excludeFiles')) {
        this.<span class="apidocCodeKeywordSpan">_loadExcludedFiles</span>(this._defaultExcludedFileMasks);
    }

    if (!this._isDefined('fileExtensions')) {
        this._loadFileExtensions(this._defaultFileExtensions);
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadExtract" id="apidoc.element.jscs.configuration.prototype._loadExtract">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadExtract
        <span class="apidocSignatureSpan">(masks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadExtract = function (masks) {
    if (masks === true) {
        masks = this._defaultExtractFileMasks;
    } else if (masks === false) {
        masks = [];
    }

    assert(Array.isArray(masks), '`extract` option should be array of strings');
    this._extractFileMasks = masks.slice();
    this._extractFileMatchers = this._extractFileMasks.map(function(fileMask) {
        return new minimatch.Minimatch(path.resolve(this._basePath, fileMask), {
            dot: true
        });
    }, this);

    if (!this._isDefined('extract')) {
        this._definedOptions.push('extract');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (!this._isDefined('additionalRules')) {
        this._definedOptions.push('additionalRules');
    }
}

if (options.hasOwnProperty('extract')) {
    this.<span class="apidocCodeKeywordSpan">_loadExtract</span>(options.extract);
}

if (options.hasOwnProperty('fileExtensions')) {
    this._loadFileExtensions(options.fileExtensions);
}

if (options.hasOwnProperty('excludeFiles')) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadFileExtensions" id="apidoc.element.jscs.configuration.prototype._loadFileExtensions">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadFileExtensions
        <span class="apidocSignatureSpan">(extensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadFileExtensions = function (extensions) {
    assert(
        typeof extensions === 'string' || Array.isArray(extensions),
        '`fileExtensions` option requires string or array value'
    );

    this._fileExtensions = this._fileExtensions.concat(extensions).map(function(ext) {
        return ext.toLowerCase();
    });

    if (!this._isDefined('fileExtensions')) {
        this._definedOptions.push('fileExtensions');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
Configuration.prototype._loadDefaults = function() {
   if (!this._isDefined('excludeFiles')) {
       this._loadExcludedFiles(this._defaultExcludedFileMasks);
   }

   if (!this._isDefined('fileExtensions')) {
       this.<span class="apidocCodeKeywordSpan">_loadFileExtensions</span>(this._defaultFileExtensions);
   }
};

/**
* Returns resulting configuration after preset is applied and options are processed.
*
* @return {Object}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadFix" id="apidoc.element.jscs.configuration.prototype._loadFix">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadFix
        <span class="apidocSignatureSpan">(fix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadFix = function (fix) {
    fix = fix === null ? false : fix;

    assert(
        typeof fix === 'boolean',
        '`fix` option requires boolean or null value'
    );

    this._fix = fix;

    if (!this._isDefined('fix')) {
        this._definedOptions.push('fix');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (options.hasOwnProperty('excludeFiles')) {
    this._loadExcludedFiles(options.excludeFiles);
}

if (options.hasOwnProperty('fix')) {
    this.<span class="apidocCodeKeywordSpan">_loadFix</span>(options.fix);
}

this._loadMaxError(options);

if (options.hasOwnProperty('es3')) {
    this._loadES3(options.es3);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadMaxError" id="apidoc.element.jscs.configuration.prototype._loadMaxError">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadMaxError
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadMaxError = function (options) {

    // If "fix" option is enabled, set to Inifinity, otherwise this option
    // doesn't make sense with "fix" conjunction
    if (this._fix === true) {
        this._maxErrors = Infinity;

        return;
    }

    if (!options.hasOwnProperty('maxErrors')) {
        return;
    }

    var maxErrors = options.maxErrors === null ? null : Number(options.maxErrors);

    assert(
        maxErrors === -1 || maxErrors &gt; 0 || maxErrors === null,
        '`maxErrors` option requires -1, null value or positive number'
    );

    this._maxErrors = maxErrors;

    if (!this._isDefined('fix')) {
        this._definedOptions.push('fix');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._loadExcludedFiles(options.excludeFiles);
}

if (options.hasOwnProperty('fix')) {
    this._loadFix(options.fix);
}

this.<span class="apidocCodeKeywordSpan">_loadMaxError</span>(options);

if (options.hasOwnProperty('es3')) {
    this._loadES3(options.es3);
}

if (options.hasOwnProperty('errorFilter')) {
    this._loadErrorFilter(options.errorFilter, options.configPath);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadPlugin" id="apidoc.element.jscs.configuration.prototype._loadPlugin">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadPlugin
        <span class="apidocSignatureSpan">(plugin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadPlugin = function (plugin) {
    assert(typeof plugin === 'function', '`plugin` should be a function');
    plugin(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    );
    this._basePath = path.dirname(options.configPath);
}

if (options.hasOwnProperty('plugins')) {
    assert(Array.isArray(options.plugins), '`plugins` option requires array value');
    options.plugins.forEach(function(plugin) {
        this.<span class="apidocCodeKeywordSpan">_loadPlugin</span>(plugin, options.configPath);
    }, this);

    if (!this._isDefined('plugins')) {
        this._definedOptions.push('plugins');
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadPreset" id="apidoc.element.jscs.configuration.prototype._loadPreset">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadPreset
        <span class="apidocSignatureSpan">(preset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadPreset = function (preset) {
    if (this._loadedPresets.indexOf(preset) &gt; -1) {
        return;
    }

    // Do not keep adding preset from CLI (#2087)
    delete this._overrides.preset;

    this._loadedPresets.push(preset);

    // If preset is loaded from another preset - preserve the original name
    if (!this._presetName) {
        this._presetName = preset;
    }
    assert(typeof preset === 'string', '`preset` option requires string value');

    var presetData = this._presets[preset];
    assert(Boolean(presetData), 'Preset "' + preset + '" does not exist');

    if (!this._isDefined('preset')) {
        this._definedOptions.push('preset');
    }

    // Process config from the preset
    this._processConfig(this._presets[preset]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   if (options.hasOwnProperty('errorFilter')) {
       this._loadErrorFilter(options.errorFilter, options.configPath);
   }

   // Apply presets
   if (options.hasOwnProperty('preset')) {
       this.<span class="apidocCodeKeywordSpan">_loadPreset</span>(options.preset, options.configPath);
   }

   this._loadRules(currentConfig);
};

/**
* Loads plugin data.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._loadRules" id="apidoc.element.jscs.configuration.prototype._loadRules">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_loadRules
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadRules = function (config) {
    Object.keys(config).forEach(function(key) {

        // Only rules should be processed
        if (BUILTIN_OPTIONS[key]) {
            return;
        }

        if (this._rules[key]) {
            var optionValue = config[key];

            // Disable rule it it equals "false" or "null"
            if (optionValue === null || optionValue === false) {
                delete this._ruleSettings[key];

            } else {
                this._ruleSettings[key] = config[key];
            }

        } else if (this._unsupportedRuleNames.indexOf(key) === -1) {
            this._unsupportedRuleNames.push(key);
        }
    }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }

   // Apply presets
   if (options.hasOwnProperty('preset')) {
       this._loadPreset(options.preset, options.configPath);
   }

   this.<span class="apidocCodeKeywordSpan">_loadRules</span>(currentConfig);
};

/**
* Loads plugin data.
*
* @param {function(Configuration)} plugin
* @protected
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._processConfig" id="apidoc.element.jscs.configuration.prototype._processConfig">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_processConfig
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_processConfig = function (config) {
    var overrides = this._overrides;
    var currentConfig = {};

    // Copy configuration so original config would be intact
    copyConfiguration(config, currentConfig);

    // Override the properties
    copyConfiguration(overrides, currentConfig);

    this._errorOnRemovedOptions(currentConfig);

    // NOTE: options is a separate object to ensure that future options must be added
    // to BUILTIN_OPTIONS to work, which also assures they aren't mistaken for a rule
    var options = this._getOptionsFromConfig(currentConfig);

    // Base path
    if (this._basePath === defaults.cwd &amp;&amp; options.configPath) {
        assert(
            typeof options.configPath === 'string',
            '`configPath` option requires string value'
        );
        this._basePath = path.dirname(options.configPath);
    }

    if (options.hasOwnProperty('plugins')) {
        assert(Array.isArray(options.plugins), '`plugins` option requires array value');
        options.plugins.forEach(function(plugin) {
            this._loadPlugin(plugin, options.configPath);
        }, this);

        if (!this._isDefined('plugins')) {
            this._definedOptions.push('plugins');
        }
    }

    if (options.hasOwnProperty('additionalRules')) {
        assert(Array.isArray(options.additionalRules), '`additionalRules` option requires array value');
        options.additionalRules.forEach(function(rule) {
            this._loadAdditionalRule(rule, options.configPath);
        }, this);

        if (!this._isDefined('additionalRules')) {
            this._definedOptions.push('additionalRules');
        }
    }

    if (options.hasOwnProperty('extract')) {
        this._loadExtract(options.extract);
    }

    if (options.hasOwnProperty('fileExtensions')) {
        this._loadFileExtensions(options.fileExtensions);
    }

    if (options.hasOwnProperty('excludeFiles')) {
        this._loadExcludedFiles(options.excludeFiles);
    }

    if (options.hasOwnProperty('fix')) {
        this._loadFix(options.fix);
    }

    this._loadMaxError(options);

    if (options.hasOwnProperty('es3')) {
        this._loadES3(options.es3);
    }

    if (options.hasOwnProperty('errorFilter')) {
        this._loadErrorFilter(options.errorFilter, options.configPath);
    }

    // Apply presets
    if (options.hasOwnProperty('preset')) {
        this._loadPreset(options.preset, options.configPath);
    }

    this._loadRules(currentConfig);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Load settings from a configuration.
 *
 * @param {Object} config
 */
Configuration.prototype.load = function(config) {

    // Load all the options
    this.<span class="apidocCodeKeywordSpan">_processConfig</span>(config);

    // Load defaults if they weren't set
    this._loadDefaults(config);

    // Load and apply all the rules
    this._useRules();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype._useRules" id="apidoc.element.jscs.configuration.prototype._useRules">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>_useRules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_useRules = function () {
    this._configuredRules = [];

    Object.keys(this._ruleSettings).forEach(function(optionName) {
        var rule = this._rules[optionName];
        rule.configure(this._ruleSettings[optionName]);
        this._configuredRules.push(rule);
    }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   // Load all the options
   this._processConfig(config);

   // Load defaults if they weren't set
   this._loadDefaults(config);

   // Load and apply all the rules
   this.<span class="apidocCodeKeywordSpan">_useRules</span>();
};

/**
* Load default values for options which were not defined
*
* @private
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getBasePath" id="apidoc.element.jscs.configuration.prototype.getBasePath">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getBasePath
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBasePath = function () {
    return this._basePath;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param  {String} path - The path containing file(s) used to guide the configuration
 *
 * @return {Promise} Resolved with the generated, JSCS configuration
 */
Generator.prototype.generate = function(path) {
var checker = getChecker();
var _path = utils.normalizePath(path, checker.getConfiguration().<span class="apidocCodeKeywordSpan">getBasePath</span>());
var presetNames = Object.keys(checker.getConfiguration().getRegisteredPresets());
var statsForPresets;

console.log('Checking', _path, 'against the presets');

return Vow
.all(presetNames.map(this._checkAgainstPreset.bind(this, _path)))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getConfiguredRule" id="apidoc.element.jscs.configuration.prototype.getConfiguredRule">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getConfiguredRule
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConfiguredRule = function (name) {
    return this._configuredRules.filter(function(rule) {
        return rule.getOptionName() === name;
    })[0] || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {JsFile} file
     * @param {Error} error
     * @return {Boolean} whether the correction was carried out
     * @private
     */
    _fixSpecificError: function(file, error) {
var configuration = this.getConfiguration();
var instance = configuration.<span class="apidocCodeKeywordSpan">getConfiguredRule</span>(error.rule);

if (instance &amp;&amp; instance._fix) {
    // "error.fixed = true" should go first, so rule can
    // decide for itself (with "error.fixed = false")
    // if it can fix this particular error
    error.fixed = true;
    instance._fix(file, error);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getConfiguredRules" id="apidoc.element.jscs.configuration.prototype.getConfiguredRules">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getConfiguredRules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConfiguredRules = function () {
    return this._configuredRules;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Loads configuration from JS Object. Activates and configures required rules.
 *
 * @param {Object} config
 */
configure: function(config) {
    this._configuration.load(config);

    this._configuredRules = this._configuration.<span class="apidocCodeKeywordSpan">getConfiguredRules</span>();
    this._maxErrors = this._configuration.getMaxErrors();
},

/**
 * Checks file provided with a string.
 *
 * @param {String} source
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getErrorFilter" id="apidoc.element.jscs.configuration.prototype.getErrorFilter">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getErrorFilter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getErrorFilter = function () {
    return this._errorFilter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @protected
     */
    _checkJsFile: function(file, errors) {
        if (this._maxErrorsExceeded) {
return;
        }

        var errorFilter = this._configuration.<span class="apidocCodeKeywordSpan">getErrorFilter</span>();

        this._configuredRules.forEach(function(rule) {
errors.setCurrentRule(rule.getOptionName());

try {
    rule.check(file, errors);
} catch (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getExcludedFileMasks" id="apidoc.element.jscs.configuration.prototype.getExcludedFileMasks">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getExcludedFileMasks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getExcludedFileMasks = function () {
    return this._excludedFileMasks;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getExtractFileMasks" id="apidoc.element.jscs.configuration.prototype.getExtractFileMasks">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getExtractFileMasks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getExtractFileMasks = function () {
    return this._extractFileMasks;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getFileExtensions" id="apidoc.element.jscs.configuration.prototype.getFileExtensions">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getFileExtensions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFileExtensions = function () {
    return this._fileExtensions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Returns true if the file extension matches a file extension to process.
 *
 * @returns {Boolean}
 */
Configuration.prototype.hasCorrectExtension = function(testPath) {
    var extension = path.extname(testPath).toLowerCase();
    var basename = path.basename(testPath).toLowerCase();
    var fileExtensions = this.<span class="apidocCodeKeywordSpan">getFileExtensions</span>();

    return !(
        fileExtensions.indexOf(extension) &lt; 0 &amp;&amp;
        fileExtensions.indexOf(basename) &lt; 0 &amp;&amp;
        fileExtensions.indexOf('*') &lt; 0
    );
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getFix" id="apidoc.element.jscs.configuration.prototype.getFix">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getFix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFix = function () {
    return !!this._fix;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Execute checker depending on config value either checks or checks and fixes
*
* @see Checker#checkPath/Checker#fixPath
*/
Checker.prototype.execute = function() {
   var method = this._configuration.<span class="apidocCodeKeywordSpan">getFix</span>() === true ? this.fixPath : this.checkPath
;

   return method.apply(this, arguments);
};

/**
* Checks single file.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getMaxErrors" id="apidoc.element.jscs.configuration.prototype.getMaxErrors">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getMaxErrors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMaxErrors = function () {
    return this._maxErrors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Object} config
 */
configure: function(config) {
    this._configuration.load(config);

    this._configuredRules = this._configuration.getConfiguredRules();
    this._maxErrors = this._configuration.<span class="apidocCodeKeywordSpan">getMaxErrors</span>();
},

/**
 * Checks file provided with a string.
 *
 * @param {String} source
 * @param {String} [filename='input']
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getPresetName" id="apidoc.element.jscs.configuration.prototype.getPresetName">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getPresetName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPresetName = function () {
    return this._presetName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getProcessedConfig" id="apidoc.element.jscs.configuration.prototype.getProcessedConfig">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getProcessedConfig
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getProcessedConfig = function () {
    var result = {};
    Object.keys(this._ruleSettings).forEach(function(key) {
        result[key] = this._ruleSettings[key];
    }, this);
    result.excludeFiles = this._excludedFileMasks;
    result.fileExtensions = this._fileExtensions;
    result.extract = this._extractFileMasks;
    result.maxErrors = this._maxErrors;
    result.preset = this._presetName;
    result.es3 = this._es3Enabled;
    result.errorFilter = this._errorFilter;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Get processed config.
 *
 * @return {Object}
 */
getProcessedConfig: function() {
    return this._configuration.<span class="apidocCodeKeywordSpan">getProcessedConfig</span>();
},

/**
 * Loads configuration from JS Object. Activates and configures required rules.
 *
 * @param {Object} config
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getRegisteredPresets" id="apidoc.element.jscs.configuration.prototype.getRegisteredPresets">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getRegisteredPresets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRegisteredPresets = function () {
    return this._presets;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} path - The path containing file(s) used to guide the configuration
 *
 * @return {Promise} Resolved with the generated, JSCS configuration
 */
Generator.prototype.generate = function(path) {
var checker = getChecker();
var _path = utils.normalizePath(path, checker.getConfiguration().getBasePath());
var presetNames = Object.keys(checker.getConfiguration().<span class="apidocCodeKeywordSpan">getRegisteredPresets</span>());
var statsForPresets;

console.log('Checking', _path, 'against the presets');

return Vow
.all(presetNames.map(this._checkAgainstPreset.bind(this, _path)))
.then(function(resultsPerPreset) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getRegisteredRules" id="apidoc.element.jscs.configuration.prototype.getRegisteredRules">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getRegisteredRules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRegisteredRules = function () {
    var rules = this._rules;
    return Object.keys(rules).map(function(ruleOptionName) {
        return rules[ruleOptionName];
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.getUnsupportedRuleNames" id="apidoc.element.jscs.configuration.prototype.getUnsupportedRuleNames">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>getUnsupportedRuleNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getUnsupportedRuleNames = function () {
    return this._unsupportedRuleNames;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        rule.check(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.<span class="apidocCodeKeywordSpan">getUnsupportedRuleNames</span>().forEach(function(rulename) {
    errors.add('Unsupported rule: ' + rulename, file.getProgram());
});

var program = file.getProgram();
var tokenIndex = new TokenIndex(program.getFirstToken());
errors.calculateErrorLocations(tokenIndex);
errors.filter(function(error) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.hasCorrectExtension" id="apidoc.element.jscs.configuration.prototype.hasCorrectExtension">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>hasCorrectExtension
        <span class="apidocSignatureSpan">(testPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasCorrectExtension = function (testPath) {
    var extension = path.extname(testPath).toLowerCase();
    var basename = path.basename(testPath).toLowerCase();
    var fileExtensions = this.getFileExtensions();

    return !(
        fileExtensions.indexOf(extension) &lt; 0 &amp;&amp;
        fileExtensions.indexOf(basename) &lt; 0 &amp;&amp;
        fileExtensions.indexOf('*') &lt; 0
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }

            return vowFs.stat(fullname).then(function(stat) {
if (stat.isDirectory()) {
    return this._processDirectory(fullname, fileHandler);
}

if (!this._configuration.<span class="apidocCodeKeywordSpan">hasCorrectExtension</span>(fullname)) {
    if (!this._configuration.shouldExtractFile(fullname)) {
        return [];
    }

    return this.extractFile(fullname);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.hasPreset" id="apidoc.element.jscs.configuration.prototype.hasPreset">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>hasPreset
        <span class="apidocSignatureSpan">(presetName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasPreset = function (presetName) {
    return this._presets.hasOwnProperty(presetName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.isES3Enabled" id="apidoc.element.jscs.configuration.prototype.isES3Enabled">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>isES3Enabled
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isES3Enabled = function () {
    return this._es3Enabled;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {String} source
 * @private
 */
_createJsFileInstance: function(filename, source) {
    return new JsFile({
        filename: filename,
        source: source,
        es3: this._configuration.<span class="apidocCodeKeywordSpan">isES3Enabled</span>()
    });
},

/**
 * Checks and fix file provided with a string.
 *
 * @param {String} source
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.isFileExcluded" id="apidoc.element.jscs.configuration.prototype.isFileExcluded">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>isFileExcluded
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFileExcluded = function (filePath) {
    filePath = path.resolve(filePath);

    return this._excludedFileMatchers.some(function(matcher) {
        return matcher.match(filePath);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Checks single file.
 *
 * @param {String} path
 * @returns {Promise.&lt;Errors&gt;}
 */
Checker.prototype.checkFile = function(path) {
    if (this._configuration.<span class="apidocCodeKeywordSpan">isFileExcluded</span>(path)) {
        return Vow.resolve(null);
    }

    return vowFs.read(path, 'utf8').then(function(data) {
        return this.checkString(data, path);
    }, this);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.load" id="apidoc.element.jscs.configuration.prototype.load">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>load
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (config) {

    // Load all the options
    this._processConfig(config);

    // Load defaults if they weren't set
    this._loadDefaults(config);

    // Load and apply all the rules
    this._useRules();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

promise.always(function(status) {
    exit(status.valueOf());
});

try {
    config = configFile.<span class="apidocCodeKeywordSpan">load</span>(program.config);
} catch (e) {
    console.error('Config source is corrupted -', e.toString());
    defer.reject(5);

    return returnArgs;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.override" id="apidoc.element.jscs.configuration.prototype.override">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>override
        <span class="apidocSignatureSpan">(overrides)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">override = function (overrides) {
    Object.keys(overrides).forEach(function(key) {
        this._overrides[key] = overrides[key];
    }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   OVERRIDE_OPTIONS.forEach(function(option) {
       if (option in program) {
           overrides[option] = program[option];
       }
   });

   this.<span class="apidocCodeKeywordSpan">override</span>(overrides);
};

/**
* Load external module.
*
* @param {String|null} external - path (relative or absolute) or name to the external module
* @param {String} type - type of the module
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.registerDefaultPresets" id="apidoc.element.jscs.configuration.prototype.registerDefaultPresets">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>registerDefaultPresets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerDefaultPresets = function () {
    var dir = path.join(__dirname, '../../presets/');

    fs.readdirSync(dir).forEach(function(preset) {
        var name = preset.split('.')[0];
        var p = path.join(dir, preset);

        this.registerPreset(name, require(p));
    }, this);

    this.registerPreset('wikimedia', require('jscs-preset-wikimedia'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var StringChecker = function() {
this._configuredRules = [];

this._errorsFound = 0;
this._maxErrorsExceeded = false;

this._configuration = this._createConfiguration();
this._configuration.<span class="apidocCodeKeywordSpan">registerDefaultPresets</span>();
};

StringChecker.prototype = {
/**
 * Registers single Code Style checking rule.
 *
 * @param {Rule} rule
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.registerDefaultRules" id="apidoc.element.jscs.configuration.prototype.registerDefaultRules">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>registerDefaultRules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerDefaultRules = function () {
    var dir = path.join(__dirname, '../rules');

    fs.readdirSync(dir).forEach(function(rule) {
        this.registerRule(
            require(path.join(dir, rule))
        );
    }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// To run autoconfigure over all errors in the path
if (program.autoConfigure) {
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().<span class="apidocCodeKeywordSpan">registerDefaultRules</span>();

try {
    checker.configure(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.registerPreset" id="apidoc.element.jscs.configuration.prototype.registerPreset">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>registerPreset
        <span class="apidocSignatureSpan">(presetName, presetConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerPreset = function (presetName, presetConfig) {
    assert(_.isPlainObject(presetConfig), 'Preset should be an object');

    for (var key in presetConfig) {
        assert(typeof presetConfig[key] !== 'function', 'Preset should be an JSON object');
    }

    this._presets[presetName] = presetConfig;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Configuration.prototype.registerDefaultPresets = function() {
    var dir = path.join(__dirname, '../../presets/');

    fs.readdirSync(dir).forEach(function(preset) {
        var name = preset.split('.')[0];
        var p = path.join(dir, preset);

        this.<span class="apidocCodeKeywordSpan">registerPreset</span>(name, require(p));
    }, this);

    this.registerPreset('wikimedia', require('jscs-preset-wikimedia'));
};

module.exports = Configuration;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.registerRule" id="apidoc.element.jscs.configuration.prototype.registerRule">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>registerRule
        <span class="apidocSignatureSpan">(rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerRule = function (rule) {
    if (typeof rule === 'function') {
        var RuleClass = rule;
        rule = new RuleClass();
    }

    var optionName = rule.getOptionName();
    assert(!this._rules.hasOwnProperty(optionName), 'Rule "' + optionName + '" is already registered');
    this._rules[optionName] = rule;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
StringChecker.prototype = {
/**
 * Registers single Code Style checking rule.
 *
 * @param {Rule} rule
 */
registerRule: function(rule) {
    this._configuration.<span class="apidocCodeKeywordSpan">registerRule</span>(rule);
},

/**
 * Registers built-in Code Style checking rules.
 */
registerDefaultRules: function() {
    this._configuration.registerDefaultRules();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.shouldExtractFile" id="apidoc.element.jscs.configuration.prototype.shouldExtractFile">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>shouldExtractFile
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shouldExtractFile = function (filePath) {
    filePath = path.resolve(filePath);
    return this._extractFileMatchers.some(function(matcher) {
        return matcher.match(filePath);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {Promise.&lt;Errors&gt;}
 */
Checker.prototype.extractFile = function(path) {
    if (this._configuration.isFileExcluded(path)) {
return Vow.resolve(null);
    }

    if (!this._configuration.<span class="apidocCodeKeywordSpan">shouldExtractFile</span>(path)) {
return Vow.resolve(null);
    }

    return vowFs.read(path, 'utf8').then(function(data) {
var result = extractJs(path, data);

result.sources.forEach(function(script) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.configuration.prototype.usePlugin" id="apidoc.element.jscs.configuration.prototype.usePlugin">
        function <span class="apidocSignatureSpan">jscs.configuration.prototype.</span>usePlugin
        <span class="apidocSignatureSpan">(plugin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">usePlugin = function (plugin) {
    this._loadPlugin(plugin);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_anonymous_functions" id="apidoc.module.jscs.disallow_anonymous_functions">module jscs.disallow_anonymous_functions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_anonymous_functions.disallow_anonymous_functions" id="apidoc.element.jscs.disallow_anonymous_functions.disallow_anonymous_functions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_anonymous_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_anonymous_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_anonymous_functions.prototype" id="apidoc.module.jscs.disallow_anonymous_functions.prototype">module jscs.disallow_anonymous_functions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_anonymous_functions.prototype.check" id="apidoc.element.jscs.disallow_anonymous_functions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_anonymous_functions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(['FunctionExpression', 'FunctionDeclaration'], function(node) {
        if (node.id === null) {
            errors.add('Anonymous functions need to be named', node);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_anonymous_functions.prototype.configure" id="apidoc.element.jscs.disallow_anonymous_functions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_anonymous_functions.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_anonymous_functions.prototype.getOptionName" id="apidoc.element.jscs.disallow_anonymous_functions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_anonymous_functions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowAnonymousFunctions';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_array_destructuring_return" id="apidoc.module.jscs.disallow_array_destructuring_return">module jscs.disallow_array_destructuring_return</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_array_destructuring_return.disallow_array_destructuring_return" id="apidoc.element.jscs.disallow_array_destructuring_return.disallow_array_destructuring_return">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_array_destructuring_return
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_array_destructuring_return = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_array_destructuring_return.prototype" id="apidoc.module.jscs.disallow_array_destructuring_return.prototype">module jscs.disallow_array_destructuring_return.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_array_destructuring_return.prototype.check" id="apidoc.element.jscs.disallow_array_destructuring_return.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_array_destructuring_return.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var addError = function(node) {
        errors.add(
            'Array destructuring is not allowed for return, ' +
            'use object destructuring instead',
            node
        );
    };

    var isViolationDetected = function(maybeArrayPattern, maybeCallExpression) {

        return maybeCallExpression &amp;&amp; maybeCallExpression.type === 'CallExpression' &amp;&amp;
            maybeArrayPattern &amp;&amp; maybeArrayPattern.type === 'ArrayPattern';
    };

    file.iterateNodesByType(['VariableDeclaration', 'AssignmentExpression'], function(node) {

        if (node.type === 'VariableDeclaration') {
            node.declarations.forEach(function(declaration) {
                if (!isViolationDetected(declaration.id, declaration.init)) {
                    return;
                }

                addError(declaration.init);
            });
        }

        if (node.type === 'AssignmentExpression') {
            if (!isViolationDetected(node.left, node.right)) {
                return;
            }

            addError(node.right);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_array_destructuring_return.prototype.configure" id="apidoc.element.jscs.disallow_array_destructuring_return.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_array_destructuring_return.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_array_destructuring_return.prototype.getOptionName" id="apidoc.element.jscs.disallow_array_destructuring_return.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_array_destructuring_return.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowArrayDestructuringReturn';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_arrow_functions" id="apidoc.module.jscs.disallow_arrow_functions">module jscs.disallow_arrow_functions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_arrow_functions.disallow_arrow_functions" id="apidoc.element.jscs.disallow_arrow_functions.disallow_arrow_functions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_arrow_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_arrow_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_arrow_functions.prototype" id="apidoc.module.jscs.disallow_arrow_functions.prototype">module jscs.disallow_arrow_functions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_arrow_functions.prototype.check" id="apidoc.element.jscs.disallow_arrow_functions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_arrow_functions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(['ArrowFunctionExpression'], function(node) {
        errors.add('Do not use arrow functions', node);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_arrow_functions.prototype.configure" id="apidoc.element.jscs.disallow_arrow_functions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_arrow_functions.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_arrow_functions.prototype.getOptionName" id="apidoc.element.jscs.disallow_arrow_functions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_arrow_functions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowArrowFunctions';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_capitalized_comments" id="apidoc.module.jscs.disallow_capitalized_comments">module jscs.disallow_capitalized_comments</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_capitalized_comments.disallow_capitalized_comments" id="apidoc.element.jscs.disallow_capitalized_comments.disallow_capitalized_comments">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_capitalized_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_capitalized_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_capitalized_comments.prototype" id="apidoc.module.jscs.disallow_capitalized_comments.prototype">module jscs.disallow_capitalized_comments.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_capitalized_comments.prototype.check" id="apidoc.element.jscs.disallow_capitalized_comments.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_capitalized_comments.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var letterPattern = require('../../patterns/L');
    var lowerCasePattern = require('../../patterns/Ll');

    file.iterateTokensByType(['CommentLine', 'CommentBlock'], function(comment) {
        var stripped = comment.value.replace(/[\n\s\*]/g, '');
        var firstChar = stripped[0];

        if (letterPattern.test(firstChar) &amp;&amp; !lowerCasePattern.test(firstChar)) {
            errors.add(
                'Comments must start with a lowercase letter',
                comment
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_capitalized_comments.prototype.configure" id="apidoc.element.jscs.disallow_capitalized_comments.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_capitalized_comments.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_capitalized_comments.prototype.getOptionName" id="apidoc.element.jscs.disallow_capitalized_comments.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_capitalized_comments.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowCapitalizedComments';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_comma_before_line_break" id="apidoc.module.jscs.disallow_comma_before_line_break">module jscs.disallow_comma_before_line_break</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_comma_before_line_break.disallow_comma_before_line_break" id="apidoc.element.jscs.disallow_comma_before_line_break.disallow_comma_before_line_break">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_comma_before_line_break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_comma_before_line_break = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_comma_before_line_break.prototype" id="apidoc.module.jscs.disallow_comma_before_line_break.prototype">module jscs.disallow_comma_before_line_break.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_comma_before_line_break.prototype.check" id="apidoc.element.jscs.disallow_comma_before_line_break.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_comma_before_line_break.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptFunction = this._exceptFunction;

    function canSkip(token) {
        var node = token.parentElement;
        if (node.getNewlineCount() === 0) {
            return true;
        }

        // exception for function params
        if (
            node.params &amp;&amp;
            file.isOnTheSameLine(node.params[0], node.params[node.params.length - 1])
        ) {
            return true;
        }

        // See #1841
        if (!exceptFunction || !node.properties) {
            return false;
        }

        return node.properties.some(function(property) {
            return property.value.type === 'FunctionExpression';
        });
    }

    file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
        var nextToken = token.getNextCodeToken();

        if (canSkip(token) || nextToken.value === ',') {
            return;
        }

        errors.assert.sameLine({
            token: token,
            nextToken: nextToken,
            message: 'Commas should be placed on the same line as value'
        });

        errors.assert.differentLine({
            token: token.getPreviousCodeToken(),
            nextToken: token,
            message: 'Commas should be placed on new line'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_comma_before_line_break.prototype.configure" id="apidoc.element.jscs.disallow_comma_before_line_break.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_comma_before_line_break.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var optionName = this.getOptionName();

    if (typeof options !== 'object') {
        assert(
            options === true,
            optionName + ' option requires either a true value or an object'
        );

        var _options = {allExcept: []};
        return this.configure(_options);
    }

    assert(
        Array.isArray(options.allExcept),
        'Property `allExcept` in ' + optionName + ' should be an array of strings'
    );

    this._exceptFunction = options.allExcept.indexOf('function') &gt; -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_comma_before_line_break.prototype.getOptionName" id="apidoc.element.jscs.disallow_comma_before_line_break.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_comma_before_line_break.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowCommaBeforeLineBreak';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_curly_braces" id="apidoc.module.jscs.disallow_curly_braces">module jscs.disallow_curly_braces</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_curly_braces.disallow_curly_braces" id="apidoc.element.jscs.disallow_curly_braces.disallow_curly_braces">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_curly_braces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_curly_braces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_curly_braces.prototype" id="apidoc.module.jscs.disallow_curly_braces.prototype">module jscs.disallow_curly_braces.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_curly_braces.prototype.check" id="apidoc.element.jscs.disallow_curly_braces.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_curly_braces.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {

    function isSingleBlockStatement(node) {
        return node &amp;&amp; node.type === 'BlockStatement' &amp;&amp;
        node.body.length === 1;
    }

    function addError(typeString, entity) {
        errors.add(
            typeString + ' statement with extra curly braces',
            entity
        );
    }

    function checkBody(type, typeString) {
        file.iterateNodesByType(type, function(node) {
            if (isSingleBlockStatement(node.body)) {
                addError(typeString, node);
            }
        });
    }

    var typeIndex = this._typeIndex;

    if (typeIndex.if || typeIndex.else) {
        file.iterateNodesByType('IfStatement', function(node) {
            if (typeIndex.if &amp;&amp; isSingleBlockStatement(node.consequent)) {
                addError('If', node);
            }
            if (typeIndex.else &amp;&amp; isSingleBlockStatement(node.alternate)) {
                addError('Else', node.alternate.getFirstToken());
            }
        });
    }

    if (typeIndex.while) {
        checkBody('WhileStatement', 'While');
    }

    if (typeIndex.for) {
        checkBody('ForStatement', 'For');
        checkBody('ForInStatement', 'For in');
        checkBody('ForOfStatement', 'For of');
    }

    if (typeIndex.do) {
        checkBody('DoWhileStatement', 'Do while');
    }

    if (typeIndex.with) {
        checkBody('WithStatement', 'With');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_curly_braces.prototype.configure" id="apidoc.element.jscs.disallow_curly_braces.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_curly_braces.prototype.</span>configure
        <span class="apidocSignatureSpan">(statementTypes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (statementTypes) {
    assert(
        Array.isArray(statementTypes) || statementTypes === true,
        this.getOptionName() + ' option requires array or true value'
    );

    if (statementTypes === true) {
        statementTypes = defaultKeywords;
    }

    this._typeIndex = {};
    statementTypes.forEach(function(type) {
        this._typeIndex[type] = true;
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_curly_braces.prototype.getOptionName" id="apidoc.element.jscs.disallow_curly_braces.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_curly_braces.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowCurlyBraces';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_dangling_underscores" id="apidoc.module.jscs.disallow_dangling_underscores">module jscs.disallow_dangling_underscores</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_dangling_underscores.disallow_dangling_underscores" id="apidoc.element.jscs.disallow_dangling_underscores.disallow_dangling_underscores">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_dangling_underscores
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_dangling_underscores = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_dangling_underscores.prototype" id="apidoc.module.jscs.disallow_dangling_underscores.prototype">module jscs.disallow_dangling_underscores.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_dangling_underscores.prototype.check" id="apidoc.element.jscs.disallow_dangling_underscores.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_dangling_underscores.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var allowedIdentifiers = this._identifierIndex;

    file.iterateTokensByType('Identifier', function(token) {
        var value = token.value;

        if ((value[0] === '_' || value.slice(-1) === '_') &amp;&amp;
            allowedIdentifiers.indexOf(value) &lt; 0
        ) {
            errors.add(
                'Invalid dangling underscore found',
                token
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_dangling_underscores.prototype.configure" id="apidoc.element.jscs.disallow_dangling_underscores.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_dangling_underscores.prototype.</span>configure
        <span class="apidocSignatureSpan">(identifiers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (identifiers) {
    assert(
        identifiers === true ||
        typeof identifiers === 'object',
        this.getOptionName() + ' option requires the value `true` ' +
        'or an object with String[] `allExcept` property'
    );

    // verify first item in `allExcept` property in object (if it's an object)
    assert(
        typeof identifiers !== 'object' ||
        Array.isArray(identifiers.allExcept) &amp;&amp;
        typeof identifiers.allExcept[0] === 'string',
        'Property `allExcept` in ' + this.getOptionName() + ' should be an array of strings'
    );

    var isTrue = identifiers === true;
    var defaultIdentifiers = [
        '__proto__',
        '_',
        '__dirname',
        '__filename',
        'super_'
    ];

    if (isTrue) {
        identifiers = defaultIdentifiers;
    } else {
        identifiers = (identifiers.allExcept).concat(defaultIdentifiers);
    }

    this._identifierIndex = identifiers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_dangling_underscores.prototype.getOptionName" id="apidoc.element.jscs.disallow_dangling_underscores.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_dangling_underscores.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowDanglingUnderscores';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_empty_blocks" id="apidoc.module.jscs.disallow_empty_blocks">module jscs.disallow_empty_blocks</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_empty_blocks.disallow_empty_blocks" id="apidoc.element.jscs.disallow_empty_blocks.disallow_empty_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_empty_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_empty_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_empty_blocks.prototype" id="apidoc.module.jscs.disallow_empty_blocks.prototype">module jscs.disallow_empty_blocks.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_empty_blocks.prototype.check" id="apidoc.element.jscs.disallow_empty_blocks.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_empty_blocks.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptComments = this._exceptComments;

    function canSkip(token) {
        if (!exceptComments) {
            return false;
        }
        var canSkipToken = false;
        var tokenLoc = token.getLoc();
        file.getComments().forEach(function(comment) {
            var commentLoc = comment.getLoc();
            if (commentLoc.start.line &gt;= tokenLoc.start.line &amp;&amp;
                commentLoc.end.line &lt;= tokenLoc.end.line) {
                canSkipToken = true;
            }
        });
        return canSkipToken;
    }

    file.iterateNodesByType('BlockStatement', function(node) {
        if (node.body.length) {
            return true;
        }

        if (canSkip(node)) {
            return true;
        }

        if (node.parentElement.type !== 'CatchClause' &amp;&amp;
            node.parentElement.type !== 'FunctionDeclaration' &amp;&amp;
            node.parentElement.type !== 'FunctionExpression' &amp;&amp;
            node.parentElement.type !== 'ArrowFunctionExpression' &amp;&amp;
            node.parentElement.type !== 'ObjectMethod') {
            errors.add('Empty block found', node.lastChild);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_empty_blocks.prototype.configure" id="apidoc.element.jscs.disallow_empty_blocks.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_empty_blocks.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var optionName = this.getOptionName();

    if (typeof options !== 'object') {
        assert(
            options === true,
            optionName + ' option requires a true value or an object like: { allExcept: [\'comments\'] }'
        );

        var _options = {
            allExcept: []
        };
        return this.configure(_options);
    }

    assert(
        Array.isArray(options.allExcept),
        'Property `allExcept` in ' + optionName + ' should be an array of strings'
    );

    this._exceptComments = options.allExcept.indexOf('comments') &gt; -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_empty_blocks.prototype.getOptionName" id="apidoc.element.jscs.disallow_empty_blocks.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_empty_blocks.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowEmptyBlocks';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_function_declarations" id="apidoc.module.jscs.disallow_function_declarations">module jscs.disallow_function_declarations</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_function_declarations.disallow_function_declarations" id="apidoc.element.jscs.disallow_function_declarations.disallow_function_declarations">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_function_declarations
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_function_declarations = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_function_declarations.prototype" id="apidoc.module.jscs.disallow_function_declarations.prototype">module jscs.disallow_function_declarations.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_function_declarations.prototype.check" id="apidoc.element.jscs.disallow_function_declarations.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_function_declarations.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('FunctionDeclaration', function(node) {
        errors.add('Illegal function declaration', node);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_function_declarations.prototype.configure" id="apidoc.element.jscs.disallow_function_declarations.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_function_declarations.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_function_declarations.prototype.getOptionName" id="apidoc.element.jscs.disallow_function_declarations.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_function_declarations.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowFunctionDeclarations';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_identical_destructuring_names" id="apidoc.module.jscs.disallow_identical_destructuring_names">module jscs.disallow_identical_destructuring_names</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_identical_destructuring_names.disallow_identical_destructuring_names" id="apidoc.element.jscs.disallow_identical_destructuring_names.disallow_identical_destructuring_names">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_identical_destructuring_names
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_identical_destructuring_names = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_identical_destructuring_names.prototype" id="apidoc.module.jscs.disallow_identical_destructuring_names.prototype">module jscs.disallow_identical_destructuring_names.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_identical_destructuring_names.prototype.check" id="apidoc.element.jscs.disallow_identical_destructuring_names.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_identical_destructuring_names.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(['ObjectPattern'], function(node) {
        var props = node.properties;
        for (var i = 0; i &lt; props.length; i++) {
            var prop = props[i];
            if (prop.type === 'ObjectProperty' &amp;&amp; !prop.shorthand &amp;&amp; !prop.computed &amp;&amp;
                prop.key.name === prop.value.name) {
                errors.add('Use the shorthand form of destructuring instead', prop);
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_identical_destructuring_names.prototype.configure" id="apidoc.element.jscs.disallow_identical_destructuring_names.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_identical_destructuring_names.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_identical_destructuring_names.prototype.getOptionName" id="apidoc.element.jscs.disallow_identical_destructuring_names.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_identical_destructuring_names.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowIdenticalDestructuringNames';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_identifier_names" id="apidoc.module.jscs.disallow_identifier_names">module jscs.disallow_identifier_names</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_identifier_names.disallow_identifier_names" id="apidoc.element.jscs.disallow_identifier_names.disallow_identifier_names">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_identifier_names
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_identifier_names = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_identifier_names.prototype" id="apidoc.module.jscs.disallow_identifier_names.prototype">module jscs.disallow_identifier_names.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_identifier_names.prototype.check" id="apidoc.element.jscs.disallow_identifier_names.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_identifier_names.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var disallowedIdentifiers = this._identifierIndex;

    file.iterateNodesByType('Identifier', function(node) {
        if (Object.prototype.hasOwnProperty.call(disallowedIdentifiers, node.name)) {
            errors.add('Illegal Identifier name: ' + node.name, node);
        }
    });

    file.iterateNodesByType('MemberExpression', function(node) {
        if (node.property.type === 'StringLiteral') {
            if (Object.prototype.hasOwnProperty.call(disallowedIdentifiers, node.property.value)) {
                errors.add('Illegal Identifier name: ' + node.property.value, node.property);
            }
        }
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_identifier_names.prototype.configure" id="apidoc.element.jscs.disallow_identifier_names.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_identifier_names.prototype.</span>configure
        <span class="apidocSignatureSpan">(identifiers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (identifiers) {
    assert(
        Array.isArray(identifiers),
        'disallowIdentifierNames option requires an array'
    );

    this._identifierIndex = {};
    for (var i = 0, l = identifiers.length; i &lt; l; i++) {
        this._identifierIndex[identifiers[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_identifier_names.prototype.getOptionName" id="apidoc.element.jscs.disallow_identifier_names.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_identifier_names.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowIdentifierNames';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_implicit_type_conversion" id="apidoc.module.jscs.disallow_implicit_type_conversion">module jscs.disallow_implicit_type_conversion</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_implicit_type_conversion.disallow_implicit_type_conversion" id="apidoc.element.jscs.disallow_implicit_type_conversion.disallow_implicit_type_conversion">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_implicit_type_conversion
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_implicit_type_conversion = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_implicit_type_conversion.prototype" id="apidoc.module.jscs.disallow_implicit_type_conversion.prototype">module jscs.disallow_implicit_type_conversion.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_implicit_type_conversion.prototype.check" id="apidoc.element.jscs.disallow_implicit_type_conversion.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_implicit_type_conversion.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var types = this._typeIndex;
    if (types.numeric || types.boolean || types.binary) {
        file.iterateNodesByType('UnaryExpression', function(node) {
            if (types.numeric &amp;&amp; node.operator === '+') {
                errors.add('Implicit numeric conversion', node);
            }
            if (types.binary &amp;&amp; node.operator === '~') {
                errors.add('Implicit binary conversion', node);
            }
            if (types.boolean &amp;&amp;
                node.operator === '!' &amp;&amp;
                node.argument.type === 'UnaryExpression' &amp;&amp;
                node.argument.operator === '!'
            ) {
                errors.add('Implicit boolean conversion', node);
            }
        });
    }
    if (types.string) {
        file.iterateNodesByType('BinaryExpression', function(node) {

            if (node.operator !== '+') {
                return;
            }

            // Do not report concatination for same string literals (#1538)
            if (node.left.type === node.right.type) {
                return;
            }

            if (
                (node.left.type === 'StringLiteral' &amp;&amp; node.left.value === '') ||
                (node.right.type === 'StringLiteral' &amp;&amp; node.right.value === '')
            ) {
                errors.add('Implicit string conversion', node);
            }
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_implicit_type_conversion.prototype.configure" id="apidoc.element.jscs.disallow_implicit_type_conversion.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_implicit_type_conversion.prototype.</span>configure
        <span class="apidocSignatureSpan">(types)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (types) {
    assert(Array.isArray(types), this.getOptionName() + ' option requires array value');
    this._typeIndex = {};
    for (var i = 0, l = types.length; i &lt; l; i++) {
        this._typeIndex[types[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_implicit_type_conversion.prototype.getOptionName" id="apidoc.element.jscs.disallow_implicit_type_conversion.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_implicit_type_conversion.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowImplicitTypeConversion';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_keywords" id="apidoc.module.jscs.disallow_keywords">module jscs.disallow_keywords</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords.disallow_keywords" id="apidoc.element.jscs.disallow_keywords.disallow_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_keywords.prototype" id="apidoc.module.jscs.disallow_keywords.prototype">module jscs.disallow_keywords.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords.prototype.check" id="apidoc.element.jscs.disallow_keywords.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
        errors.add('Illegal keyword: ' + token.value, token);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords.prototype.configure" id="apidoc.element.jscs.disallow_keywords.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(Array.isArray(keywords), this.getOptionName() + ' option requires array value');
    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords.prototype.getOptionName" id="apidoc.element.jscs.disallow_keywords.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowKeywords';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_keywords_in_comments" id="apidoc.module.jscs.disallow_keywords_in_comments">module jscs.disallow_keywords_in_comments</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_in_comments.disallow_keywords_in_comments" id="apidoc.element.jscs.disallow_keywords_in_comments.disallow_keywords_in_comments">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_in_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_keywords_in_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_keywords_in_comments.prototype" id="apidoc.module.jscs.disallow_keywords_in_comments.prototype">module jscs.disallow_keywords_in_comments.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_in_comments.prototype.check" id="apidoc.element.jscs.disallow_keywords_in_comments.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords_in_comments.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var keywordRegEx = this._keywordRegEx;
    file.iterateTokensByType(['CommentLine', 'CommentBlock'], function(comment) {
        var match;

        // Both '//' and '/*' comment starters have offset '2'
        var commentOffset = 2;
        keywordRegEx.lastIndex = 0;
        while ((match = keywordRegEx.exec(comment.value)) !== null) {
            errors.add(
                this.mesage,
                comment,
                match.index + commentOffset
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_in_comments.prototype.configure" id="apidoc.element.jscs.disallow_keywords_in_comments.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords_in_comments.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    this._message = 'Comments cannot contain the following keywords: ';
    this._keywords = ['todo', 'fixme'];

    switch (true) {
        case Array.isArray(keywords):
            // use the array of strings provided to build RegExp pattern
            this._keywords = keywords;
<span class="apidocCodeCommentSpan">            /* falls through */
</span>        case keywords:
            // use default keywords
            this._message += this._keywords.join(', ');
            this._keywordRegEx = new RegExp('\\b(' + this._keywords.join('|') + ')\\b', 'gi');
            break;
        case typeof keywords === 'string':
            // use string passed in as the RegExp pattern
            this._message = 'Comments cannot contain keywords based on the expression you provided';
            this._keywordRegEx = new RegExp(keywords, 'gi');
            break;
        default:
            assert(false, this.getOptionName() + ' option requires a true value, a string or an array');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_in_comments.prototype.getOptionName" id="apidoc.element.jscs.disallow_keywords_in_comments.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords_in_comments.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowKeywordsInComments';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_keywords_on_new_line" id="apidoc.module.jscs.disallow_keywords_on_new_line">module jscs.disallow_keywords_on_new_line</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_on_new_line.disallow_keywords_on_new_line" id="apidoc.element.jscs.disallow_keywords_on_new_line.disallow_keywords_on_new_line">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_keywords_on_new_line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_keywords_on_new_line = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_keywords_on_new_line.prototype" id="apidoc.module.jscs.disallow_keywords_on_new_line.prototype">module jscs.disallow_keywords_on_new_line.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_on_new_line.prototype.check" id="apidoc.element.jscs.disallow_keywords_on_new_line.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords_on_new_line.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
        var prevToken = token.getPreviousCodeToken();

        if (token.value === 'else') {
            if (prevToken.value !== '}') {
                // Special case for #905, even though it contradicts rule meaning,
                // it makes more sense that way.
                return;
            }

            if (isPreviousTokenAComment(token)) {
                // Special case for #1421, to handle comments before the else
                return;
            }
        }

        // Special cases for #885, using while as the keyword contradicts rule meaning
        // but it is more efficient and reduces complexity of the code in this rule
        if (token.value === 'while') {
            var parentElement = token.parentElement;

            // "while" that is part of a do will not return nodes as it is not a start token
            if (parentElement.type !== 'DoWhileStatement' || prevToken.value !== '}') {
                // allow "while" that is part of a "do while" with no braces to succeed
                return;
            }

            if (isPreviousTokenAComment(token)) {
                // Special case for #1421, to handle comments before the else
                return;
            }
        }

        errors.assert.sameLine({
            token: prevToken,
            nextToken: token
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_on_new_line.prototype.configure" id="apidoc.element.jscs.disallow_keywords_on_new_line.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords_on_new_line.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(Array.isArray(keywords), this.getOptionName() + ' option requires array value');
    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_keywords_on_new_line.prototype.getOptionName" id="apidoc.element.jscs.disallow_keywords_on_new_line.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_keywords_on_new_line.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowKeywordsOnNewLine';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_mixed_spaces_and_tabs" id="apidoc.module.jscs.disallow_mixed_spaces_and_tabs">module jscs.disallow_mixed_spaces_and_tabs</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs.disallow_mixed_spaces_and_tabs" id="apidoc.element.jscs.disallow_mixed_spaces_and_tabs.disallow_mixed_spaces_and_tabs">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_mixed_spaces_and_tabs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_mixed_spaces_and_tabs = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_mixed_spaces_and_tabs.prototype" id="apidoc.module.jscs.disallow_mixed_spaces_and_tabs.prototype">module jscs.disallow_mixed_spaces_and_tabs.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.check" id="apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_mixed_spaces_and_tabs.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var test = this._options === true ?
        (/ \t|\t [^\*]|\t $/) :
        (/ \t/);

    file.iterateTokensByType('Whitespace', function(token) {
        var match = test.exec(token.value);
        if (match) {
            errors.add('Mixed spaces and tabs found', token, token.index);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.configure" id="apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_mixed_spaces_and_tabs.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || options === 'smart',
        this.getOptionName() + ' option requires a true value or "smart"'
    );

    this._options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.getOptionName" id="apidoc.element.jscs.disallow_mixed_spaces_and_tabs.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_mixed_spaces_and_tabs.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowMixedSpacesAndTabs';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multi_line_ternary" id="apidoc.module.jscs.disallow_multi_line_ternary">module jscs.disallow_multi_line_ternary</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multi_line_ternary.disallow_multi_line_ternary" id="apidoc.element.jscs.disallow_multi_line_ternary.disallow_multi_line_ternary">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multi_line_ternary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multi_line_ternary = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multi_line_ternary.prototype" id="apidoc.module.jscs.disallow_multi_line_ternary.prototype">module jscs.disallow_multi_line_ternary.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multi_line_ternary.prototype.check" id="apidoc.element.jscs.disallow_multi_line_ternary.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_multi_line_ternary.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('ConditionalExpression', function(node) {

        errors.assert.sameLine({
            token: node.test,
            nextToken: node.consequent,
            message: 'Illegal new line after test'
        });

        errors.assert.sameLine({
            token: node.consequent,
            nextToken: node.alternate,
            message: 'Illegal new line after consequent'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multi_line_ternary.prototype.configure" id="apidoc.element.jscs.disallow_multi_line_ternary.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_multi_line_ternary.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multi_line_ternary.prototype.getOptionName" id="apidoc.element.jscs.disallow_multi_line_ternary.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_multi_line_ternary.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowMultiLineTernary';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multiple_line_breaks" id="apidoc.module.jscs.disallow_multiple_line_breaks">module jscs.disallow_multiple_line_breaks</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_breaks.disallow_multiple_line_breaks" id="apidoc.element.jscs.disallow_multiple_line_breaks.disallow_multiple_line_breaks">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_breaks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multiple_line_breaks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multiple_line_breaks.prototype" id="apidoc.module.jscs.disallow_multiple_line_breaks.prototype">module jscs.disallow_multiple_line_breaks.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_breaks.prototype.check" id="apidoc.element.jscs.disallow_multiple_line_breaks.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_breaks.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    // Iterate over all tokens (including comments)
    file.iterateTokensByType('Whitespace', function(whitespaceToken) {
        if (whitespaceToken.getNewlineCount() === 0) {
            return;
        }

        var token = whitespaceToken.getPreviousNonWhitespaceToken();

        if (!token) {
            return;
        }

        var nextToken = token.getNextNonWhitespaceToken();

        errors.assert.linesBetween({
            token: token,
            nextToken: nextToken,
            atMost: 2
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_breaks.prototype.configure" id="apidoc.element.jscs.disallow_multiple_line_breaks.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_breaks.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_breaks.prototype.getOptionName" id="apidoc.element.jscs.disallow_multiple_line_breaks.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_breaks.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowMultipleLineBreaks';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multiple_line_strings" id="apidoc.module.jscs.disallow_multiple_line_strings">module jscs.disallow_multiple_line_strings</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_strings.disallow_multiple_line_strings" id="apidoc.element.jscs.disallow_multiple_line_strings.disallow_multiple_line_strings">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_line_strings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multiple_line_strings = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multiple_line_strings.prototype" id="apidoc.module.jscs.disallow_multiple_line_strings.prototype">module jscs.disallow_multiple_line_strings.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_strings.prototype.check" id="apidoc.element.jscs.disallow_multiple_line_strings.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_strings.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByType('String', function(token) {
        if (token.getNewlineCount() !== 0) {
            errors.add('Multiline strings are disallowed.', token);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_strings.prototype.configure" id="apidoc.element.jscs.disallow_multiple_line_strings.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_strings.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_line_strings.prototype.getOptionName" id="apidoc.element.jscs.disallow_multiple_line_strings.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_line_strings.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowMultipleLineStrings';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multiple_spaces" id="apidoc.module.jscs.disallow_multiple_spaces">module jscs.disallow_multiple_spaces</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_spaces.disallow_multiple_spaces" id="apidoc.element.jscs.disallow_multiple_spaces.disallow_multiple_spaces">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_spaces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multiple_spaces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multiple_spaces.prototype" id="apidoc.module.jscs.disallow_multiple_spaces.prototype">module jscs.disallow_multiple_spaces.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_spaces.prototype.check" id="apidoc.element.jscs.disallow_multiple_spaces.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_spaces.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var token = file.getProgram().getFirstToken();
    var nextToken;

    while (token) {
        nextToken = token.getNextNonWhitespaceToken();

        if (!nextToken) {
            break;
        }

        if (!this._allowEOLComments || nextToken.type !== 'CommentLine') {
            errors.assert.spacesBetween({
                token: token,
                nextToken: nextToken,
                atMost: 1
            });
        }

        token = token.getNextNonWhitespaceToken();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_spaces.prototype.configure" id="apidoc.element.jscs.disallow_multiple_spaces.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_spaces.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true ||
        typeof options === 'object' &amp;&amp;
        options.allowEOLComments === true,
        this.getOptionName() + ' option requires true value ' +
        'or an object with `allowEOLComments` property'
    );

    this._allowEOLComments = options.allowEOLComments;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_spaces.prototype.getOptionName" id="apidoc.element.jscs.disallow_multiple_spaces.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_spaces.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowMultipleSpaces';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multiple_var_decl" id="apidoc.module.jscs.disallow_multiple_var_decl">module jscs.disallow_multiple_var_decl</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_var_decl.disallow_multiple_var_decl" id="apidoc.element.jscs.disallow_multiple_var_decl.disallow_multiple_var_decl">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_multiple_var_decl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_multiple_var_decl = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_multiple_var_decl.prototype" id="apidoc.module.jscs.disallow_multiple_var_decl.prototype">module jscs.disallow_multiple_var_decl.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_var_decl.prototype.check" id="apidoc.element.jscs.disallow_multiple_var_decl.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_var_decl.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {

    function isSourcedFromRequire(node) {
        // If this node is a CallExpression it has a callee,
        // check if this is the `require` function
        if (node.callee &amp;&amp; node.callee.name === 'require') {
            return true;
        }

        // If this CallExpression is not a `require` we keep looking for
        // the `require` method up in the tree
        if (node.callee &amp;&amp; node.callee.object) {
            return isSourcedFromRequire(node.callee.object);
        }

        // If there is no `callee` this might be a MemberExpression, keep
        // look for the `require` method up in the tree.
        if (node.object) {
            return isSourcedFromRequire(node.object);
        }

        return false;
    }

    var inStrictMode = this._strictMode;
    var exceptUndefined = this._exceptUndefined;
    var exceptRequire = this._exceptRequire;

    file.iterateNodesByType('VariableDeclaration', function(node) {
        var definedVariables = node.declarations.filter(function(declaration) {
            return !!declaration.init;
        });
        var hasDefinedVariables = definedVariables.length &gt; 0;

        var requireStatements = node.declarations.filter(function(declaration) {
            var init = declaration.init;
            return init &amp;&amp; isSourcedFromRequire(init);
        });
        var allRequireStatements = requireStatements.length === node.declarations.length;

        var isForStatement = node.parentElement.type === 'ForStatement';

        // allow single var declarations
        if (node.declarations.length === 1) {
            return;
        }

        // allow multiple var declarations in for statement unless we're in strict mode
        // for (var i = 0, j = myArray.length; i &lt; j; i++) {}
        if (!inStrictMode &amp;&amp; isForStatement) {
            return;
        }

        // allow multiple var declarations with all undefined variables in exceptUndefined mode
        // var a, b, c
        if (exceptUndefined &amp;&amp; !hasDefinedVariables) {
            return;
        }

        // allow multiple var declaration with all require
        // var a = require("a"), b = require("b")
        if (exceptRequire &amp;&amp; allRequireStatements) {
            return;
        }

        // allow multiple var declarations only with require &amp;&amp; undefined
        // var a = require("a"), b = require("b"), x, y
        if (exceptUndefined &amp;&amp; exceptRequire &amp;&amp; definedVariables.length === requireStatements.length) {
            return;
        }

        errors.add('Multiple var declaration', node);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_var_decl.prototype.configure" id="apidoc.element.jscs.disallow_multiple_var_decl.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_var_decl.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    // support for legacy options
    if (typeof options !== 'object') {
        assert(
            options === true ||
            options === 'strict' ||
            options === 'exceptUndefined',
            this.getOptionName() +
                ' option requires a true value, "strict", "exceptUndefined", or an object'
        );

        var _options = {
            strict: options === 'strict',
            allExcept: []
        };

        if (options === 'exceptUndefined') {
            _options.allExcept.push('undefined');
        }

        return this.configure(_options);
    }

    if (Array.isArray(options.allExcept)) {
        this._exceptUndefined = options.allExcept.indexOf('undefined') &gt; -1;
        this._exceptRequire = options.allExcept.indexOf('require') &gt; -1;
    }

    this._strictMode = options.strict === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_multiple_var_decl.prototype.getOptionName" id="apidoc.element.jscs.disallow_multiple_var_decl.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_multiple_var_decl.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowMultipleVarDecl';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_named_unassigned_functions" id="apidoc.module.jscs.disallow_named_unassigned_functions">module jscs.disallow_named_unassigned_functions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_named_unassigned_functions.disallow_named_unassigned_functions" id="apidoc.element.jscs.disallow_named_unassigned_functions.disallow_named_unassigned_functions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_named_unassigned_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_named_unassigned_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_named_unassigned_functions.prototype" id="apidoc.module.jscs.disallow_named_unassigned_functions.prototype">module jscs.disallow_named_unassigned_functions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_named_unassigned_functions.prototype.check" id="apidoc.element.jscs.disallow_named_unassigned_functions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_named_unassigned_functions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('FunctionExpression', function(node) {
        // If the function has been named via left hand assignment, skip it
        //   e.g. `var hello = function() {`, `foo.bar = function() {`
        if (node.parentElement.type.match(/VariableDeclarator|Property|AssignmentExpression/)) {
            return;
        }

        // If the function has not been named, skip it
        //   e.g. `[].forEach(function() {`
        if (node.id === null) {
            return;
        }

        // Otherwise, complain that it is being named
        errors.add('Inline functions cannot be named', node);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_named_unassigned_functions.prototype.configure" id="apidoc.element.jscs.disallow_named_unassigned_functions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_named_unassigned_functions.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires true value'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_named_unassigned_functions.prototype.getOptionName" id="apidoc.element.jscs.disallow_named_unassigned_functions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_named_unassigned_functions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowNamedUnassignedFunctions';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_nested_ternaries" id="apidoc.module.jscs.disallow_nested_ternaries">module jscs.disallow_nested_ternaries</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_nested_ternaries.disallow_nested_ternaries" id="apidoc.element.jscs.disallow_nested_ternaries.disallow_nested_ternaries">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_nested_ternaries
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_nested_ternaries = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_nested_ternaries.prototype" id="apidoc.module.jscs.disallow_nested_ternaries.prototype">module jscs.disallow_nested_ternaries.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_nested_ternaries.prototype.check" id="apidoc.element.jscs.disallow_nested_ternaries.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_nested_ternaries.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var maxLevel = this._maxLevel;
    file.iterateNodesByType('ConditionalExpression', function(node) {
        var level = 0;
        var getLevel = function(currentNode) {
            if (currentNode.parentElement &amp;&amp; currentNode.parentElement.type === 'ConditionalExpression') {
                level += 1;
                if (level &gt; maxLevel) {
                    errors.add('Illegal nested ternary', node);
                    return;
                }
                getLevel(currentNode.parentElement);
            }
        };
        getLevel(node);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_nested_ternaries.prototype.configure" id="apidoc.element.jscs.disallow_nested_ternaries.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_nested_ternaries.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || (typeof options.maxLevel === 'number' &amp;&amp; options.maxLevel &gt; 0),
        this.getOptionName() + ' option requires a true value or an object with "maxLevel" property'
    );

    this._maxLevel = 0;
    if (options.maxLevel) {
        this._maxLevel = options.maxLevel;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_nested_ternaries.prototype.getOptionName" id="apidoc.element.jscs.disallow_nested_ternaries.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_nested_ternaries.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowNestedTernaries';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_newline_before_block_statements" id="apidoc.module.jscs.disallow_newline_before_block_statements">module jscs.disallow_newline_before_block_statements</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_newline_before_block_statements.disallow_newline_before_block_statements" id="apidoc.element.jscs.disallow_newline_before_block_statements.disallow_newline_before_block_statements">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_newline_before_block_statements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_newline_before_block_statements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_newline_before_block_statements.prototype" id="apidoc.module.jscs.disallow_newline_before_block_statements.prototype">module jscs.disallow_newline_before_block_statements.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_newline_before_block_statements.prototype.check" id="apidoc.element.jscs.disallow_newline_before_block_statements.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_newline_before_block_statements.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var setting = this._setting;
    var hasMultiLineEx = this._hasMultiLineEx;

    function assertSameLine(token, nextToken) {
        errors.assert.sameLine({
            token: token,
            nextToken: nextToken,
            message: 'Newline before curly brace for block statement is disallowed'
        });
    }
    function assertDifferentLine(token, nextToken) {
        errors.assert.differentLine({
            token: token,
            nextToken: nextToken,
            message: 'Newline before curly brace for block statement is required'
        });
    }

    file.iterateNodesByType(['BlockStatement', 'ClassBody'], function(node) {
        if (isBareBlock(node)) {
            return;
        }

        if (setting === true || setting.indexOf(getBlockType(node)) !== -1) {
            var openingBrace = node.getFirstToken();
            var prevToken = openingBrace.getPreviousCodeToken();

            if (hasMultiLineEx !== true) {
                assertSameLine(prevToken, openingBrace);
                return;
            }

            // Check if the 'conditions' span on multiple lines.
            // The simplest way is to check if the round braces are on different lines.
            //
            // For example:
            //     // same line
            //     for (var i = 0; i &lt; length; i++) {
            //     }
            //
            //     // different lines:
            //     for (var i = 0;
            //          i &lt; length;
            //          i++)
            //     {
            //     }
            var parentElement = node.parentElement;
            var parentNextToken = file.getFirstNodeToken(parentElement);
            var openingRoundBrace = file.findNextToken(parentNextToken, 'Punctuator', '(');
            var closingRoundBrace = file.findPrevToken(openingBrace, 'Punctuator', ')');

            // Not always the conditions are there: to check look for the presence of round braces.
            // For example:
            //     try {
            //     } ...
            if (openingRoundBrace &amp;&amp; closingRoundBrace &amp;&amp;
                    !file.isOnTheSameLine(openingRoundBrace, closingRoundBrace)) {
                assertDifferentLine(prevToken, openingBrace);
            } else {
                assertSameLine(prevToken, openingBrace);
            }
        }
    });

    if (setting === true || setting.indexOf('switch') !== -1) {
        file.iterateNodesByType(['SwitchStatement'], function(node) {
            var openingBrace = file.findNextToken(file.getLastNodeToken(node.discriminant), 'Punctuator', '{');
            var prevToken = file.getPrevToken(openingBrace);

            if (hasMultiLineEx !== true) {
                assertSameLine(prevToken, openingBrace);
                return;
            }

            var openingRoundBrace = file.findNextToken(file.getFirstNodeToken(node), 'Punctuator', '(');
            var closingRoundBrace = file.findPrevToken(openingBrace, 'Punctuator', ')');

            if (!file.isOnTheSameLine(openingRoundBrace, closingRoundBrace)) {
                assertDifferentLine(prevToken, openingBrace);
            } else {
                assertSameLine(prevToken, openingBrace);
            }
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_newline_before_block_statements.prototype.configure" id="apidoc.element.jscs.disallow_newline_before_block_statements.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_newline_before_block_statements.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var settingValue;
    this._hasMultiLineEx = false;
    if (options.constructor === Object) {
        settingValue = options.value;
        if (options.allExcept) {
            assert(
                Array.isArray(options.allExcept) &amp;&amp; options.allExcept.length === 1 &amp;&amp;
                options.allExcept[0] === 'multiLine',
                'allExcept option must be an array whose values can be only `multiLine`'
            );
            this._hasMultiLineEx = true;
        }
    } else {
        settingValue = options;
    }
    assert(
        Array.isArray(settingValue) &amp;&amp; settingValue.length || settingValue === true,
        'disallowNewlineBeforeBlockStatements option requires non-empty array value or true value'
    );

    this._setting = settingValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_newline_before_block_statements.prototype.getOptionName" id="apidoc.element.jscs.disallow_newline_before_block_statements.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_newline_before_block_statements.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowNewlineBeforeBlockStatements';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_node_types" id="apidoc.module.jscs.disallow_node_types">module jscs.disallow_node_types</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_node_types.disallow_node_types" id="apidoc.element.jscs.disallow_node_types.disallow_node_types">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_node_types
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_node_types = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_node_types.prototype" id="apidoc.module.jscs.disallow_node_types.prototype">module jscs.disallow_node_types.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_node_types.prototype.check" id="apidoc.element.jscs.disallow_node_types.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_node_types.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var disallowedNodeTypes = this._nodeTypes;
    file.iterateNodesByType(disallowedNodeTypes, function(node) {
        errors.add('Illegal use of disallowed node type: ' + node.type, node);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_node_types.prototype.configure" id="apidoc.element.jscs.disallow_node_types.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_node_types.prototype.</span>configure
        <span class="apidocSignatureSpan">(nodeTypes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (nodeTypes) {
    assert(
        Array.isArray(nodeTypes),
        'disallowNodeTypes option requires an array'
    );

    this._nodeTypes = nodeTypes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_node_types.prototype.getOptionName" id="apidoc.element.jscs.disallow_node_types.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_node_types.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowNodeTypes';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_not_operators_in_conditionals" id="apidoc.module.jscs.disallow_not_operators_in_conditionals">module jscs.disallow_not_operators_in_conditionals</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_not_operators_in_conditionals.disallow_not_operators_in_conditionals" id="apidoc.element.jscs.disallow_not_operators_in_conditionals.disallow_not_operators_in_conditionals">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_not_operators_in_conditionals
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_not_operators_in_conditionals = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_not_operators_in_conditionals.prototype" id="apidoc.module.jscs.disallow_not_operators_in_conditionals.prototype">module jscs.disallow_not_operators_in_conditionals.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.check" id="apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_not_operators_in_conditionals.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    function hasNotOperator(test) {
        return test.type === 'UnaryExpression' &amp;&amp; test.operator === '!';
    }

    function hasNotEqualOperator(test) {
        return test.type === 'BinaryExpression' &amp;&amp; test.operator === '!=';
    }

    function hasStrictNotEqualOperator(test) {
        return test.type === 'BinaryExpression' &amp;&amp; test.operator === '!==';
    }

    file.iterateNodesByType(['IfStatement', 'ConditionalExpression'], function(node) {
        var alternate = node.alternate;

        // check if the if statement has an else block
        if (node.type === 'IfStatement' &amp;&amp; (!alternate || alternate.type !== 'BlockStatement')) {
            return;
        }
        var test = node.test;
        if (hasNotOperator(test)) {
            errors.add('Illegal use of not operator in if statement', test);
        }
        if (hasNotEqualOperator(test)) {
            errors.add('Illegal use of not equal operator in if statement', test);
        }
        if (hasStrictNotEqualOperator(test)) {
            errors.add('Illegal use of strict not equal operator in if statement', test);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.configure" id="apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_not_operators_in_conditionals.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.getOptionName" id="apidoc.element.jscs.disallow_not_operators_in_conditionals.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_not_operators_in_conditionals.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowNotOperatorsInConditionals';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_object_keys_on_new_line" id="apidoc.module.jscs.disallow_object_keys_on_new_line">module jscs.disallow_object_keys_on_new_line</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_object_keys_on_new_line.disallow_object_keys_on_new_line" id="apidoc.element.jscs.disallow_object_keys_on_new_line.disallow_object_keys_on_new_line">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_object_keys_on_new_line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_object_keys_on_new_line = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_object_keys_on_new_line.prototype" id="apidoc.module.jscs.disallow_object_keys_on_new_line.prototype">module jscs.disallow_object_keys_on_new_line.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.check" id="apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_object_keys_on_new_line.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('ObjectExpression', function(node) {
        var properties = node.properties;
        for (var i = 1; i &lt; properties.length; i++) {
            var propertyNode = properties[i];

            errors.assert.sameLine({
                token: propertyNode.getPreviousCodeToken(),
                nextToken: propertyNode.getFirstToken(),
                message: 'Object keys should be on the same line'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.configure" id="apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_object_keys_on_new_line.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.getOptionName" id="apidoc.element.jscs.disallow_object_keys_on_new_line.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_object_keys_on_new_line.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowObjectKeysOnNewLine';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_operator_before_line_break" id="apidoc.module.jscs.disallow_operator_before_line_break">module jscs.disallow_operator_before_line_break</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_operator_before_line_break.disallow_operator_before_line_break" id="apidoc.element.jscs.disallow_operator_before_line_break.disallow_operator_before_line_break">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_operator_before_line_break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_operator_before_line_break = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_operator_before_line_break.prototype" id="apidoc.module.jscs.disallow_operator_before_line_break.prototype">module jscs.disallow_operator_before_line_break.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_operator_before_line_break.prototype.check" id="apidoc.element.jscs.disallow_operator_before_line_break.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_operator_before_line_break.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue('Punctuator', this._operators, function(token) {
        errors.assert.sameLine({
            token: token,
            nextToken: file.getNextToken(token),
            message: 'Operator needs to either be on the same line or after a line break.'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_operator_before_line_break.prototype.configure" id="apidoc.element.jscs.disallow_operator_before_line_break.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_operator_before_line_break.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    assert(Array.isArray(operators) || operators === true,
        this.getOptionName() + ' option requires array or true value');

    if (operators === true) {
        operators = defaultOperators;
    }
    this._operators = operators;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_operator_before_line_break.prototype.getOptionName" id="apidoc.element.jscs.disallow_operator_before_line_break.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_operator_before_line_break.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowOperatorBeforeLineBreak';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_after_blocks" id="apidoc.module.jscs.disallow_padding_newlines_after_blocks">module jscs.disallow_padding_newlines_after_blocks</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks.disallow_padding_newlines_after_blocks" id="apidoc.element.jscs.disallow_padding_newlines_after_blocks.disallow_padding_newlines_after_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_after_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_after_blocks.prototype" id="apidoc.module.jscs.disallow_padding_newlines_after_blocks.prototype">module jscs.disallow_padding_newlines_after_blocks.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.check" id="apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_blocks.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('BlockStatement', function(node) {
        var endToken = file.getLastNodeToken(node);
        var nextToken = file.getNextToken(endToken);

        while (nextToken.type !== 'EOF') {
            if (file.isOnTheSameLine(endToken, nextToken)) {
                endToken = nextToken;
                nextToken = file.getNextToken(nextToken);
                continue;
            }

            errors.assert.linesBetween({
                token: endToken,
                nextToken: nextToken,
                atMost: 1,
                message: 'Extra newline after closing curly brace'
            });

            return;
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.configure" id="apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_blocks.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    assert(
        value === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.getOptionName" id="apidoc.element.jscs.disallow_padding_newlines_after_blocks.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_blocks.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowPaddingNewLinesAfterBlocks';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_after_use_strict" id="apidoc.module.jscs.disallow_padding_newlines_after_use_strict">module jscs.disallow_padding_newlines_after_use_strict</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict.disallow_padding_newlines_after_use_strict" id="apidoc.element.jscs.disallow_padding_newlines_after_use_strict.disallow_padding_newlines_after_use_strict">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_after_use_strict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_after_use_strict = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_after_use_strict.prototype" id="apidoc.module.jscs.disallow_padding_newlines_after_use_strict.prototype">module jscs.disallow_padding_newlines_after_use_strict.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.check" id="apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_use_strict.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('Directive', function(node) {
        var literal = node.value;

        if (literal.value !== 'use strict') {
            return;
        }

        var endOfNode = file.getLastNodeToken(node);
        var nextToken = file.getNextToken(endOfNode, {
            includeComments: true
        });

        errors.assert.linesBetween({
            atMost: 1,
            token: endOfNode,
            nextToken: nextToken
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.configure" id="apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_use_strict.prototype.</span>configure
        <span class="apidocSignatureSpan">(disallowPaddingNewLinesAfterUseStrict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (disallowPaddingNewLinesAfterUseStrict) {
    assert(
        disallowPaddingNewLinesAfterUseStrict === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.getOptionName" id="apidoc.element.jscs.disallow_padding_newlines_after_use_strict.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_after_use_strict.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowPaddingNewLinesAfterUseStrict';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_before_export" id="apidoc.module.jscs.disallow_padding_newlines_before_export">module jscs.disallow_padding_newlines_before_export</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_export.disallow_padding_newlines_before_export" id="apidoc.element.jscs.disallow_padding_newlines_before_export.disallow_padding_newlines_before_export">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_export
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_before_export = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_before_export.prototype" id="apidoc.module.jscs.disallow_padding_newlines_before_export.prototype">module jscs.disallow_padding_newlines_before_export.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.check" id="apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_export.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('AssignmentExpression', function(node) {
        var left = node.left;

        if (!(
            left.object &amp;&amp;
            left.object.name === 'module' &amp;&amp;
            left.property &amp;&amp;
            left.property.name === 'exports')) {
            return;
        }

        var firstToken = node.getFirstToken();
        var prevToken = file.getPrevToken(firstToken, {includeComments: true});

        errors.assert.linesBetween({
            atMost: 1,
            token: prevToken,
            nextToken: firstToken,
            message: 'Unexpected extra newline before export'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.configure" id="apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_export.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    assert(
        value === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.getOptionName" id="apidoc.element.jscs.disallow_padding_newlines_before_export.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_export.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowPaddingNewLinesBeforeExport';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_before_keywords" id="apidoc.module.jscs.disallow_padding_newlines_before_keywords">module jscs.disallow_padding_newlines_before_keywords</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords.disallow_padding_newlines_before_keywords" id="apidoc.element.jscs.disallow_padding_newlines_before_keywords.disallow_padding_newlines_before_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_before_keywords = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_before_keywords.prototype" id="apidoc.module.jscs.disallow_padding_newlines_before_keywords.prototype">module jscs.disallow_padding_newlines_before_keywords.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.check" id="apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_keywords.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
        errors.assert.linesBetween({
            token: file.getPrevToken(token, { includeComments: true }),
            nextToken: token,
            atMost: 1,
            message: 'Keyword `' + token.value + '` should not have an empty line above it'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.configure" id="apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_keywords.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(Array.isArray(keywords) || keywords === true,
        this.getOptionName() + ' option requires array or true value');

    if (keywords === true) {
        keywords = defaultKeywords;
    }

    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.getOptionName" id="apidoc.element.jscs.disallow_padding_newlines_before_keywords.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_keywords.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowPaddingNewlinesBeforeKeywords';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_before_line_comments" id="apidoc.module.jscs.disallow_padding_newlines_before_line_comments">module jscs.disallow_padding_newlines_before_line_comments</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments.disallow_padding_newlines_before_line_comments" id="apidoc.element.jscs.disallow_padding_newlines_before_line_comments.disallow_padding_newlines_before_line_comments">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_before_line_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_before_line_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_before_line_comments.prototype" id="apidoc.module.jscs.disallow_padding_newlines_before_line_comments.prototype">module jscs.disallow_padding_newlines_before_line_comments.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.check" id="apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_line_comments.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByType('CommentLine', function(comment) {
        if (comment.getLoc().start.line === 1) {
            return;
        }

        errors.assert.linesBetween({
            token: file.getPrevToken(comment, {includeComments: true}),
            nextToken: comment,
            atMost: 1,
            message: 'Line comments must not be preceded with a blank line'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.configure" id="apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_line_comments.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    assert(
        value === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.getOptionName" id="apidoc.element.jscs.disallow_padding_newlines_before_line_comments.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_before_line_comments.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowPaddingNewLinesBeforeLineComments';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_in_blocks" id="apidoc.module.jscs.disallow_padding_newlines_in_blocks">module jscs.disallow_padding_newlines_in_blocks</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks.disallow_padding_newlines_in_blocks" id="apidoc.element.jscs.disallow_padding_newlines_in_blocks.disallow_padding_newlines_in_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_in_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_in_blocks.prototype" id="apidoc.module.jscs.disallow_padding_newlines_in_blocks.prototype">module jscs.disallow_padding_newlines_in_blocks.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.check" id="apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_blocks.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptConditionals = this._exceptConditionals;
    var exceptFunctions = this._exceptFunctions;
    var checkOpen = this._checkOpen;
    var checkClose = this._checkClose;

    file.iterateNodesByType('BlockStatement', function(node) {
        var openingBracket;
        var closingBracket;

        if (exceptConditionals &amp;&amp; node.parentElement.type === 'IfStatement' ||
            exceptFunctions &amp;&amp; (node.parentElement.type === 'FunctionExpression' ||
            node.parentElement.type === 'FunctionDeclaration')) {
            return;
        }

        if (checkOpen === true) {
            openingBracket = node.getFirstToken();

            errors.assert.linesBetween({
                token: openingBracket,
                nextToken: file.getNextToken(openingBracket, {includeComments: true}),
                atMost: 1,
                message: 'Expected no padding newline after opening curly brace'
            });
        }

        if (checkClose === true) {
            closingBracket = file.getLastNodeToken(node);

            errors.assert.linesBetween({
                token: file.getPrevToken(closingBracket, {includeComments: true}),
                nextToken: closingBracket,
                atMost: 1,
                message: 'Expected no padding newline before closing curly brace'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.configure" id="apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_blocks.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var optionName = this.getOptionName();

    this._checkOpen = true;
    this._checkClose = true;

    if (typeof options === 'object') {
        assert(options.allExcept || options.open || options.close,
        optionName + 'option requires either "open", "close", "allExcept"');

        if (options.allExcept) {
            assert(Array.isArray(options.allExcept), optionName + ' option requires "allExcept" to be an array');
            assert(options.allExcept.length &gt; 0, optionName + ' option requires "allExcept" to have at least one ' +
            'item or be set to `true`');
            this._exceptConditionals = options.allExcept.indexOf('conditionals') &gt; -1;
            this._exceptFunctions = options.allExcept.indexOf('functions') &gt; -1;
        }

        if (options.open || options.close) {
            assert(typeof options.open === 'boolean' &amp;&amp; typeof options.close === 'boolean',
              this.getOptionName() + ' option requires the "open" and "close" ' +
              'properties to be booleans');

            this._checkOpen = options.open;
            this._checkClose = options.close;
        }
    } else {
        assert(options === true, this.getOptionName() + ' option requires either a true value, or an object');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.getOptionName" id="apidoc.element.jscs.disallow_padding_newlines_in_blocks.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_blocks.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowPaddingNewlinesInBlocks';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_in_objects" id="apidoc.module.jscs.disallow_padding_newlines_in_objects">module jscs.disallow_padding_newlines_in_objects</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_objects.disallow_padding_newlines_in_objects" id="apidoc.element.jscs.disallow_padding_newlines_in_objects.disallow_padding_newlines_in_objects">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_padding_newlines_in_objects
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_padding_newlines_in_objects = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_padding_newlines_in_objects.prototype" id="apidoc.module.jscs.disallow_padding_newlines_in_objects.prototype">module jscs.disallow_padding_newlines_in_objects.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.check" id="apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_objects.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('ObjectExpression', function(node) {
        var openingBracket = node.getFirstToken();
        var nextToken = file.getNextToken(openingBracket);

        if (nextToken.type === 'Punctuator' &amp;&amp; nextToken.value === '}') {
            return;
        }

        errors.assert.sameLine({
            token: openingBracket,
            nextToken: nextToken,
            message: 'Illegal newline after opening curly brace'
        });

        var closingBracket = file.getLastNodeToken(node);

        errors.assert.sameLine({
            token: file.getPrevToken(closingBracket),
            nextToken: closingBracket,
            message: 'Illegal newline before closing curly brace'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.configure" id="apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_objects.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    assert(
        value === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.getOptionName" id="apidoc.element.jscs.disallow_padding_newlines_in_objects.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_padding_newlines_in_objects.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowPaddingNewLinesInObjects';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_parentheses_around_arrow_param" id="apidoc.module.jscs.disallow_parentheses_around_arrow_param">module jscs.disallow_parentheses_around_arrow_param</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param.disallow_parentheses_around_arrow_param" id="apidoc.element.jscs.disallow_parentheses_around_arrow_param.disallow_parentheses_around_arrow_param">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_parentheses_around_arrow_param
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_parentheses_around_arrow_param = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_parentheses_around_arrow_param.prototype" id="apidoc.module.jscs.disallow_parentheses_around_arrow_param.prototype">module jscs.disallow_parentheses_around_arrow_param.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.check" id="apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_parentheses_around_arrow_param.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    function isWrapped(node) {
        var openParensToken = file.getPrevToken(file.getFirstNodeToken(node));
        var closingParensToken = file.getNextToken(file.getLastNodeToken(node));
        var closingTokenValue = closingParensToken ? closingParensToken.value : '';

        return openParensToken.value + closingTokenValue === '()';
    }

    file.iterateNodesByType('ArrowFunctionExpression', function(node) {
        if (node.params.length !== 1) {
            return;
        }
        var firstParam = node.params[0];

        var hasDefaultParameter = firstParam.type === 'AssignmentPattern';
        var hasDestructuring = firstParam.type === 'ObjectPattern' || firstParam.type === 'ArrayPattern';
        var hasRestElement = firstParam.type === 'RestElement';

        if (hasDefaultParameter ||
            hasDestructuring ||
            hasRestElement) {
            return;
        }

        if (isWrapped(firstParam)) {
            errors.add('Illegal wrap of arrow function expressions in parentheses', firstParam);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.configure" id="apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_parentheses_around_arrow_param.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.getOptionName" id="apidoc.element.jscs.disallow_parentheses_around_arrow_param.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_parentheses_around_arrow_param.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowParenthesesAroundArrowParam';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_quoted_keys_in_objects" id="apidoc.module.jscs.disallow_quoted_keys_in_objects">module jscs.disallow_quoted_keys_in_objects</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.disallow_quoted_keys_in_objects" id="apidoc.element.jscs.disallow_quoted_keys_in_objects.disallow_quoted_keys_in_objects">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_quoted_keys_in_objects
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_quoted_keys_in_objects = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_quoted_keys_in_objects.prototype" id="apidoc.module.jscs.disallow_quoted_keys_in_objects.prototype">module jscs.disallow_quoted_keys_in_objects.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype._fix" id="apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.disallow_quoted_keys_in_objects.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var node = error.element;
    var key = node.key.childElements[0];

    var newKey = new cst.Token(key.type, key.getSourceCode().slice(1, -1));

    node.key.replaceChild(newKey, key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &amp;&amp; instance._fix) {
        // "error.fixed = true" should go first, so rule can
        // decide for itself (with "error.fixed = false")
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.check" id="apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_quoted_keys_in_objects.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var KEY_NAME_RE = /^(0|[1-9][0-9]*|[a-zA-Z_$]+[\w$]*)$/; // number or identifier
    var exceptReserved = this._exceptReserved;

    file.iterateNodesByType('ObjectExpression', function(node) {
        node.properties.forEach(function(prop) {
            var key = prop.key;

            // Spread properties
            if (!key) {
                return;
            }

            if (key.type !== 'StringLiteral') {
                return;
            }

            if (typeof key.value !== 'string') {
                return;
            }

            if (!KEY_NAME_RE.test(key.value)) {
                return;
            }

            if (exceptReserved &amp;&amp; reservedWords.check(key.value, file.getDialect(), true)) {
                return;
            }

            errors.cast({
                message: 'Extra quotes for key',
                element: prop
            });
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.configure" id="apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_quoted_keys_in_objects.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || options === 'allButReserved' || typeof options === 'object',
        this.getOptionName() + ' option requires a true value or an object'
    );

    this._exceptReserved = options === 'allButReserved';
    if (Array.isArray(options.allExcept)) {
        this._exceptReserved = options.allExcept.indexOf('reserved') !== -1;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.getOptionName" id="apidoc.element.jscs.disallow_quoted_keys_in_objects.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_quoted_keys_in_objects.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowQuotedKeysInObjects';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_semicolons" id="apidoc.module.jscs.disallow_semicolons">module jscs.disallow_semicolons</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_semicolons.disallow_semicolons" id="apidoc.element.jscs.disallow_semicolons.disallow_semicolons">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_semicolons
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_semicolons = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_semicolons.prototype" id="apidoc.module.jscs.disallow_semicolons.prototype">module jscs.disallow_semicolons.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_semicolons.prototype._fix" id="apidoc.element.jscs.disallow_semicolons.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.disallow_semicolons.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    error.element.remove();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &amp;&amp; instance._fix) {
        // "error.fixed = true" should go first, so rule can
        // decide for itself (with "error.fixed = false")
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_semicolons.prototype.check" id="apidoc.element.jscs.disallow_semicolons.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_semicolons.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue('Punctuator', ';', function(token) {
        var nextToken = file.getNextToken(token);

        var node = token.parentElement;

        // Ignore node exceptions
        if (node.type in nodeExceptions) {
            return;
        }

        // Ignore next token exceptions
        if (nextToken.value in tokenExceptions) {
            return;
        }

        if (nextToken.type === 'EOF' || !file.isOnTheSameLine(token, nextToken)) {
            errors.cast({
                message: 'semicolons are disallowed at the end of a line.',
                element: token
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_semicolons.prototype.configure" id="apidoc.element.jscs.disallow_semicolons.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_semicolons.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_semicolons.prototype.getOptionName" id="apidoc.element.jscs.disallow_semicolons.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_semicolons.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSemicolons';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_shorthand_arrow_functions" id="apidoc.module.jscs.disallow_shorthand_arrow_functions">module jscs.disallow_shorthand_arrow_functions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_shorthand_arrow_functions.disallow_shorthand_arrow_functions" id="apidoc.element.jscs.disallow_shorthand_arrow_functions.disallow_shorthand_arrow_functions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_shorthand_arrow_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_shorthand_arrow_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_shorthand_arrow_functions.prototype" id="apidoc.module.jscs.disallow_shorthand_arrow_functions.prototype">module jscs.disallow_shorthand_arrow_functions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.check" id="apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_shorthand_arrow_functions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('ArrowFunctionExpression', function(node) {
        if (node.expression) {
            errors.add('Use arrow function with explicit block and explicit return', node.body);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.configure" id="apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_shorthand_arrow_functions.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.getOptionName" id="apidoc.element.jscs.disallow_shorthand_arrow_functions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_shorthand_arrow_functions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowShorthandArrowFunctions';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_binary_operators" id="apidoc.module.jscs.disallow_space_after_binary_operators">module jscs.disallow_space_after_binary_operators</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_binary_operators.disallow_space_after_binary_operators" id="apidoc.element.jscs.disallow_space_after_binary_operators.disallow_space_after_binary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_binary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_binary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_binary_operators.prototype" id="apidoc.module.jscs.disallow_space_after_binary_operators.prototype">module jscs.disallow_space_after_binary_operators.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_binary_operators.prototype.check" id="apidoc.element.jscs.disallow_space_after_binary_operators.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_binary_operators.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operators = this._operatorIndex;

    // Comma
    if (operators[',']) {
        file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
            if (file.getNextToken(token).value === ',') {
                return;
            }
            errors.assert.noWhitespaceBetween({
                token: token,
                nextToken: file.getNextToken(token),
                message: 'Operator , should stick to following expression'
            });
        });
    }

    // For everything else
    file.iterateNodesByType(
        ['BinaryExpression', 'AssignmentExpression', 'VariableDeclarator', 'LogicalExpression'],
        function(node) {
            var operator;
            var expression;

            if (node.type === 'VariableDeclarator') {
                expression = node.init;
                operator = '=';
            } else {
                operator = node.operator;
                expression = node.right;
            }

            if (expression === null) {
                return;
            }

            var operatorToken = file.findPrevOperatorToken(
                file.getFirstNodeToken(expression),
                operator
            );

            var nextToken = file.getNextToken(operatorToken);

            if (operators[operator]) {
                errors.assert.noWhitespaceBetween({
                    token: operatorToken,
                    nextToken: nextToken,
                    message: 'Operator ' + operator + ' should stick to following expression'
                });
            }
        }
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_binary_operators.prototype.configure" id="apidoc.element.jscs.disallow_space_after_binary_operators.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_binary_operators.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + ' option requires array or true value'
    );

    if (isTrue) {
        operators = allOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &lt; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_binary_operators.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_after_binary_operators.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_binary_operators.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpaceAfterBinaryOperators';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_comma" id="apidoc.module.jscs.disallow_space_after_comma">module jscs.disallow_space_after_comma</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_comma.disallow_space_after_comma" id="apidoc.element.jscs.disallow_space_after_comma.disallow_space_after_comma">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_comma = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_comma.prototype" id="apidoc.module.jscs.disallow_space_after_comma.prototype">module jscs.disallow_space_after_comma.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_comma.prototype.check" id="apidoc.element.jscs.disallow_space_after_comma.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_comma.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptSparseArrays = this._exceptSparseArrays;
    file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
        var nextToken = file.getNextToken(token);

        if (exceptSparseArrays &amp;&amp; nextToken.value === ',') {
            return;
        }
        errors.assert.noWhitespaceBetween({
            token: token,
            nextToken: nextToken,
            message: 'Illegal space after comma'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_comma.prototype.configure" id="apidoc.element.jscs.disallow_space_after_comma.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_comma.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    if (typeof options !== 'object') {
        assert(
            options === true,
            this.getOptionName() + ' option requires true value or an object'
        );
        var _options = {allExcept: []};
        return this.configure(_options);
    }

    assert(
        Array.isArray(options.allExcept),
        ' property `allExcept` in ' + this.getOptionName() + ' should be an array of strings'
    );
    this._exceptSparseArrays = options.allExcept.indexOf('sparseArrays') &gt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_comma.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_after_comma.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_comma.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpaceAfterComma';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_keywords" id="apidoc.module.jscs.disallow_space_after_keywords">module jscs.disallow_space_after_keywords</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_keywords.disallow_space_after_keywords" id="apidoc.element.jscs.disallow_space_after_keywords.disallow_space_after_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_keywords.prototype" id="apidoc.module.jscs.disallow_space_after_keywords.prototype">module jscs.disallow_space_after_keywords.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_keywords.prototype.check" id="apidoc.element.jscs.disallow_space_after_keywords.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_keywords.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
        var nextToken = file.getNextToken(token);

        // Make an exception if the next token is not a Punctuator such as a Keyword or Identifier
        if (nextToken.type !== 'Punctuator') {
            return;
        }
        errors.assert.noWhitespaceBetween({
            token: token,
            nextToken: nextToken
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_keywords.prototype.configure" id="apidoc.element.jscs.disallow_space_after_keywords.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_keywords.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(
        Array.isArray(keywords) || keywords === true,
        this.getOptionName() + ' option requires array or true value'
    );

    if (keywords === true) {
        keywords = defaultKeywords;
    }

    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_keywords.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_after_keywords.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_keywords.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpaceAfterKeywords';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_line_comment" id="apidoc.module.jscs.disallow_space_after_line_comment">module jscs.disallow_space_after_line_comment</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_line_comment.disallow_space_after_line_comment" id="apidoc.element.jscs.disallow_space_after_line_comment.disallow_space_after_line_comment">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_line_comment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_line_comment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_line_comment.prototype" id="apidoc.module.jscs.disallow_space_after_line_comment.prototype">module jscs.disallow_space_after_line_comment.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_line_comment.prototype.check" id="apidoc.element.jscs.disallow_space_after_line_comment.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_line_comment.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByType('CommentLine', function(comment) {
        var value = comment.value;
        if (value.length &gt; 0 &amp;&amp; value[0] === ' ') {
            errors.add('Illegal space after line comment', comment);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_line_comment.prototype.configure" id="apidoc.element.jscs.disallow_space_after_line_comment.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_line_comment.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_line_comment.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_after_line_comment.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_line_comment.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpaceAfterLineComment';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_object_keys" id="apidoc.module.jscs.disallow_space_after_object_keys">module jscs.disallow_space_after_object_keys</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_object_keys.disallow_space_after_object_keys" id="apidoc.element.jscs.disallow_space_after_object_keys.disallow_space_after_object_keys">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_object_keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_object_keys = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_object_keys.prototype" id="apidoc.module.jscs.disallow_space_after_object_keys.prototype">module jscs.disallow_space_after_object_keys.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_object_keys.prototype.check" id="apidoc.element.jscs.disallow_space_after_object_keys.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_object_keys.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptSingleline = this._exceptSingleline;
    var exceptMultiline = this._exceptMultiline;
    var exceptAligned = this._exceptAligned;
    var exceptMethod = this._exceptMethod;

    file.iterateNodesByType('ObjectExpression', function(node) {
        var multiline = node.getNewlineCount() &gt; 0;
        if (exceptSingleline &amp;&amp; !multiline) {
            return;
        }
        if (exceptMultiline &amp;&amp; multiline) {
            return;
        }

        var maxKeyEndPos = 0;
        var tokens = [];
        node.properties.forEach(function(property) {
            if (property.shorthand ||
                (exceptMethod &amp;&amp; property.method) ||
                property.type === 'SpreadProperty') {
                return;
            }

            var keyToken = file.getLastNodeToken(property.key);
            if (property.computed === true) {
                keyToken = file.getNextToken(keyToken);
            }

            if (exceptAligned) {
                maxKeyEndPos = Math.max(maxKeyEndPos, keyToken.getLoc().end.column);
            }
            tokens.push(keyToken);
        });

        var noSpace = true;
        if (exceptAligned) {
            var withoutSpace = 0;
            var alignedOnColon = 0;
            tokens.forEach(function(key) {
                var colon = file.getNextToken(key);
                var spaces = file.getDistanceBetween(key, colon);
                if (spaces === 0) {
                    withoutSpace++;
                } else if (spaces === maxKeyEndPos - key.getLoc().end.column) {
                    alignedOnColon++;
                }
            });

            noSpace = withoutSpace &gt; alignedOnColon;
        }

        tokens.forEach(function(key) {
            var colon = file.getNextToken(key);
            var spaces = (exceptAligned &amp;&amp; !noSpace) ? maxKeyEndPos - key.getLoc().end.column : 0;
            errors.assert.spacesBetween({
                token: key,
                nextToken: colon,
                exactly: spaces,
                message: 'Illegal space after key',
                disallowNewLine: true
            });
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_object_keys.prototype.configure" id="apidoc.element.jscs.disallow_space_after_object_keys.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_object_keys.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    if (typeof options !== 'object') {
        assert(
            options === true ||
            options === 'ignoreSingleLine' ||
            options === 'ignoreMultiLine',
            this.getOptionName() +
            ' option requires a true value, "ignoreSingleLine", "ignoreMultiLine", or an object'
        );

        var _options = {
            allExcept: []
        };

        if (options === 'ignoreSingleLine') {
            _options.allExcept.push('singleline');
        }
        if (options === 'ignoreMultiLine') {
            _options.allExcept.push('multiline');
        }

        return this.configure(_options);
    } else {
        assert(
            Array.isArray(options.allExcept),
            this.getOptionName() +
            ' option object requires allExcept array property'
        );
    }

    this._exceptSingleline = options.allExcept.indexOf('singleline') &gt; -1;
    this._exceptMultiline = options.allExcept.indexOf('multiline') &gt; -1;
    this._exceptAligned = options.allExcept.indexOf('aligned') &gt; -1;
    this._exceptMethod = options.allExcept.indexOf('method') &gt; -1;
    assert(
        !this._exceptMultiline || !this._exceptAligned,
        this.getOptionName() +
        ' option allExcept property cannot contain `aligned` and `multiline` at the same time'
    );
    assert(
        !this._exceptMultiline || !this._exceptSingleline,
        this.getOptionName() +
        ' option allExcept property cannot contain `singleline` and `multiline` at the same time'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_object_keys.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_after_object_keys.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_object_keys.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpaceAfterObjectKeys';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_prefix_unary_operators" id="apidoc.module.jscs.disallow_space_after_prefix_unary_operators">module jscs.disallow_space_after_prefix_unary_operators</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators.disallow_space_after_prefix_unary_operators" id="apidoc.element.jscs.disallow_space_after_prefix_unary_operators.disallow_space_after_prefix_unary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_after_prefix_unary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_after_prefix_unary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_after_prefix_unary_operators.prototype" id="apidoc.module.jscs.disallow_space_after_prefix_unary_operators.prototype">module jscs.disallow_space_after_prefix_unary_operators.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.check" id="apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_prefix_unary_operators.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operatorIndex = this._operatorIndex;

    file.iterateNodesByType(['UnaryExpression', 'UpdateExpression'], function(node) {
        // Check "node.prefix" for prefix type of (inc|dec)rement
        if (node.prefix &amp;&amp; operatorIndex[node.operator]) {
            var operatorToken = node.getFirstToken();
            errors.assert.noWhitespaceBetween({
                token: operatorToken,
                nextToken: file.getNextToken(operatorToken),
                message: 'Operator ' + node.operator + ' should stick to operand'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.configure" id="apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_prefix_unary_operators.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + ' option requires array or true value'
    );

    if (isTrue) {
        operators = defaultOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &lt; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_after_prefix_unary_operators.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_after_prefix_unary_operators.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpaceAfterPrefixUnaryOperators';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_binary_operators" id="apidoc.module.jscs.disallow_space_before_binary_operators">module jscs.disallow_space_before_binary_operators</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_binary_operators.disallow_space_before_binary_operators" id="apidoc.element.jscs.disallow_space_before_binary_operators.disallow_space_before_binary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_binary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_binary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_binary_operators.prototype" id="apidoc.module.jscs.disallow_space_before_binary_operators.prototype">module jscs.disallow_space_before_binary_operators.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_binary_operators.prototype.check" id="apidoc.element.jscs.disallow_space_before_binary_operators.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_binary_operators.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operators = this._operatorIndex;

    // Comma
    if (operators[',']) {
        file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
            if (file.getPrevToken(token).value === ',') {
                return;
            }
            errors.assert.noWhitespaceBetween({
                token: file.getPrevToken(token, {includeComments: true}),
                nextToken: token,
                message: 'Operator , should stick to previous expression'
            });
        });
    }

    // For everything else
    file.iterateNodesByType(
        ['BinaryExpression', 'AssignmentExpression', 'VariableDeclarator', 'LogicalExpression'],
        function(node) {
            var operator;
            var expression;

            if (node.type === 'VariableDeclarator') {
                expression = node.init;
                operator = '=';
            } else {
                operator = node.operator;
                expression = node.right;
            }

            if (expression === null) {
                return;
            }

            var operatorToken = file.findPrevOperatorToken(
                file.getFirstNodeToken(expression),
                operator
            );

            var prevToken = file.getPrevToken(operatorToken, {includeComments: true});

            if (operators[operator]) {
                errors.assert.noWhitespaceBetween({
                    token: prevToken,
                    nextToken: operatorToken,
                    message: 'Operator ' + node.operator + ' should stick to previous expression'
                });
            }
        }
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_binary_operators.prototype.configure" id="apidoc.element.jscs.disallow_space_before_binary_operators.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_binary_operators.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + ' option requires array or true value'
    );

    if (isTrue) {
        operators = allOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &lt; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_binary_operators.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_before_binary_operators.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_binary_operators.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpaceBeforeBinaryOperators';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_block_statements" id="apidoc.module.jscs.disallow_space_before_block_statements">module jscs.disallow_space_before_block_statements</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_block_statements.disallow_space_before_block_statements" id="apidoc.element.jscs.disallow_space_before_block_statements.disallow_space_before_block_statements">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_block_statements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_block_statements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_block_statements.prototype" id="apidoc.module.jscs.disallow_space_before_block_statements.prototype">module jscs.disallow_space_before_block_statements.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_block_statements.prototype.check" id="apidoc.element.jscs.disallow_space_before_block_statements.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_block_statements.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('BlockStatement', function(node) {
        if (isBareBlock(node)) {
            return;
        }
        var first = node.getFirstToken();

        errors.assert.noWhitespaceBetween({
            token: file.getPrevToken(first),
            nextToken: first,
            disallowNewLine: true,
            message: 'Extra space before opening curly brace for block expressions'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_block_statements.prototype.configure" id="apidoc.element.jscs.disallow_space_before_block_statements.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_block_statements.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_block_statements.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_before_block_statements.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_block_statements.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpaceBeforeBlockStatements';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_comma" id="apidoc.module.jscs.disallow_space_before_comma">module jscs.disallow_space_before_comma</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_comma.disallow_space_before_comma" id="apidoc.element.jscs.disallow_space_before_comma.disallow_space_before_comma">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_comma = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_comma.prototype" id="apidoc.module.jscs.disallow_space_before_comma.prototype">module jscs.disallow_space_before_comma.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_comma.prototype.check" id="apidoc.element.jscs.disallow_space_before_comma.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_comma.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptSparseArrays = this._exceptSparseArrays;
    file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
        var prevToken = token.getPreviousCodeToken();

        if (exceptSparseArrays &amp;&amp; prevToken.value === ',') {
            return;
        }
        errors.assert.noWhitespaceBetween({
            token: prevToken,
            nextToken: token,
            message: 'Illegal space before comma'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_comma.prototype.configure" id="apidoc.element.jscs.disallow_space_before_comma.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_comma.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    if (typeof options !== 'object') {
        assert(
            options === true,
            this.getOptionName() + ' option requires true value or an object'
        );
        var _options = {allExcept: []};
        return this.configure(_options);
    }

    assert(
        Array.isArray(options.allExcept),
        ' property `allExcept` in ' + this.getOptionName() + ' should be an array of strings'
    );
    this._exceptSparseArrays = options.allExcept.indexOf('sparseArrays') &gt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_comma.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_before_comma.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_comma.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpaceBeforeComma';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_keywords" id="apidoc.module.jscs.disallow_space_before_keywords">module jscs.disallow_space_before_keywords</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_keywords.disallow_space_before_keywords" id="apidoc.element.jscs.disallow_space_before_keywords.disallow_space_before_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_keywords.prototype" id="apidoc.module.jscs.disallow_space_before_keywords.prototype">module jscs.disallow_space_before_keywords.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_keywords.prototype.check" id="apidoc.element.jscs.disallow_space_before_keywords.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_keywords.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
        var prevToken = file.getPrevToken(token, {includeComments: true});
        if (!prevToken || prevToken.isComment) {
            return;
        }

        if (prevToken.type !== 'Keyword' &amp;&amp; prevToken.value !== ';') {
            errors.assert.noWhitespaceBetween({
                token: prevToken,
                nextToken: token,
                message: 'Illegal space before "' + token.value + '" keyword'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_keywords.prototype.configure" id="apidoc.element.jscs.disallow_space_before_keywords.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_keywords.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(
        Array.isArray(keywords) || keywords === true,
        this.getOptionName() + ' option requires array or true value');

    if (keywords === true) {
        keywords = defaultKeywords;
    }

    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_keywords.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_before_keywords.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_keywords.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpaceBeforeKeywords';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_object_values" id="apidoc.module.jscs.disallow_space_before_object_values">module jscs.disallow_space_before_object_values</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_object_values.disallow_space_before_object_values" id="apidoc.element.jscs.disallow_space_before_object_values.disallow_space_before_object_values">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_object_values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_object_values = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_object_values.prototype" id="apidoc.module.jscs.disallow_space_before_object_values.prototype">module jscs.disallow_space_before_object_values.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_object_values.prototype.check" id="apidoc.element.jscs.disallow_space_before_object_values.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_object_values.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('ObjectExpression', function(node) {
        node.properties.forEach(function(property) {
            if (property.shorthand ||
                property.type === 'ObjectMethod' ||
                property.type === 'SpreadProperty') {
                return;
            }

            var keyToken = file.getFirstNodeToken(property.key);
            var colon = file.findNextToken(keyToken, 'Punctuator', ':');

            errors.assert.noWhitespaceBetween({
                token: colon,
                nextToken: file.getNextToken(colon),
                message: 'Illegal space after key colon'
            });
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_object_values.prototype.configure" id="apidoc.element.jscs.disallow_space_before_object_values.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_object_values.prototype.</span>configure
        <span class="apidocSignatureSpan">(disallow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (disallow) {
    assert(
        disallow === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_object_values.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_before_object_values.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_object_values.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpaceBeforeObjectValues';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_postfix_unary_operators" id="apidoc.module.jscs.disallow_space_before_postfix_unary_operators">module jscs.disallow_space_before_postfix_unary_operators</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators.disallow_space_before_postfix_unary_operators" id="apidoc.element.jscs.disallow_space_before_postfix_unary_operators.disallow_space_before_postfix_unary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_postfix_unary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_postfix_unary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_postfix_unary_operators.prototype" id="apidoc.module.jscs.disallow_space_before_postfix_unary_operators.prototype">module jscs.disallow_space_before_postfix_unary_operators.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.check" id="apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_postfix_unary_operators.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operatorIndex = this._operatorIndex;

    // 'UpdateExpression' involve only ++ and -- operators
    file.iterateNodesByType('UpdateExpression', function(node) {
        // "!node.prefix" means postfix type of (inc|dec)rement
        if (!node.prefix &amp;&amp; operatorIndex[node.operator]) {
            var operatorToken = file.getLastNodeToken(node);
            errors.assert.noWhitespaceBetween({
                token: file.getPrevToken(operatorToken),
                nextToken: operatorToken,
                message: 'Operator ' + node.operator + ' should stick to operand'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.configure" id="apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_postfix_unary_operators.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + ' option requires array or true value'
    );

    if (isTrue) {
        operators = defaultOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &lt; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_before_postfix_unary_operators.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_postfix_unary_operators.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpaceBeforePostfixUnaryOperators';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_semicolon" id="apidoc.module.jscs.disallow_space_before_semicolon">module jscs.disallow_space_before_semicolon</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_semicolon.disallow_space_before_semicolon" id="apidoc.element.jscs.disallow_space_before_semicolon.disallow_space_before_semicolon">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_before_semicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_before_semicolon = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_before_semicolon.prototype" id="apidoc.module.jscs.disallow_space_before_semicolon.prototype">module jscs.disallow_space_before_semicolon.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_semicolon.prototype.check" id="apidoc.element.jscs.disallow_space_before_semicolon.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_semicolon.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateTokensByTypeAndValue('Punctuator', ';', function(token) {
        var prevToken = token.getPreviousCodeToken();

        if (!prevToken || prevToken.value in exceptions) {
            return;
        }

        errors.assert.noWhitespaceBetween({
            token: prevToken,
            nextToken: token,
            message: 'Illegal space before semicolon'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_semicolon.prototype.configure" id="apidoc.element.jscs.disallow_space_before_semicolon.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_semicolon.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var isObject = typeof value === 'object';

    var error = this.getOptionName() + ' rule requires string value true or object';

    if (isObject) {
        assert('allExcept' in value, error);
    } else {
        assert(value === true, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_before_semicolon.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_before_semicolon.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_before_semicolon.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpaceBeforeSemicolon';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_between_arguments" id="apidoc.module.jscs.disallow_space_between_arguments">module jscs.disallow_space_between_arguments</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_between_arguments.disallow_space_between_arguments" id="apidoc.element.jscs.disallow_space_between_arguments.disallow_space_between_arguments">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_space_between_arguments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_space_between_arguments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_space_between_arguments.prototype" id="apidoc.module.jscs.disallow_space_between_arguments.prototype">module jscs.disallow_space_between_arguments.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_space_between_arguments.prototype.check" id="apidoc.element.jscs.disallow_space_between_arguments.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_space_between_arguments.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(['CallExpression'], function(node) {
        node.arguments.forEach(function(param) {
            var token = file.getFirstNodeToken(param);
            var punctuatorToken = file.getPrevToken(token);

            if (punctuatorToken.value === ',') {
                errors.assert.noWhitespaceBetween({
                    token: punctuatorToken,
                    nextToken: file.getNextToken(punctuatorToken),
                    message: 'Illegal space between arguments'
                });
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_between_arguments.prototype.configure" id="apidoc.element.jscs.disallow_space_between_arguments.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_space_between_arguments.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_space_between_arguments.prototype.getOptionName" id="apidoc.element.jscs.disallow_space_between_arguments.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_space_between_arguments.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpaceBetweenArguments';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_anonymous_function_expression" id="apidoc.module.jscs.disallow_spaces_in_anonymous_function_expression">module jscs.disallow_spaces_in_anonymous_function_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.disallow_spaces_in_anonymous_function_expression" id="apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.disallow_spaces_in_anonymous_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_anonymous_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_anonymous_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_anonymous_function_expression.prototype" id="apidoc.module.jscs.disallow_spaces_in_anonymous_function_expression.prototype">module jscs.disallow_spaces_in_anonymous_function_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_anonymous_function_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType(['FunctionExpression'], function(node) {
        var functionNode = node;

        // anonymous function expressions only
        if (node.id) {
            return;
        }

        if (beforeOpeningRoundBrace) {
            var functionToken = file.getFirstNodeToken(functionNode);
            if (node.async &amp;&amp; functionToken.value === 'async') {
                functionToken = file.getNextToken(functionToken);
            }
            // if generator, set token to be * instead
            if (node.generator &amp;&amp; functionToken.value === 'function') {
                functionToken = file.getNextToken(functionToken);
            }

            errors.assert.noWhitespaceBetween({
                token: functionToken,
                nextToken: file.getNextToken(functionToken),
                message: 'Illegal space before opening round brace'
            });
        }

        if (beforeOpeningCurlyBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            errors.assert.noWhitespaceBetween({
                token: file.getPrevToken(bodyToken),
                nextToken: bodyToken,
                message: 'Illegal space before opening curly brace'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_anonymous_function_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === 'object',
        this.getOptionName() + ' option must be the object'
    );

    if ('beforeOpeningRoundBrace' in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + '.beforeOpeningRoundBrace ' +
            'property requires true value or should be removed'
        );
    }

    if ('beforeOpeningCurlyBrace' in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + '.beforeOpeningCurlyBrace ' +
            'property requires true value or should be removed'
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + ' must have beforeOpeningCurlyBrace ' +
        ' or beforeOpeningRoundBrace property'
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_anonymous_function_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_anonymous_function_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpacesInAnonymousFunctionExpression';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_call_expression" id="apidoc.module.jscs.disallow_spaces_in_call_expression">module jscs.disallow_spaces_in_call_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_call_expression.disallow_spaces_in_call_expression" id="apidoc.element.jscs.disallow_spaces_in_call_expression.disallow_spaces_in_call_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_call_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_call_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_call_expression.prototype" id="apidoc.module.jscs.disallow_spaces_in_call_expression.prototype">module jscs.disallow_spaces_in_call_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_call_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(['CallExpression', 'NewExpression'], function(node) {
        var lastCalleeToken = file.getLastNodeToken(node.callee);
        var roundBraceToken = file.findNextToken(lastCalleeToken, 'Punctuator', '(');

        // CallExpressions can't have missing parens, otherwise they're identifiers
        if (node.type === 'NewExpression') {
            if (roundBraceToken === null || roundBraceToken.parentElement !== node) {
                return;
            }
        }

        errors.assert.noWhitespaceBetween({
            token: file.getPrevToken(roundBraceToken),
            nextToken: roundBraceToken,
            message: 'Illegal space before opening round brace'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_call_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_call_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_call_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpacesInCallExpression';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_conditional_expression" id="apidoc.module.jscs.disallow_spaces_in_conditional_expression">module jscs.disallow_spaces_in_conditional_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression.disallow_spaces_in_conditional_expression" id="apidoc.element.jscs.disallow_spaces_in_conditional_expression.disallow_spaces_in_conditional_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_conditional_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_conditional_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_conditional_expression.prototype" id="apidoc.module.jscs.disallow_spaces_in_conditional_expression.prototype">module jscs.disallow_spaces_in_conditional_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_conditional_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(['ConditionalExpression'], function(node) {

        var test = node.test;
        var consequent = node.consequent;
        var consequentToken = file.getFirstNodeToken(consequent);
        var alternate = node.alternate;
        var alternateToken = file.getFirstNodeToken(alternate);
        var questionMarkToken = file.findPrevOperatorToken(consequentToken, '?');
        var colonToken = file.findPrevOperatorToken(alternateToken, ':');
        var token;

        if (this._afterTest &amp;&amp; file.isOnTheSameLine(test, questionMarkToken)) {
            token = file.getPrevToken(questionMarkToken);

            errors.assert.noWhitespaceBetween({
                token: token,
                nextToken: questionMarkToken,
                message: 'Illegal space after test'
            });
        }

        if (this._beforeConsequent &amp;&amp; file.isOnTheSameLine(questionMarkToken, consequent)) {
            token = file.getNextToken(questionMarkToken);

            errors.assert.noWhitespaceBetween({
                token: questionMarkToken,
                nextToken: token,
                message: 'Illegal space before consequent'
            });
        }

        if (this._afterConsequent &amp;&amp; file.isOnTheSameLine(consequent, colonToken)) {
            token = file.getPrevToken(colonToken);

            errors.assert.noWhitespaceBetween({
                token: token,
                nextToken: colonToken,
                message: 'Illegal space after consequent'
            });
        }

        if (this._beforeAlternate &amp;&amp; file.isOnTheSameLine(colonToken, alternate)) {
            token = file.getNextToken(colonToken);
            errors.assert.noWhitespaceBetween({
                token: colonToken,
                nextToken: token,
                message: 'Illegal space before alternate'
            });
        }
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_conditional_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var validProperties = [
        'afterTest',
        'beforeConsequent',
        'afterConsequent',
        'beforeAlternate'
    ];
    var optionName = this.getOptionName();

    if (options === true) {
        options = {
            'afterTest': true,
            'beforeConsequent': true,
            'afterConsequent': true,
            'beforeAlternate': true
        };
    }

    assert(
        typeof options === 'object',
        optionName + ' option requires a true value or an object'
    );

    var isProperlyConfigured = validProperties.some(function(key) {
        var isPresent = key in options;

        if (isPresent) {
            assert(
                options[key] === true,
                optionName + '.' + key + ' property requires true value or should be removed'
            );
        }

        return isPresent;
    });

    assert(
        isProperlyConfigured,
        optionName + ' must have at least 1 of the following properties: ' + validProperties.join(', ')
    );

    validProperties.forEach(function(property) {
        this['_' + property] = Boolean(options[property]);
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_conditional_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_conditional_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpacesInConditionalExpression';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_for_statement" id="apidoc.module.jscs.disallow_spaces_in_for_statement">module jscs.disallow_spaces_in_for_statement</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_for_statement.disallow_spaces_in_for_statement" id="apidoc.element.jscs.disallow_spaces_in_for_statement.disallow_spaces_in_for_statement">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_for_statement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_for_statement = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_for_statement.prototype" id="apidoc.module.jscs.disallow_spaces_in_for_statement.prototype">module jscs.disallow_spaces_in_for_statement.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_for_statement.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('ForStatement', function(node) {
        if (node.test) {
            var testToken = file.getFirstNodeToken(node.test);
            errors.assert.noWhitespaceBetween({
                token: file.getPrevToken(testToken),
                nextToken: testToken,
                message: 'Space found after semicolon'
            });
        }
        if (node.update) {
            var updateToken = file.getFirstNodeToken(node.update);
            errors.assert.noWhitespaceBetween({
                token: file.getPrevToken(updateToken),
                nextToken: updateToken,
                message: 'Space found after semicolon'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_for_statement.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_for_statement.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_for_statement.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpacesInForStatement';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_function" id="apidoc.module.jscs.disallow_spaces_in_function">module jscs.disallow_spaces_in_function</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function.disallow_spaces_in_function" id="apidoc.element.jscs.disallow_spaces_in_function.disallow_spaces_in_function">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_function = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_function.prototype" id="apidoc.module.jscs.disallow_spaces_in_function.prototype">module jscs.disallow_spaces_in_function.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_function.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType(['FunctionDeclaration', 'FunctionExpression'], function(node) {
        // for a named function, use node.id
        var functionNode = node.id || node;
        var parent = node.parentElement;

        // Ignore syntactic sugar for getters and setters.
        if (parent.type === 'Property' &amp;&amp; (parent.kind === 'get' || parent.kind === 'set')) {
            return;
        }

        // shorthand or constructor methods
        if (parent.method || parent.type === 'MethodDefinition') {
            functionNode = parent.key;
        }

        if (beforeOpeningRoundBrace) {
            var functionToken = file.getFirstNodeToken(functionNode);
            if (node.async &amp;&amp; functionToken.value === 'async') {
                functionToken = file.getNextToken(functionToken);
            }
            // if generator, set token to be * instead
            if (node.generator &amp;&amp; functionToken.value === 'function') {
                functionToken = file.getNextToken(functionToken);
            }
            errors.assert.noWhitespaceBetween({
                token: functionToken,
                nextToken: file.getNextToken(functionToken),
                message: 'Illegal space before opening round brace'
            });
        }

        if (beforeOpeningCurlyBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            errors.assert.noWhitespaceBetween({
                token: file.getPrevToken(bodyToken),
                nextToken: bodyToken,
                message: 'Illegal space before opening curly brace'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_function.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === 'object',
        this.getOptionName() + ' option must be the object'
    );

    if ('beforeOpeningRoundBrace' in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + '.beforeOpeningRoundBrace ' +
            'property requires true value or should be removed'
        );
    }

    if ('beforeOpeningCurlyBrace' in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + '.beforeOpeningCurlyBrace ' +
            'property requires true value or should be removed'
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + ' must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property'
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_function.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpacesInFunction';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_function_declaration" id="apidoc.module.jscs.disallow_spaces_in_function_declaration">module jscs.disallow_spaces_in_function_declaration</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_declaration.disallow_spaces_in_function_declaration" id="apidoc.element.jscs.disallow_spaces_in_function_declaration.disallow_spaces_in_function_declaration">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_declaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_function_declaration = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_function_declaration.prototype" id="apidoc.module.jscs.disallow_spaces_in_function_declaration.prototype">module jscs.disallow_spaces_in_function_declaration.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_declaration.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType(['FunctionDeclaration'], function(node) {
        // Exception for `export default function` #1376
        if (!node.id) {
            return;
        }

        if (beforeOpeningRoundBrace) {
            var functionToken = file.getFirstNodeToken(node.id);
            if (node.async &amp;&amp; functionToken.value === 'async') {
                functionToken = file.getNextToken(functionToken);
            }
            // if generator, set token to be * instead
            if (node.generator &amp;&amp; functionToken.value === 'function') {
                functionToken = file.getNextToken(functionToken);
            }
            errors.assert.noWhitespaceBetween({
                token: functionToken,
                nextToken: file.getNextToken(functionToken),
                message: 'Illegal space before opening round brace'
            });
        }

        if (beforeOpeningCurlyBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            errors.assert.noWhitespaceBetween({
                token: file.getPrevToken(bodyToken),
                nextToken: bodyToken,
                message: 'Illegal space before opening curly brace'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_declaration.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === 'object',
        this.getOptionName() + ' option must be the object'
    );

    if ('beforeOpeningRoundBrace' in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + '.beforeOpeningRoundBrace ' +
            'property requires true value or should be removed'
        );
    }

    if ('beforeOpeningCurlyBrace' in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + '.beforeOpeningCurlyBrace ' +
            'property requires true value or should be removed'
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + ' must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property'
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_function_declaration.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_declaration.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpacesInFunctionDeclaration';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_function_expression" id="apidoc.module.jscs.disallow_spaces_in_function_expression">module jscs.disallow_spaces_in_function_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_expression.disallow_spaces_in_function_expression" id="apidoc.element.jscs.disallow_spaces_in_function_expression.disallow_spaces_in_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_function_expression.prototype" id="apidoc.module.jscs.disallow_spaces_in_function_expression.prototype">module jscs.disallow_spaces_in_function_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType('FunctionExpression', function(node) {

        // for a named function, use node.id
        var functionNode = node.id || node;

        if (beforeOpeningRoundBrace) {
            var functionToken = file.getFirstNodeToken(functionNode);
            if (node.async &amp;&amp; functionToken.value === 'async') {
                functionToken = file.getNextToken(functionToken);
            }
            // if generator, set token to be * instead
            if (node.generator &amp;&amp; functionToken.value === 'function') {
                functionToken = file.getNextToken(functionToken);
            }
            errors.assert.noWhitespaceBetween({
                token: functionToken,
                nextToken: file.getNextToken(functionToken),
                message: 'Illegal space before opening round brace'
            });
        }

        if (beforeOpeningCurlyBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            errors.assert.noWhitespaceBetween({
                token: file.getPrevToken(bodyToken),
                nextToken: bodyToken,
                message: 'Illegal space before opening curly brace'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === 'object',
        this.getOptionName() + ' option must be the object'
    );

    if ('beforeOpeningRoundBrace' in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + '.beforeOpeningRoundBrace ' +
            'property requires true value or should be removed'
        );
    }

    if ('beforeOpeningCurlyBrace' in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + '.beforeOpeningCurlyBrace ' +
            'property requires true value or should be removed'
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + ' must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property'
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_function_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_function_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpacesInFunctionExpression';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_generator" id="apidoc.module.jscs.disallow_spaces_in_generator">module jscs.disallow_spaces_in_generator</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_generator.disallow_spaces_in_generator" id="apidoc.element.jscs.disallow_spaces_in_generator.disallow_spaces_in_generator">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_generator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_generator = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_generator.prototype" id="apidoc.module.jscs.disallow_spaces_in_generator.prototype">module jscs.disallow_spaces_in_generator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_generator.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_generator.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_generator.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeStar = this._beforeStar;
    var afterStar = this._afterStar;

    file.iterateNodesByType(['FunctionDeclaration', 'FunctionExpression'], function(node) {
        if (!node.generator) {
            return;
        }

        var parent = node.parentElement;
        var shorthand = node.shorthand;

        // shorthand or constructor methods
        if (parent.method || parent.type === 'MethodDefinition') {
            node = parent.key;
        }

        var currentToken = file.getFirstNodeToken(node);

        if (node.async &amp;&amp; currentToken.value === 'async') {
            currentToken = file.getNextToken(currentToken);
        }

        if (beforeStar &amp;&amp; !shorthand) {
            // currentToken assigned outside of function
            errors.assert.noWhitespaceBetween({
                token: currentToken,
                nextToken: file.getNextToken(currentToken),
                message: 'Illegal space before star'
            });
        }

        if (afterStar) {
            if (shorthand) {
                currentToken = file.getPrevToken(currentToken);
            } else {
                // currentToken reassigned for star token
                currentToken = file.getNextToken(currentToken);
            }

            errors.assert.noWhitespaceBetween({
                token: currentToken,
                nextToken: file.getNextToken(currentToken),
                message: 'Illegal space after star'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_generator.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_generator.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_generator.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === 'object',
        this.getOptionName() + ' option must be an object'
    );

    if ('beforeStar' in options) {
        assert(
            options.beforeStar === true,
            this.getOptionName() + '.beforeStar ' +
            'property requires true value or should be removed'
        );
    }
    if ('afterStar' in options) {
        assert(
            options.afterStar === true,
            this.getOptionName() + '.afterStar ' +
            'property requires true value or should be removed'
        );
    }

    assert(
        options.beforeStar || options.afterStar,
        this.getOptionName() + ' must have beforeStar or afterStar property'
    );

    this._beforeStar = options.beforeStar;
    this._afterStar = options.afterStar;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_generator.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_generator.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_generator.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpacesInGenerator';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_named_function_expression" id="apidoc.module.jscs.disallow_spaces_in_named_function_expression">module jscs.disallow_spaces_in_named_function_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression.disallow_spaces_in_named_function_expression" id="apidoc.element.jscs.disallow_spaces_in_named_function_expression.disallow_spaces_in_named_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_in_named_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_in_named_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_in_named_function_expression.prototype" id="apidoc.module.jscs.disallow_spaces_in_named_function_expression.prototype">module jscs.disallow_spaces_in_named_function_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.check" id="apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_named_function_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType(['FunctionExpression'], function(node) {
        var functionNode = node.id;
        var parent = node.parentElement;

        // Ignore syntactic sugar for getters and setters.
        if (parent.type === 'Property' &amp;&amp; (parent.kind === 'get' || parent.kind === 'set')) {
            return;
        }

        // shorthand or constructor methods
        if (parent.method || parent.type === 'MethodDefinition') {
            functionNode = parent.key;
        }

        // named function expressions only
        if (node.id) {
            if (beforeOpeningRoundBrace) {
                var functionToken = file.getFirstNodeToken(functionNode);
                if (node.async &amp;&amp; functionToken.value === 'async') {
                    functionToken = file.getNextToken(functionToken);
                }
                errors.assert.noWhitespaceBetween({
                    token: functionToken,
                    nextToken: file.getNextToken(functionToken),
                    message: 'Illegal space before opening round brace'
                });
            }

            if (beforeOpeningCurlyBrace) {
                var bodyToken = file.getFirstNodeToken(node.body);
                errors.assert.noWhitespaceBetween({
                    token: file.getPrevToken(bodyToken),
                    nextToken: bodyToken,
                    message: 'Illegal space before opening curly brace'
                });
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.configure" id="apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_named_function_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === 'object',
        this.getOptionName() + ' option must be the object'
    );

    if ('beforeOpeningRoundBrace' in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + '.beforeOpeningRoundBrace ' +
            'property requires true value or should be removed'
        );
    }

    if ('beforeOpeningCurlyBrace' in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + '.beforeOpeningCurlyBrace ' +
            'property requires true value or should be removed'
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + ' must have beforeOpeningCurlyBrace ' +
        'or beforeOpeningRoundBrace property'
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_in_named_function_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_in_named_function_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpacesInNamedFunctionExpression';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_array_brackets" id="apidoc.module.jscs.disallow_spaces_inside_array_brackets">module jscs.disallow_spaces_inside_array_brackets</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets.disallow_spaces_inside_array_brackets" id="apidoc.element.jscs.disallow_spaces_inside_array_brackets.disallow_spaces_inside_array_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_array_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_array_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_array_brackets.prototype" id="apidoc.module.jscs.disallow_spaces_inside_array_brackets.prototype">module jscs.disallow_spaces_inside_array_brackets.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.check" id="apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_array_brackets.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateNodesByType('ArrayExpression', function(node) {
        var openBracket = node.getFirstToken();
        var afterOpen = file.getNextToken(openBracket, {includeComments: true});
        var closeBracket = file.getLastNodeToken(node);
        var beforeClose = file.getPrevToken(closeBracket, {includeComments: true});

        // Skip for empty array brackets
        if (afterOpen.value === ']') {
            return;
        }

        if (!(afterOpen.value in exceptions)) {
            errors.assert.noWhitespaceBetween({
                token: openBracket,
                nextToken: afterOpen,
                message: 'Illegal space after opening bracket'
            });
        }

        if (!(beforeClose.value in exceptions)) {
            errors.assert.noWhitespaceBetween({
                token: beforeClose,
                nextToken: closeBracket,
                message: 'Illegal space before closing bracket'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.configure" id="apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_array_brackets.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var mode;
    var modes = {
        'all': true,
        'nested': true
    };
    var isObject = typeof value === 'object';

    var error = this.getOptionName() + ' rule' +
    ' requires string value "all" or "nested" or object';

    if (typeof value === 'string' || value === true) {
        assert(modes[value === true ? 'all' : value], error);

    } else if (isObject) {
        assert('allExcept' in value, error);
    } else {
        assert(false, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);

    } else {
        mode = value;
    }

    if (mode === 'nested') {
        this._exceptions['['] = this._exceptions[']'] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_inside_array_brackets.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_array_brackets.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpacesInsideArrayBrackets';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_brackets" id="apidoc.module.jscs.disallow_spaces_inside_brackets">module jscs.disallow_spaces_inside_brackets</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_brackets.disallow_spaces_inside_brackets" id="apidoc.element.jscs.disallow_spaces_inside_brackets.disallow_spaces_inside_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_brackets.prototype" id="apidoc.module.jscs.disallow_spaces_inside_brackets.prototype">module jscs.disallow_spaces_inside_brackets.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.check" id="apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_brackets.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateTokensByTypeAndValue('Punctuator', '[', function(token) {
        var nextToken = file.getNextToken(token, { includeComments: true });
        var value = nextToken.getSourceCode();

        if (value in exceptions) {
            return;
        }

        // Skip for empty array brackets
        if (value === ']') {
            return;
        }

        errors.assert.noWhitespaceBetween({
            token: token,
            nextToken: nextToken,
            message: 'Illegal space after opening bracket'
        });
    });

    file.iterateTokensByTypeAndValue('Punctuator', ']', function(token) {
        var prevToken = file.getPrevToken(token, { includeComments: true });
        var value = prevToken.getSourceCode();

        if (value in exceptions) {
            return;
        }

        // Skip for empty array brackets
        if (value === '[') {
            return;
        }

        errors.assert.noWhitespaceBetween({
            token: prevToken,
            nextToken: token,
            message: 'Illegal space before closing bracket'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.configure" id="apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_brackets.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var isObject = typeof value === 'object';

    var error = this.getOptionName() + ' rule requires string value true or object';

    if (isObject) {
        assert('allExcept' in value, error);
    } else {
        assert(value === true, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_inside_brackets.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_brackets.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpacesInsideBrackets';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_imported_object_braces" id="apidoc.module.jscs.disallow_spaces_inside_imported_object_braces">module jscs.disallow_spaces_inside_imported_object_braces</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.disallow_spaces_inside_imported_object_braces" id="apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.disallow_spaces_inside_imported_object_braces">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_imported_object_braces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_imported_object_braces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_imported_object_braces.prototype" id="apidoc.module.jscs.disallow_spaces_inside_imported_object_braces.prototype">module jscs.disallow_spaces_inside_imported_object_braces.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.check" id="apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_imported_object_braces.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(['ImportDeclaration'], function(node) {

        if (!node.specifiers) {
            return;
        }

        node.specifiers.forEach(function(specifier) {

            if (specifier.type !== 'ImportSpecifier') {
                return;
            }

            var maybeOpeningBrace = file.getPrevToken(specifier.getFirstToken());
            var maybeClosingBrace = file.getNextToken(specifier.getLastToken());

            if (maybeOpeningBrace.value === '{') {
                errors.assert.noWhitespaceBetween({
                    token: maybeOpeningBrace,
                    nextToken: specifier.getFirstToken(),
                    message: 'Illegal space after opening curly brace'
                });
            }

            if (maybeClosingBrace.value === '}') {
                errors.assert.noWhitespaceBetween({
                    token: specifier.getLastToken(),
                    nextToken: maybeClosingBrace,
                    message: 'Illegal space before closing curly brace'
                });
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.configure" id="apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_imported_object_braces.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_inside_imported_object_braces.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_imported_object_braces.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpacesInsideImportedObjectBraces';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_object_brackets" id="apidoc.module.jscs.disallow_spaces_inside_object_brackets">module jscs.disallow_spaces_inside_object_brackets</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets.disallow_spaces_inside_object_brackets" id="apidoc.element.jscs.disallow_spaces_inside_object_brackets.disallow_spaces_inside_object_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_object_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_object_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_object_brackets.prototype" id="apidoc.module.jscs.disallow_spaces_inside_object_brackets.prototype">module jscs.disallow_spaces_inside_object_brackets.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.check" id="apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_object_brackets.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateNodesByType(['ObjectExpression', 'ObjectPattern'], function(node) {
        var openingBracket = node.getFirstToken();
        var nextToken = file.getNextToken(openingBracket);

        errors.assert.noWhitespaceBetween({
            token: openingBracket,
            nextToken: nextToken,
            message: 'Illegal space after opening curly brace'
        });

        var closingBracket = file.getLastNodeToken(node);
        var prevToken = file.getPrevToken(closingBracket);

        if (prevToken.value in exceptions) {
            return;
        }

        errors.assert.noWhitespaceBetween({
            token: prevToken,
            nextToken: closingBracket,
            message: 'Illegal space before closing curly brace'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.configure" id="apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_object_brackets.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var mode;
    var modes = {
        'all': true,
        'nested': true
    };
    var isObject = typeof value === 'object';

    var error = this.getOptionName() + ' rule' +
    ' requires string "all" or "nested", true value or object';

    if (typeof value === 'string' || value === true) {
        assert(modes[value === true ? 'all' : value], error);

    } else if (isObject) {
        assert('allExcept' in value, error);
    } else {
        assert(false, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);

    } else {
        mode = value;
    }

    if (mode === 'nested') {
        this._exceptions['}'] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_inside_object_brackets.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_object_brackets.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpacesInsideObjectBrackets';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_parentheses" id="apidoc.module.jscs.disallow_spaces_inside_parentheses">module jscs.disallow_spaces_inside_parentheses</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parentheses.disallow_spaces_inside_parentheses" id="apidoc.element.jscs.disallow_spaces_inside_parentheses.disallow_spaces_inside_parentheses">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parentheses
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_parentheses = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_parentheses.prototype" id="apidoc.module.jscs.disallow_spaces_inside_parentheses.prototype">module jscs.disallow_spaces_inside_parentheses.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.check" id="apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parentheses.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var only = this._only;
    var singleQuote = this._onlySingleQuote;
    var doubleQuote = this._onlyDoubleQuote;
    var alreadyAdded = [];

    file.iterateTokensByTypeAndValue('Punctuator', '(', function(token) {
        var nextToken = file.getNextToken(token, {includeComments: true});
        var value = nextToken.getSourceCode();
        var shouldReturn = true;

        if (doubleQuote &amp;&amp; nextToken.type === 'String' &amp;&amp; value[0] === '"') {
            shouldReturn = false;
        }

        if (singleQuote &amp;&amp; nextToken.type === 'String' &amp;&amp; value[0] === '\'') {
            shouldReturn = false;
        }

        if (only &amp;&amp; value in only) {
            shouldReturn = false;
        }

        if (!only) {
            shouldReturn = false;
        }

        if (shouldReturn) {
            return;
        }

        var isAdded = errors.assert.noWhitespaceBetween({
            token: token,
            nextToken: nextToken,
            message: 'Illegal space after opening round bracket'
        });

        if (isAdded) {
            alreadyAdded.push(token);
        }
    });

    file.iterateTokensByTypeAndValue('Punctuator', ')', function(token) {
        var prevToken = file.getPrevToken(token, {includeComments: true});
        var value = prevToken.getSourceCode();
        var shouldReturn = true;

        // Do not check already found errors, like "function ( ) { ..."
        if (alreadyAdded.indexOf(prevToken) &gt; -1) {
            return;
        }

        if (doubleQuote &amp;&amp; prevToken.type === 'String' &amp;&amp; value[value.length - 1] === '"') {
            shouldReturn = false;
        }

        if (singleQuote &amp;&amp; prevToken.type === 'String' &amp;&amp; value[value.length - 1] === '\'') {
            shouldReturn = false;
        }

        if (only) {
            if (value in only) {
                shouldReturn = false;
            }

            if (
                value === ']' &amp;&amp;
                prevToken.parentElement.type === 'MemberExpression'
            ) {
                shouldReturn = true;
            }
        } else {
            shouldReturn = false;
        }

        if (shouldReturn) {
            return;
        }

        errors.assert.noWhitespaceBetween({
            token: prevToken,
            nextToken: token,
            message: 'Illegal space before closing round bracket'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.configure" id="apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parentheses.prototype.</span>configure
        <span class="apidocSignatureSpan">(option)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (option) {
    var isObject = typeof option === 'object';

    var error = this.getOptionName() + ' option requires' +
        ' true or object value with "only" properties ';

    // backcompat for 1.10: {all: true} #1027
    if (isObject &amp;&amp; option.all === true) {
        option = true;
    }

    if (typeof option === 'boolean') {
        assert(option === true, error);
    } else if (isObject) {
        assert('only' in option, error);
    } else {
        assert(false, error);
    }

    this._onlySingleQuote = false;
    this._onlyDoubleQuote = false;
    this._only = null;

    if (option.only) {
        this._only = {};

        (option.only).forEach(function(value) {
            if (value === '\'') {
                this._onlySingleQuote = true;
            }

            if (value === '"') {
                this._onlyDoubleQuote = true;
            }

            this._only[value] = true;
        }, this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_inside_parentheses.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parentheses.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpacesInsideParentheses';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_parenthesized_expression" id="apidoc.module.jscs.disallow_spaces_inside_parenthesized_expression">module jscs.disallow_spaces_inside_parenthesized_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.disallow_spaces_inside_parenthesized_expression" id="apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.disallow_spaces_inside_parenthesized_expression">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_parenthesized_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_parenthesized_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_parenthesized_expression.prototype" id="apidoc.module.jscs.disallow_spaces_inside_parenthesized_expression.prototype">module jscs.disallow_spaces_inside_parenthesized_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.check" id="apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parenthesized_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateTokensByTypeAndValue('Punctuator', '(', function(token) {
        var nextToken = file.getNextToken(token, {includeComments: true});
        var value = nextToken.isComment ?
            nextToken.type === 'CommentBlock' ? '/*' : '//' :
            nextToken.value;

        // Skip empty parentheses and explicit exceptions
        if (value === ')' || value in exceptions) {
            return;
        }

        // Skip non-expression parentheses
        var type = TokenCategorizer.categorizeOpenParen(token);
        if (type !== 'ParenthesizedExpression') {
            return;
        }

        errors.assert.noWhitespaceBetween({
            token: token,
            nextToken: nextToken,
            message: 'Illegal space after opening grouping parenthesis'
        });
    });

    file.iterateTokensByTypeAndValue('Punctuator', ')', function(token) {
        var prevToken = file.getPrevToken(token, {includeComments: true});
        var value = prevToken.isComment ?
            prevToken.type === 'CommentBlock' ? '*/' : '' :
            prevToken.value;

        // Skip empty parentheses and explicit exceptions
        if (value === '(' || value in exceptions) {
            return;
        }

        // Skip non-expression parentheses
        var type = TokenCategorizer.categorizeCloseParen(token);
        if (type !== 'ParenthesizedExpression') {
            return;
        }

        errors.assert.noWhitespaceBetween({
            token: prevToken,
            nextToken: token,
            message: 'Illegal space before closing grouping parenthesis'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.configure" id="apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parenthesized_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var isObject = typeof value === 'object';

    var error = this.getOptionName() + ' rule requires string value true or object';

    if (isObject) {
        assert('allExcept' in value, error);
    } else {
        assert(value === true, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_inside_parenthesized_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_parenthesized_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpacesInsideParenthesizedExpression';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_template_string_placeholders" id="apidoc.module.jscs.disallow_spaces_inside_template_string_placeholders">module jscs.disallow_spaces_inside_template_string_placeholders</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.disallow_spaces_inside_template_string_placeholders" id="apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.disallow_spaces_inside_template_string_placeholders">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_spaces_inside_template_string_placeholders
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_spaces_inside_template_string_placeholders = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_spaces_inside_template_string_placeholders.prototype" id="apidoc.module.jscs.disallow_spaces_inside_template_string_placeholders.prototype">module jscs.disallow_spaces_inside_template_string_placeholders.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.check" id="apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_template_string_placeholders.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('TemplateLiteral', function(node) {
        node.childElements
            .filter(function(element) {
                return element.isToken &amp;&amp; element.type === 'Punctuator';
            })
            .forEach(function(element) {
                if (element.value === '${' &amp;&amp; element.nextSibling.isWhitespace) {
                    errors.assert.noWhitespaceBetween({
                        token: element,
                        nextToken: element.getNextCodeToken(),
                        message: 'Illegal space after "${"'
                    });
                }
                if (element.value === '}' &amp;&amp; element.previousSibling.isWhitespace) {
                    errors.assert.noWhitespaceBetween({
                        token: element.getPreviousCodeToken(),
                        nextToken: element,
                        message: 'Illegal space before "}"'
                    });
                }
            });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.configure" id="apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_template_string_placeholders.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.getOptionName" id="apidoc.element.jscs.disallow_spaces_inside_template_string_placeholders.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_spaces_inside_template_string_placeholders.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowSpacesInsideTemplateStringPlaceholders';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_tabs" id="apidoc.module.jscs.disallow_tabs">module jscs.disallow_tabs</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_tabs.disallow_tabs" id="apidoc.element.jscs.disallow_tabs.disallow_tabs">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_tabs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_tabs = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_tabs.prototype" id="apidoc.module.jscs.disallow_tabs.prototype">module jscs.disallow_tabs.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_tabs.prototype.check" id="apidoc.element.jscs.disallow_tabs.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_tabs.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByType('Whitespace', function(whitespace) {
        var match = whitespace.value.match(/\t/);
        if (match) {
            errors.add('Tab found', whitespace, match.index);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_tabs.prototype.configure" id="apidoc.element.jscs.disallow_tabs.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_tabs.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_tabs.prototype.getOptionName" id="apidoc.element.jscs.disallow_tabs.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_tabs.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowTabs';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_trailing_comma" id="apidoc.module.jscs.disallow_trailing_comma">module jscs.disallow_trailing_comma</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_comma.disallow_trailing_comma" id="apidoc.element.jscs.disallow_trailing_comma.disallow_trailing_comma">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_trailing_comma = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_trailing_comma.prototype" id="apidoc.module.jscs.disallow_trailing_comma.prototype">module jscs.disallow_trailing_comma.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_comma.prototype._fix" id="apidoc.element.jscs.disallow_trailing_comma.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.disallow_trailing_comma.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    error.element.remove();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &amp;&amp; instance._fix) {
        // "error.fixed = true" should go first, so rule can
        // decide for itself (with "error.fixed = false")
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_comma.prototype.check" id="apidoc.element.jscs.disallow_trailing_comma.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_trailing_comma.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType([
        'ObjectExpression', 'ArrayExpression',
        'ObjectPattern', 'ArrayPattern'
    ], function(node) {
        var closingToken = file.getLastNodeToken(node);
        var comma = closingToken.getPreviousCodeToken();

        if (comma.type === 'Punctuator' &amp;&amp; comma.value === ',') {
            errors.add(
                'Extra comma following the final element of an array or object literal',
                comma
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_comma.prototype.configure" id="apidoc.element.jscs.disallow_trailing_comma.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_trailing_comma.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_comma.prototype.getOptionName" id="apidoc.element.jscs.disallow_trailing_comma.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_trailing_comma.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowTrailingComma';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_trailing_whitespace" id="apidoc.module.jscs.disallow_trailing_whitespace">module jscs.disallow_trailing_whitespace</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_whitespace.disallow_trailing_whitespace" id="apidoc.element.jscs.disallow_trailing_whitespace.disallow_trailing_whitespace">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_trailing_whitespace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_trailing_whitespace = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_trailing_whitespace.prototype" id="apidoc.module.jscs.disallow_trailing_whitespace.prototype">module jscs.disallow_trailing_whitespace.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_whitespace.prototype._fix" id="apidoc.element.jscs.disallow_trailing_whitespace.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.disallow_trailing_whitespace.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var element = error.element;
    var newValue;
    var lines = element.getValueLineInfo();
    var line = lines[error.additional.lineNumber];
    if (element.isWhitespace) {
        line.text = '';
    }
    if (element.isComment) {
        line.text = line.text.replace(/\s+$/, '');
    }

    newValue = lines.map(function(line) {
        return line.text + (line.lineBreak || '');
    }).join('');

    var newElement = new Token(element.type, newValue);
    element.parentElement.replaceChild(newElement, element);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &amp;&amp; instance._fix) {
        // "error.fixed = true" should go first, so rule can
        // decide for itself (with "error.fixed = false")
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_whitespace.prototype.check" id="apidoc.element.jscs.disallow_trailing_whitespace.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_trailing_whitespace.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var program = file.getProgram();

    if (!program) {
        return;
    }

    var lastToken = program.getLastToken();
    if (lastToken &amp;&amp; lastToken.type === 'EOF') {
        lastToken = lastToken.getPreviousToken();
    }
    program.selectTokensByType('Whitespace').forEach(function(whitespace) {
        whitespace.getValueLineInfo().some(function(line, i) {
            if (this._ignoreEmptyLines &amp;&amp; i &gt; 0) {
                return true;
            }
            if (line.text &amp;&amp; (line.lineBreak || whitespace === lastToken)) {
                errors.cast({
                    message: 'Illegal trailing whitespace',
                    element: whitespace,
                    offset: line.offset,
                    additional: {
                        lineNumber: i
                    }
                });
            }
        }, this);
    }, this);
    program.selectTokensByType('CommentBlock').concat(program.selectTokensByType('CommentLine'))
        .forEach(function(comment) {
            var lines = comment.getValueLineInfo();
            lines.forEach(function(line, i) {
                if (i &gt; 0 &amp;&amp; this._ignoreEmptyLines &amp;&amp; line.text.trim() === '') {
                    return;
                }
                if (comment.type === 'CommentBlock' &amp;&amp; i === lines.length - 1) {
                    return;
                }
                if (line.text.match(/\s$/)) {
                    errors.cast({
                        message: 'Illegal trailing comment',
                        element: comment,
                        offset: line.offset,
                        additional: {
                            lineNumber: i
                        }
                    });
                }
            }, this);
        }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_whitespace.prototype.configure" id="apidoc.element.jscs.disallow_trailing_whitespace.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_trailing_whitespace.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || options === 'ignoreEmptyLines',
        this.getOptionName() + ' option requires a true value or "ignoreEmptyLines"'
    );
    this._ignoreEmptyLines = options === 'ignoreEmptyLines';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_trailing_whitespace.prototype.getOptionName" id="apidoc.element.jscs.disallow_trailing_whitespace.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_trailing_whitespace.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowTrailingWhitespace';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_unused_params" id="apidoc.module.jscs.disallow_unused_params">module jscs.disallow_unused_params</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_params.disallow_unused_params" id="apidoc.element.jscs.disallow_unused_params.disallow_unused_params">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_unused_params
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_unused_params = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_unused_params.prototype" id="apidoc.module.jscs.disallow_unused_params.prototype">module jscs.disallow_unused_params.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_params.prototype._fix" id="apidoc.element.jscs.disallow_unused_params.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.disallow_unused_params.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var node = error.element;

    var parentElement = node.parentElement;
    if (!parentElement) {
        return;
    }

    if (
        parentElement.type === 'FunctionExpression' ||
        parentElement.type === 'FunctionDeclaration' ||
        parentElement.type === 'ArrowFunctionExpression'
    ) {
        removeWithCommaIfNecessary(node, false);
        return;
    }

    if (parentElement.type === 'ObjectProperty') {
        removeWithCommaIfNecessary(parentElement, true);
        return;
    }

    if (parentElement.type === 'ArrayPattern') {
        removeWithCommaIfNecessary(node, false);
        if (
            parentElement.elements.length &gt; 0 &amp;&amp;
            parentElement.elements.every(function(element) {
                return !element;
            })
        ) {
            parentElement.removeChildren(
                parentElement.firstChild.nextSibling,
                parentElement.lastChild.previousSibling
            );
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &amp;&amp; instance._fix) {
        // "error.fixed = true" should go first, so rule can
        // decide for itself (with "error.fixed = false")
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_params.prototype.check" id="apidoc.element.jscs.disallow_unused_params.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_unused_params.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {

    function reportError(node) {
        if (node.type === 'Identifier') {
            errors.add('Param `' + node.name + '` is not used', node);
        } else {
            errors.add('Pattern is not used', node);
        }
    }

    file.iterateNodesByType(
        ['FunctionDeclaration', 'FunctionExpression', 'ArrowFunctionExpression'],
        function(node) {
            var variableMap = file.getScopes().acquire(node).getVariables()
                .filter(function(variable) {
                    return variable.type === 'Parameter';
                })
                .reduce(function(obj, variable) {
                    obj[variable.name] = variable;
                    return obj;
                }, {});

            var params = node.params;
            var reportUnusedDirectParams = true;

            for (var i = params.length - 1; i &gt;= 0; i--) {
                var param = params[i];

                if (!reportUnusedDirectParams &amp;&amp; param.type === 'Identifier') {
                    continue;
                }

                var unusedNodes = getUnusedNodes(param, variableMap, reportUnusedDirectParams);

                unusedNodes.forEach(reportError);

                if (unusedNodes.length !== 1 || unusedNodes[0] !== param) {
                    reportUnusedDirectParams = false;
                }
            }
        }
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_params.prototype.configure" id="apidoc.element.jscs.disallow_unused_params.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_unused_params.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_params.prototype.getOptionName" id="apidoc.element.jscs.disallow_unused_params.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_unused_params.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowUnusedParams';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_unused_variables" id="apidoc.module.jscs.disallow_unused_variables">module jscs.disallow_unused_variables</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_variables.disallow_unused_variables" id="apidoc.element.jscs.disallow_unused_variables.disallow_unused_variables">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_unused_variables
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_unused_variables = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_unused_variables.prototype" id="apidoc.module.jscs.disallow_unused_variables.prototype">module jscs.disallow_unused_variables.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_variables.prototype._fix" id="apidoc.element.jscs.disallow_unused_variables.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.disallow_unused_variables.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var node = error.element;

    while (node.type !== 'VariableDeclaration') {
        node = node.parentElement;
    }

    node.parentElement.removeChild(node);
    error.fixed = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &amp;&amp; instance._fix) {
        // "error.fixed = true" should go first, so rule can
        // decide for itself (with "error.fixed = false")
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_variables.prototype.check" id="apidoc.element.jscs.disallow_unused_variables.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_unused_variables.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var program = file.getProgram();
    var variableList = [];
    var nodesToCheck = [];
    var unusedNodes = [];

    function reportError(node) {
        errors.add('Variable `' + node.name + '` is not used', node);
    }

    function isVariableGood(variable) {
        var parentCheck = function(node) {
            if (node.parentElement) {
                if (node.parentElement.type === 'VariableDeclaration') {
                    var grandparentElement = node.parentElement.parentElement;

                    return grandparentElement.type !== 'ExportNamedDeclaration';
                } else if (
                    node.parentElement.type === 'VariableDeclarator' ||
                    node.parentElement.type === 'ObjectProperty' ||
                    node.parentElement.isPattern
                ) {
                    return parentCheck(node.parentElement);
                }
            } else {
                return false;
            }
        };

        var useVariable = variable.getDefinitions().some(function checkVariableDefinition(definition) {
            return parentCheck(definition.node);
        });

        return useVariable;
    }

    function getVariablesInAllScopes(scope) {
        var variableList = [];

        var iterateChildScopes = function(scope) {
            scope.getVariables().forEach(function(variable) {
                variableList.push(variable);
            });

            scope.childScopes.forEach(function(childScope) {
                return iterateChildScopes(childScope);
            });
        };

        iterateChildScopes(scope);

        return variableList;
    }

    // Get all variables in all scopes.
    variableList = getVariablesInAllScopes(file.getScopes().acquire(program));

    // Check if variables are what we want to check..
    variableList.reduce(function(acc, variable) {
        if (isVariableGood(variable)) {
            acc.push(variable);
        }

        return acc;
    }, nodesToCheck);

    // Check if variables are used.
    nodesToCheck.reduce(function checkVariableReferences(acc, variable) {
        if (variable.getReferences().length === 1) {
            variable.getDefinitions().forEach(function addUnusedVariable(definition) {
                acc.push(definition.node);
            });
        }

        return acc;
    }, unusedNodes);

    unusedNodes.forEach(reportError);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_variables.prototype.configure" id="apidoc.element.jscs.disallow_unused_variables.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_unused_variables.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_unused_variables.prototype.getOptionName" id="apidoc.element.jscs.disallow_unused_variables.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_unused_variables.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowUnusedVariables';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_var" id="apidoc.module.jscs.disallow_var">module jscs.disallow_var</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_var.disallow_var" id="apidoc.element.jscs.disallow_var.disallow_var">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_var
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_var = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_var.prototype" id="apidoc.module.jscs.disallow_var.prototype">module jscs.disallow_var.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_var.prototype.check" id="apidoc.element.jscs.disallow_var.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_var.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('VariableDeclaration', function(node) {
        for (var i = 0; i &lt; node.declarations.length; i++) {
            var thisDeclaration = node.declarations[i];

            if (thisDeclaration.parentElement.kind === 'var') {
                errors.add('Variable declarations should use `let` or `const` not `var`', node);
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_var.prototype.configure" id="apidoc.element.jscs.disallow_var.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_var.prototype.</span>configure
        <span class="apidocSignatureSpan">(option)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (option) {
    assert(option === true, this.getOptionName() + ' requires a true value');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_var.prototype.getOptionName" id="apidoc.element.jscs.disallow_var.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_var.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowVar';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_yoda_conditions" id="apidoc.module.jscs.disallow_yoda_conditions">module jscs.disallow_yoda_conditions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_yoda_conditions.disallow_yoda_conditions" id="apidoc.element.jscs.disallow_yoda_conditions.disallow_yoda_conditions">
        function <span class="apidocSignatureSpan">jscs.</span>disallow_yoda_conditions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disallow_yoda_conditions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.disallow_yoda_conditions.prototype" id="apidoc.module.jscs.disallow_yoda_conditions.prototype">module jscs.disallow_yoda_conditions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.disallow_yoda_conditions.prototype.check" id="apidoc.element.jscs.disallow_yoda_conditions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.disallow_yoda_conditions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operators = this._operatorIndex;
    file.iterateNodesByType('BinaryExpression', function(node) {
        if (operators[node.operator]) {
            if (
                node.left.type.indexOf('Literal') &gt; -1 ||
                (node.left.type === 'Identifier' &amp;&amp; node.left.name === 'undefined')
            ) {
                errors.add('Yoda condition', node.left);
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_yoda_conditions.prototype.configure" id="apidoc.element.jscs.disallow_yoda_conditions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.disallow_yoda_conditions.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + ' option requires array or true value'
    );

    if (isTrue) {
        operators = ['==', '===', '!=', '!=='];
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &lt; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.disallow_yoda_conditions.prototype.getOptionName" id="apidoc.element.jscs.disallow_yoda_conditions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.disallow_yoda_conditions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'disallowYodaConditions';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.errors" id="apidoc.module.jscs.errors">module jscs.errors</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.errors.errors" id="apidoc.element.jscs.errors.errors">
        function <span class="apidocSignatureSpan">jscs.</span>errors
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errors = function (file) {
    this._errorList = [];
    this._file = file;
    this._currentRule = '';

<span class="apidocCodeCommentSpan">    /**
     * @type {TokenAssert}
     * @public
     */
</span>    this.assert = new TokenAssert(file);
    this.assert.on('error', this._addError.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.getPosition" id="apidoc.element.jscs.errors.getPosition">
        function <span class="apidocSignatureSpan">jscs.errors.</span>getPosition
        <span class="apidocSignatureSpan">(error, tokenIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPosition = function (error, tokenIndex) {
    var element = error.element;
    var offset = error.offset;
    var rule = error.rule;

    if (!element) {
        return EMPTY_POS;
    }

    if (offset === undefined) {
        // TODO: probably should be generalized
        if (rule === 'validateQuoteMarks') {
            offset = 0;
        } else if (element.getSourceCodeLength() === 1) {
            offset = 0;
        } else {
            offset = (element.getNewlineCount() === 0 &amp;&amp; Math.ceil(element.getSourceCodeLength() / 2)) || 0;
        }
    }

    var pos = tokenIndex ? tokenIndex.getElementLoc(element) : element.getLoc().start;
    if (!pos) {
        return EMPTY_POS;
    }

    if (offset === 0) {
        return pos;
    }

    var newlineCount = element.getNewlineCount();
    if (newlineCount &gt; 0) {
        var code = element.getSourceCode();
        LINE_SEPARATOR.lastIndex = 0;
        var lineOffset = 0;
        var match;
        var previousOffset = 0;
        var firstLineColumnOffset = pos.column;
        while ((match = LINE_SEPARATOR.exec(code)) !== null) {
            var currentOffset = match.index;
            if (offset &lt;= currentOffset) {
                return {
                    line: pos.line + lineOffset,
                    column: firstLineColumnOffset + offset - previousOffset
                };
            }
            previousOffset = currentOffset + match[0].length;
            firstLineColumnOffset = 0;
            lineOffset++;
        }
        return {
            line: pos.line + newlineCount,
            column: offset - previousOffset
        };
    } else {
        return {
            line: pos.line,
            column: pos.column + offset
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

/**
 * @param {TokenIndex} tokenIndex
 */
calculateErrorLocations: function(tokenIndex) {
    this._errorList.forEach(function(error) {
        var pos = Errors.<span class="apidocCodeKeywordSpan">getPosition</span>(error, tokenIndex);
        error.line = pos.line;
        error.column = pos.column;
    });
},

/**
 * Formats error for further output.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.errors.prototype" id="apidoc.module.jscs.errors.prototype">module jscs.errors.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.errors.prototype._addError" id="apidoc.element.jscs.errors.prototype._addError">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>_addError
        <span class="apidocSignatureSpan">(errorInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addError = function (errorInfo) {
    this._errorList.push({
        filename: this._file.getFilename(),
        rule: this._currentRule,
        message: this._prepareMessage(errorInfo),
        element: errorInfo.element,
        offset: errorInfo.offset,
        additional: errorInfo.additional,
        fixed: false,
        fix: errorInfo.fix
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
add: function(message, element, offset) {
    if (message instanceof Error) {
        this._addParseError(message);
        return;
    }

    this.<span class="apidocCodeKeywordSpan">_addError</span>({
        message: message,
        element: element,
        offset: offset
    });
},

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype._addParseError" id="apidoc.element.jscs.errors.prototype._addParseError">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>_addParseError
        <span class="apidocSignatureSpan">(errorInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addParseError = function (errorInfo) {
    this._errorList.push({
        filename: this._file.getFilename(),
        rule: 'parseError',
        message: errorInfo.message,
        line: errorInfo.loc ? errorInfo.loc.line : 1,
        column: errorInfo.loc ? errorInfo.loc.column : 0
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     *
     * @param {String | Error} message
     * @param {cst.types.Element} element
     * @param {Number} [offset] relative offset
     */
    add: function(message, element, offset) {
if (message instanceof Error) {
    this.<span class="apidocCodeKeywordSpan">_addParseError</span>(message);
    return;
}

this._addError({
    message: message,
    element: element,
    offset: offset
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype._prepareMessage" id="apidoc.element.jscs.errors.prototype._prepareMessage">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>_prepareMessage
        <span class="apidocSignatureSpan">(errorInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_prepareMessage = function (errorInfo) {
    var rule = errorInfo instanceof Error ? 'parseError' : this._currentRule;

    if (rule) {
        return rule + ': ' + errorInfo.message;
    }

    return errorInfo.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} errorInfo
 * @private
 */
_addError: function(errorInfo) {
    this._errorList.push({
        filename: this._file.getFilename(),
        rule: this._currentRule,
        message: this.<span class="apidocCodeKeywordSpan">_prepareMessage</span>(errorInfo),
        element: errorInfo.element,
        offset: errorInfo.offset,
        additional: errorInfo.additional,
        fixed: false,
        fix: errorInfo.fix
    });
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.add" id="apidoc.element.jscs.errors.prototype.add">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>add
        <span class="apidocSignatureSpan">(message, element, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (message, element, offset) {
    if (message instanceof Error) {
        this._addParseError(message);
        return;
    }

    this._addError({
        message: message,
        element: element,
        offset: offset
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

            // Apply specific fix
            if (!isFixed) {
                this._fixSpecificError(file, error);
            }
        } catch (e) {
            error.fixed = false;
            errors.<span class="apidocCodeKeywordSpan">add</span>(
                getInternalErrorMessage(error.rule, e),
                file.getProgram()
            );
        }
    }, this);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.calculateErrorLocations" id="apidoc.element.jscs.errors.prototype.calculateErrorLocations">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>calculateErrorLocations
        <span class="apidocSignatureSpan">(tokenIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculateErrorLocations = function (tokenIndex) {
    this._errorList.forEach(function(error) {
        var pos = Errors.getPosition(error, tokenIndex);
        error.line = pos.line;
        error.column = pos.column;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
    errors.add('Unsupported rule: ' + rulename, file.getProgram());
});

var program = file.getProgram();
var tokenIndex = new TokenIndex(program.getFirstToken());
errors.<span class="apidocCodeKeywordSpan">calculateErrorLocations</span>(tokenIndex);
errors.filter(function(error) {
    if (error.element) {
        return tokenIndex.isRuleEnabled(error.rule, error.element);
    } else {
        return true;
    }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.cast" id="apidoc.element.jscs.errors.prototype.cast">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>cast
        <span class="apidocSignatureSpan">(errorInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cast = function (errorInfo) {
    this._addError(errorInfo);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                return;
            }

            if (exceptReserved &amp;&amp; reservedWords.check(key.value, file.getDialect(), true)) {
                return;
            }

            errors.<span class="apidocCodeKeywordSpan">cast</span>({
                message: 'Extra quotes for key',
                element: prop
            });
        });
    });
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.explainError" id="apidoc.element.jscs.errors.prototype.explainError">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>explainError
        <span class="apidocSignatureSpan">(error, colorize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">explainError = function (error, colorize) {
    var lineNumber = error.line - 1;
    var lines = this._file.getLines();
    var result = [
        renderLine(lineNumber, lines[lineNumber], colorize),
        renderPointer(error.column, colorize)
    ];
    var i = lineNumber - 1;
    var linesAround = 2;
    while (i &gt;= 0 &amp;&amp; i &gt;= (lineNumber - linesAround)) {
        result.unshift(renderLine(i, lines[i], colorize));
        i--;
    }
    i = lineNumber + 1;
    while (i &lt; lines.length &amp;&amp; i &lt;= (lineNumber + linesAround)) {
        result.push(renderLine(i, lines[i], colorize));
        i++;
    }
    result.unshift(formatErrorMessage(error.message, this.getFilename(), colorize));
    return result.join('\n');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
errorsCollection.forEach(function(errors) {
    if (!errors.isEmpty()) {
        /**
         * Formatting every single error.
         */
        errors.getErrorList().forEach(function(error) {
            errorCount++;
            console.log(errors.<span class="apidocCodeKeywordSpan">explainError</span>(error, true) + '\n');
        });
    }
});
if (errorCount) {
    /**
     * Printing summary.
     */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.filter" id="apidoc.element.jscs.errors.prototype.filter">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>filter
        <span class="apidocSignatureSpan">(filter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (filter) {
    this._errorList = this._errorList.filter(filter);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var file;

    options = Object.create(options);
    options.maxDepth = 1;
    options.cwd = path.resolve(options.cwd);

    do {
file = patterns.<span class="apidocCodeKeywordSpan">filter</span>(function(pattern) {
    var configPath = glob.sync(pattern, options)[0];

    if (configPath) {
        return fn(path.join(options.cwd, configPath));
    }
})[0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.getErrorCount" id="apidoc.element.jscs.errors.prototype.getErrorCount">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>getErrorCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getErrorCount = function () {
    return this._errorList.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    if (this.maxErrorsEnabled()) {
        if (this._maxErrors === -1 || this._maxErrors === null) {
            this._maxErrorsExceeded = false;

        } else {
            this._maxErrorsExceeded = this._errorsFound + errors.<span class="apidocCodeKeywordSpan">getErrorCount</span>() &gt;
; this._maxErrors;
            errors.stripErrorList(Math.max(0, this._maxErrors - this._errorsFound));
        }
    }

    this._errorsFound += errors.getErrorCount();
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.getErrorList" id="apidoc.element.jscs.errors.prototype.getErrorList">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>getErrorList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getErrorList = function () {
    return this._errorList;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return Vow.resolve(null);
    }

    return vowFs.read(path, 'utf8').then(function(data) {
var result = extractJs(path, data);

result.sources.forEach(function(script) {
    this.checkString(script.source, path).<span class="apidocCodeKeywordSpan">getErrorList</span>().forEach(function(error) {
        error.line += script.line;
        error.column += script.offset;
        result.addError(error);
    });
}, this);

return result.errors;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.getFilename" id="apidoc.element.jscs.errors.prototype.getFilename">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>getFilename
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFilename = function () {
    return this._file.getFilename();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Adds parser error to error list.
 *
 * @param {Object} errorInfo
 * @private
 */
_addParseError: function(errorInfo) {
    this._errorList.push({
        filename: this._file.<span class="apidocCodeKeywordSpan">getFilename</span>(),
        rule: 'parseError',
        message: errorInfo.message,
        line: errorInfo.loc ? errorInfo.loc.line : 1,
        column: errorInfo.loc ? errorInfo.loc.column : 0
    });
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.getValidationErrorCount" id="apidoc.element.jscs.errors.prototype.getValidationErrorCount">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>getValidationErrorCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getValidationErrorCount = function () {
    return this._errorList.filter(function(error) {
        return error.rule !== 'parseError' &amp;&amp; error.rule !== 'internalError';
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.isEmpty" id="apidoc.element.jscs.errors.prototype.isEmpty">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function () {
    return this._errorList.length === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

checkerPromise.then(function(errorsCollection) {
    reporter.writer(errorsCollection);
    handleMaxErrors();

    errorsCollection.forEach(function(errors) {
        if (!errors.<span class="apidocCodeKeywordSpan">isEmpty</span>()) {
            defer.reject(2);
        }
    });

    defer.resolve(0);
}).fail(function(e) {
    console.error(e.stack);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.setCurrentRule" id="apidoc.element.jscs.errors.prototype.setCurrentRule">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>setCurrentRule
        <span class="apidocSignatureSpan">(rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setCurrentRule = function (rule) {
    this._currentRule = rule;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (this._maxErrorsExceeded) {
return;
        }

        var errorFilter = this._configuration.getErrorFilter();

        this._configuredRules.forEach(function(rule) {
errors.<span class="apidocCodeKeywordSpan">setCurrentRule</span>(rule.getOptionName());

try {
    rule.check(file, errors);
} catch (e) {
    errors.setCurrentRule('internalError');
    errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.errors.prototype.stripErrorList" id="apidoc.element.jscs.errors.prototype.stripErrorList">
        function <span class="apidocSignatureSpan">jscs.errors.prototype.</span>stripErrorList
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripErrorList = function (length) {
    this._errorList.splice(length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (this.maxErrorsEnabled()) {
        if (this._maxErrors === -1 || this._maxErrors === null) {
            this._maxErrorsExceeded = false;

        } else {
            this._maxErrorsExceeded = this._errorsFound + errors.getErrorCount() &gt; this._maxErrors;
            errors.<span class="apidocCodeKeywordSpan">stripErrorList</span>(Math.max(0, this._maxErrors - this._errorsFound));
        }
    }

    this._errorsFound += errors.getErrorCount();
},

/**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.generator" id="apidoc.module.jscs.generator">module jscs.generator</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.generator.generator" id="apidoc.element.jscs.generator.generator">
        function <span class="apidocSignatureSpan">jscs.</span>generator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Generator() {
    this._config = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.generator.prototype" id="apidoc.module.jscs.generator.prototype">module jscs.generator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.generator.prototype._checkAgainstPreset" id="apidoc.element.jscs.generator.prototype._checkAgainstPreset">
        function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_checkAgainstPreset
        <span class="apidocSignatureSpan">(path, presetName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkAgainstPreset = function (path, presetName) {
    var checker = getChecker();

    checker.configure({preset: presetName, maxErrors: Infinity});

    return checker.checkPath(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.generator.prototype._generateStatsForPresets" id="apidoc.element.jscs.generator.prototype._generateStatsForPresets">
        function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_generateStatsForPresets
        <span class="apidocSignatureSpan">(resultsPerPreset, presetNames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_generateStatsForPresets = function (resultsPerPreset, presetNames) {
    return resultsPerPreset.map(function(presetResults, idx) {
        var errorCollection = [].concat.apply([], presetResults);

        var presetStats = {
            name: presetNames[idx],
            sum: 0,
            errors: []
        };

        errorCollection.forEach(function(error) {
            presetStats.sum += error.getErrorCount();
            presetStats.errors = presetStats.errors.concat(error.getErrorList());
        });

        return presetStats;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var statsForPresets;

console.log('Checking', _path, 'against the presets');

return Vow
.all(presetNames.map(this._checkAgainstPreset.bind(this, _path)))
.then(function(resultsPerPreset) {
    statsForPresets = this.<span class="apidocCodeKeywordSpan">_generateStatsForPresets</span>(resultsPerPreset, presetNames);
    return statsForPresets;
}.bind(this))
.then(this._showErrorCounts.bind(this))
.then(this._getUserPresetChoice.bind(this, prompts[0]))
.then(function showViolatedRules(choiceObj) {
    var presetIndex = choiceObj[prompts[0].name] - 1;
    var presetName = statsForPresets[presetIndex].name;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.generator.prototype._getUserPresetChoice" id="apidoc.element.jscs.generator.prototype._getUserPresetChoice">
        function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_getUserPresetChoice
        <span class="apidocSignatureSpan">(prompt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getUserPresetChoice = function (prompt) {
    return this._showPrompt(prompt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.generator.prototype._getUserViolationChoices" id="apidoc.element.jscs.generator.prototype._getUserViolationChoices">
        function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_getUserViolationChoices
        <span class="apidocSignatureSpan">(errorPrompts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getUserViolationChoices = function (errorPrompts) {
    return this._showPrompt(errorPrompts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (!violatedRuleCount) { return this._config; }

    console.log(_path + ' violates ' + violatedRuleCount + ' rule' + (violatedRuleCount &gt; 1 ? 's&amp;#
x27; : ''));

    var errorPrompts = generateRuleHandlingPrompts(errorStats);

    return this.<span class="apidocCodeKeywordSpan">_getUserViolationChoices</span>(errorPrompts)
    .then(this._handleViolatedRules.bind(this, errorPrompts))
    .then(function() {
        return this._config;
    }.bind(this));
}.bind(this))
.then(function flushConfig() {
    fs.writeFileSync(process.cwd() + '/.jscsrc', JSON.stringify(this._config, null, '\t'));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.generator.prototype._handleViolatedRules" id="apidoc.element.jscs.generator.prototype._handleViolatedRules">
        function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_handleViolatedRules
        <span class="apidocSignatureSpan">(errorPrompts, choices)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handleViolatedRules = function (errorPrompts, choices) {
    errorPrompts.forEach(function(errorPrompt) {
        var userChoice = choices[errorPrompt.name];

        if (userChoice &amp;&amp; userChoice.toLowerCase() === 'e') {
            this._config[errorPrompt.associatedRuleName] = null;
        }
    }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.generator.prototype._showErrorCounts" id="apidoc.element.jscs.generator.prototype._showErrorCounts">
        function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_showErrorCounts
        <span class="apidocSignatureSpan">(statsForPresets)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_showErrorCounts = function (statsForPresets) {
    var table = getTable();

    statsForPresets.forEach(function(presetStats, idx) {
        table.push([idx + 1, presetStats.name, presetStats.sum, getUniqueErrorNames(presetStats.errors).length]);
    });

    console.log(table.toString());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.generator.prototype._showPrompt" id="apidoc.element.jscs.generator.prototype._showPrompt">
        function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>_showPrompt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_showPrompt = function () {
    var deferred = Vow.defer();
    var args = [].slice.call(arguments);

    args.push(function(err, result) {
        if (err) {
            deferred.reject(err);
        } else {
            deferred.resolve(result);
        }
    });

    fn.apply(null, args);

    return deferred.promise();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Prompts the user to choose a preset
*
* @private
* @param {Object} prompt
* @return {Promise}
*/
Generator.prototype._getUserPresetChoice = function(prompt) {
   return this.<span class="apidocCodeKeywordSpan">_showPrompt</span>(prompt);
};

/**
* Prompts the user to nullify rules or fix violations themselves
*
* @private
* @param  {Object[]} errorPrompts
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.generator.prototype.generate" id="apidoc.element.jscs.generator.prototype.generate">
        function <span class="apidocSignatureSpan">jscs.generator.prototype.</span>generate
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (path) {
    var checker = getChecker();
    var _path = utils.normalizePath(path, checker.getConfiguration().getBasePath());
    var presetNames = Object.keys(checker.getConfiguration().getRegisteredPresets());
    var statsForPresets;

    console.log('Checking', _path, 'against the presets');

    return Vow
    .all(presetNames.map(this._checkAgainstPreset.bind(this, _path)))
    .then(function(resultsPerPreset) {
        statsForPresets = this._generateStatsForPresets(resultsPerPreset, presetNames);
        return statsForPresets;
    }.bind(this))
    .then(this._showErrorCounts.bind(this))
    .then(this._getUserPresetChoice.bind(this, prompts[0]))
    .then(function showViolatedRules(choiceObj) {
        var presetIndex = choiceObj[prompts[0].name] - 1;
        var presetName = statsForPresets[presetIndex].name;

        console.log('You chose the ' + presetName + ' preset');

        this._config.preset = presetName;

        var errorStats = getErrorsByRuleName(statsForPresets[presetIndex].errors);

        var violatedRuleCount = Object.keys(errorStats).length;

        if (!violatedRuleCount) { return this._config; }

        console.log(_path + ' violates ' + violatedRuleCount + ' rule' + (violatedRuleCount &gt; 1 ? 's' : ''));

        var errorPrompts = generateRuleHandlingPrompts(errorStats);

        return this._getUserViolationChoices(errorPrompts)
        .then(this._handleViolatedRules.bind(this, errorPrompts))
        .then(function() {
            return this._config;
        }.bind(this));
    }.bind(this))
    .then(function flushConfig() {
        fs.writeFileSync(process.cwd() + '/.jscsrc', JSON.stringify(this._config, null, '\t'));
        console.log('Generated a .jscsrc configuration file in ' + process.cwd());
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

return returnArgs;
    }
    if (program.autoConfigure) {
var generator = new ConfigGenerator();

generator
.<span class="apidocCodeKeywordSpan">generate</span>(program.autoConfigure)
.then(function() {
    defer.resolve(0);
}, function(error) {
    console.error('Configuration generation failed due to ', error);
    defer.reject(7);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.js_file" id="apidoc.module.jscs.js_file">module jscs.js_file</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.js_file.js_file" id="apidoc.element.jscs.js_file.js_file">
        function <span class="apidocSignatureSpan">jscs.</span>js_file
        <span class="apidocSignatureSpan">(params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">js_file = function (params) {
    params = params || {};
    this._parseErrors = [];
    this._filename = params.filename;
    this._source = params.source;

    this._es3 = params.es3 || false;

    this._lineBreaks = null;
    this._lines = this._source.split(/\r\n|\r|\n/);

    var parser = new Parser({
        strictMode: false,
        languageExtensions: {
            gritDirectives: true,
            appleInstrumentationDirectives: true
        }
    });

    try {
        this._program = parser.parse(this._source);
    } catch (e) {
        this._parseErrors.push(e);
        this._program = new Program([
            new Token('EOF', '')
        ]);
    }

    // Lazy initialization
    this._scopes = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.js_file.prototype" id="apidoc.module.jscs.js_file.prototype">module jscs.js_file.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype._setTokenBefore" id="apidoc.element.jscs.js_file.prototype._setTokenBefore">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>_setTokenBefore
        <span class="apidocSignatureSpan">(token, fragment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setTokenBefore = function (token, fragment) {
    var parent = token;
    var grandpa = parent.parentElement;

    while (grandpa) {
        try {
            grandpa.insertChildBefore(fragment, parent);
            break;
        } catch (e) {}

        parent = grandpa;
        grandpa = parent.parentElement;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return;
    }

    prevToken.parentElement.replaceChild(fragment, prevToken);
    return;
}

this.<span class="apidocCodeKeywordSpan">_setTokenBefore</span>(token, fragment);
    },

    _setTokenBefore: function(token, fragment) {
var parent = token;
var grandpa = parent.parentElement;

while (grandpa) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.findNextOperatorToken" id="apidoc.element.jscs.js_file.prototype.findNextOperatorToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>findNextOperatorToken
        <span class="apidocSignatureSpan">(token, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findNextOperatorToken = function (token, value) {
    return this.findNextToken(token, value in KEYWORD_OPERATORS ? 'Keyword' : 'Punctuator', value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.findNextToken" id="apidoc.element.jscs.js_file.prototype.findNextToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>findNextToken
        <span class="apidocSignatureSpan">(token, type, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findNextToken = function (token, type, value) {
    var nextToken = token.getNextToken();

    while (nextToken) {
        if (nextToken.type === type &amp;&amp; (value === undefined || nextToken.value === value)) {
            return nextToken;
        }

        nextToken = nextToken.getNextToken();
    }
    return nextToken;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Returns the first token after the given which matches type (and value).
 *
 * @param {Object} token
 * @param {String} value
 * @returns {Object|null}
 */
findNextOperatorToken: function(token, value) {
    return this.<span class="apidocCodeKeywordSpan">findNextToken</span>(token, value in KEYWORD_OPERATORS ? 'Keyword' : &amp;#
x27;Punctuator', value);
},

/**
 * Iterates through the token tree using tree iterator.
 * Calls passed function for every token.
 *
 * @param {Function} cb
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.findPrevOperatorToken" id="apidoc.element.jscs.js_file.prototype.findPrevOperatorToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>findPrevOperatorToken
        <span class="apidocSignatureSpan">(token, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findPrevOperatorToken = function (token, value) {
    return this.findPrevToken(token, value in KEYWORD_OPERATORS ? 'Keyword' : 'Punctuator', value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    expression = node.right;
}

if (expression === null) {
    return;
}

var operatorToken = file.<span class="apidocCodeKeywordSpan">findPrevOperatorToken</span>(
    file.getFirstNodeToken(expression),
    operator
);

var nextToken = file.getNextToken(operatorToken);

if (operators[operator]) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.findPrevToken" id="apidoc.element.jscs.js_file.prototype.findPrevToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>findPrevToken
        <span class="apidocSignatureSpan">(token, type, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findPrevToken = function (token, type, value) {
    var prevToken = this.getPrevToken(token);
    while (prevToken) {
        if (prevToken.type === type &amp;&amp; (value === undefined || prevToken.value === value)) {
            return prevToken;
        }

        prevToken = this.getPrevToken(prevToken);
    }
    return prevToken;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Returns the first token before the given which matches type (and value).
 *
 * @param {Object} token
 * @param {String} value
 * @returns {Object|null}
 */
findPrevOperatorToken: function(token, value) {
    return this.<span class="apidocCodeKeywordSpan">findPrevToken</span>(token, value in KEYWORD_OPERATORS ? 'Keyword' : &amp;#
x27;Punctuator', value);
},

/**
 * Returns the first token after the given which matches type (and value).
 *
 * @param {Object} token
 * @param {String} value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getComments" id="apidoc.element.jscs.js_file.prototype.getComments">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getComments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComments = function () {
    var comments = [];
    var token = this._program.getFirstToken();
    while (token) {
        if (token.isComment) {
            comments[comments.length] = token;
        }
        token = token.getNextToken();
    }
    return comments;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * Returns array of source lines for the file with comments removed.
     *
     * @returns {Array}
     */
    getLinesWithCommentsRemoved: function() {
var lines = this.getLines().concat();

this.<span class="apidocCodeKeywordSpan">getComments</span>().concat().reverse().forEach(function(comment) {
    var loc = comment.getLoc();
    var startLine = loc.start.line;
    var startCol = loc.start.column;
    var endLine = loc.end.line;
    var endCol = loc.end.column;
    var i = startLine - 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getDialect" id="apidoc.element.jscs.js_file.prototype.getDialect">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getDialect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDialect = function () {
    if (this._es3) {
        return 'es3';
    }

    return 'es6';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
}

if (!KEY_NAME_RE.test(key.value)) {
    return;
}

if (exceptReserved &amp;&amp; reservedWords.check(key.value, file.<span class="apidocCodeKeywordSpan">getDialect</span>(), true
)) {
    return;
}

errors.cast({
    message: 'Extra quotes for key',
    element: prop
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getDistanceBetween" id="apidoc.element.jscs.js_file.prototype.getDistanceBetween">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getDistanceBetween
        <span class="apidocSignatureSpan">(tokenBefore, tokenAfter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDistanceBetween = function (tokenBefore, tokenAfter) {
    if (tokenBefore === tokenAfter) {
        return 0;
    }
    tokenBefore = tokenBefore instanceof Token ? tokenBefore : tokenBefore.getLastToken();
    tokenAfter = tokenAfter instanceof Token ? tokenAfter : tokenAfter.getFirstToken();
    var currentToken = tokenBefore.getNextToken();
    var distance = 0;
    while (currentToken) {
        if (currentToken === tokenAfter) {
            break;
        }

        distance += currentToken.getSourceCodeLength();
        currentToken = currentToken.getNextToken();
    }
    return distance;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        message: options.message,
        element: token,
        offset: token.getSourceCodeLength(),
        fix: fixed ? fix : undefined
    });
}.bind(this);

var spacesBetween = this._file.<span class="apidocCodeKeywordSpan">getDistanceBetween</span>(token, nextToken);

if (atLeast !== undefined &amp;&amp; spacesBetween &lt; atLeast) {
    emitError('at least', atLeast);
    return true;
}

if (atMost !== undefined &amp;&amp; spacesBetween &gt; atMost) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getFilename" id="apidoc.element.jscs.js_file.prototype.getFilename">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getFilename
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFilename = function () {
    return this._filename;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Adds parser error to error list.
 *
 * @param {Object} errorInfo
 * @private
 */
_addParseError: function(errorInfo) {
    this._errorList.push({
        filename: this._file.<span class="apidocCodeKeywordSpan">getFilename</span>(),
        rule: 'parseError',
        message: errorInfo.message,
        line: errorInfo.loc ? errorInfo.loc.line : 1,
        column: errorInfo.loc ? errorInfo.loc.column : 0
    });
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getFirstNodeToken" id="apidoc.element.jscs.js_file.prototype.getFirstNodeToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getFirstNodeToken
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFirstNodeToken = function (node) {
    return node.getFirstToken();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//     // different lines:
//     for (var i = 0;
//          i &lt; length;
//          i++)
//     {
//     }
var parentElement = node.parentElement;
var parentNextToken = file.<span class="apidocCodeKeywordSpan">getFirstNodeToken</span>(parentElement);
var openingRoundBrace = file.findNextToken(parentNextToken, 'Punctuator', '(');
var closingRoundBrace = file.findPrevToken(openingBrace, 'Punctuator', ')');

// Not always the conditions are there: to check look for the presence of round braces.
// For example:
//     try {
//     } ...
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getFirstToken" id="apidoc.element.jscs.js_file.prototype.getFirstToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getFirstToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFirstToken = function () {
    return this._program.getFirstToken();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Returns the first token for the node from the AST.
 *
 * @param {Object} node
 * @returns {Object}
 */
getFirstNodeToken: function(node) {
    return node.<span class="apidocCodeKeywordSpan">getFirstToken</span>();
},

/**
 * Returns the last token for the node from the AST.
 *
 * @param {Object} node
 * @returns {Object}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getFirstTokenOnLineWith" id="apidoc.element.jscs.js_file.prototype.getFirstTokenOnLineWith">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getFirstTokenOnLineWith
        <span class="apidocSignatureSpan">(element, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFirstTokenOnLineWith = function (element, options) {
    options = options || {};
    var firstToken = element;

    if (element.isComment &amp;&amp; !options.includeComments) {
        firstToken = null;
    }

    if (element.isWhitespace &amp;&amp; !options.includeWhitespace) {
        firstToken = null;
    }

    var currentToken = element.getPreviousToken();
    while (currentToken) {
        if (currentToken.isWhitespace) {
            if (currentToken.getNewlineCount() &gt; 0 || !currentToken.getPreviousToken()) {
                if (options.includeWhitespace) {
                    firstToken = currentToken;
                }
                break;
            }
        } else if (currentToken.isComment) {
            if (options.includeComments) {
                firstToken = currentToken;
                break;
            }
            if (currentToken.getNewlineCount() &gt; 0) {
                break;
            }
        } else {
            firstToken = currentToken;
        }

        currentToken = currentToken.getPreviousToken();
    }

    if (firstToken) {
        return firstToken;
    }

    currentToken = element.getNextToken();
    while (currentToken) {
        if (currentToken.isWhitespace) {
            if (currentToken.getNewlineCount() &gt; 0 || !currentToken.getNextToken()) {
                if (options.includeWhitespace) {
                    firstToken = currentToken;
                }
                break;
            }
        } else if (currentToken.isComment) {
            if (options.includeComments) {
                firstToken = currentToken;
                break;
            }
            if (currentToken.getNewlineCount() &gt; 0) {
                break;
            }
        } else {
            firstToken = currentToken;
        }

        currentToken = currentToken.getNextToken();
    }

    return firstToken;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var allowFirstAfterCurly = this._allowFirstAfterCurly;

        file.iterateTokensByType('CommentLine', function(comment) {
if (comment.getLoc().start.line === 1) {
    return;
}

var firstToken = file.<span class="apidocCodeKeywordSpan">getFirstTokenOnLineWith</span>(comment);

// Should not consider code and comment on the same line (#1194)
if (firstToken !== null &amp;&amp; firstToken.type !== 'EOF') {
    return;
}

var prevToken = file.getPrevToken(comment, {includeComments: true});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getLastNodeToken" id="apidoc.element.jscs.js_file.prototype.getLastNodeToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLastNodeToken
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLastNodeToken = function (node) {
    return node.getLastToken();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    assertSameLine(prevToken, openingBrace);
}
            }
        });

        if (setting === true || setting.indexOf('switch') !== -1) {
            file.iterateNodesByType(['SwitchStatement'], function(node) {
var openingBrace = file.findNextToken(file.<span class="apidocCodeKeywordSpan">getLastNodeToken</span>(node.discriminant), '
;Punctuator', '{');
var prevToken = file.getPrevToken(openingBrace);

if (hasMultiLineEx !== true) {
    assertSameLine(prevToken, openingBrace);
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getLastToken" id="apidoc.element.jscs.js_file.prototype.getLastToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLastToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLastToken = function () {
    return this._program.getLastToken();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Returns the last token for the node from the AST.
 *
 * @param {Object} node
 * @returns {Object}
 */
getLastNodeToken: function(node) {
    return node.<span class="apidocCodeKeywordSpan">getLastToken</span>();
},

/**
 * Returns the first token for the file.
 *
 * @param {Option} [options]
 * @param {Boolean} [options.includeComments=false]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getLastTokenOnLine" id="apidoc.element.jscs.js_file.prototype.getLastTokenOnLine">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLastTokenOnLine
        <span class="apidocSignatureSpan">(lineNumber, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLastTokenOnLine = function (lineNumber, options) {
    options = options || {};

    var loc;
    var token = this._program.getLastToken();
    var currentToken;

    while (token) {
        loc = token.getLoc();
        currentToken = token;
        token = token.getPreviousToken();

        if (loc.start.line &lt;= lineNumber &amp;&amp; loc.end.line &gt;= lineNumber) {

            // Since whitespace tokens can contain newlines we need to check
            // if position is in the range, not exact match
            if (currentToken.isWhitespace &amp;&amp; !options.includeWhitespace) {
                continue;
            }
        }

        if (loc.start.line === lineNumber || loc.end.line === lineNumber) {
            if (currentToken.isComment &amp;&amp; !options.includeComments) {
                continue;
            }

            return currentToken;
        }
    }

    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        for (var i = 0, l = lines.length; i &lt; l; i++) {
            line = this._tabSize ? lines[i].replace(/\t/g, this._tabSize) : lines[i];

            if (line.length &gt; maximumLineLength) {
                errors.add(
                    'Line must be at most ' + maximumLineLength + ' characters',
                    file.<span class="apidocCodeKeywordSpan">getLastTokenOnLine</span>(i + 1, { includeComments: true })
                );
            }
        }
    }

};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getLineBreakStyle" id="apidoc.element.jscs.js_file.prototype.getLineBreakStyle">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLineBreakStyle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLineBreakStyle = function () {
    var lineBreaks = this.getLineBreaks();
    return lineBreaks.length ? lineBreaks[0] : '\n';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Updates the whitespace of a line by passing split lines to a callback function
 * for editing.
 *
 * @param {Object} token
 * @param {Function} callback
 */
TokenAssert.prototype._updateWhitespaceByLine = function(token, callback) {
    var lineBreak = this._file.<span class="apidocCodeKeywordSpan">getLineBreakStyle</span>();
    var lines = this._file.getWhitespaceBefore(token).split(/\r\n|\r|\n/);

    lines = callback(lines);
    this._file.setWhitespaceBefore(token, lines.join(lineBreak));
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getLineBreaks" id="apidoc.element.jscs.js_file.prototype.getLineBreaks">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLineBreaks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLineBreaks = function () {
    if (this._lineBreaks === null) {
        this._lineBreaks = this._source.match(/\r\n|\r|\n/g) || [];
    }
    return this._lineBreaks;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Returns the first line break character encountered in the file.
 * Assumes LF if the file is only one line.
 *
 * @returns {String}
 */
getLineBreakStyle: function() {
    var lineBreaks = this.<span class="apidocCodeKeywordSpan">getLineBreaks</span>();
    return lineBreaks.length ? lineBreaks[0] : '\n';
},

/**
 * Returns all line break characters from the file.
 *
 * @returns {String[]}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getLineCountBetween" id="apidoc.element.jscs.js_file.prototype.getLineCountBetween">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLineCountBetween
        <span class="apidocSignatureSpan">(tokenBefore, tokenAfter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLineCountBetween = function (tokenBefore, tokenAfter) {
    if (tokenBefore === tokenAfter) {
        return 0;
    }
    tokenBefore = tokenBefore instanceof Token ? tokenBefore : tokenBefore.getLastToken();
    tokenAfter = tokenAfter instanceof Token ? tokenAfter : tokenAfter.getFirstToken();

    var currentToken = tokenBefore.getNextToken();
    var lineCount = 0;
    while (currentToken) {
        if (currentToken === tokenAfter) {
            break;
        }

        lineCount += currentToken.getNewlineCount();
        currentToken = currentToken.getNextToken();
    }
    return lineCount;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    this._validateOptions(options);

    // Only attempt to remove or add lines if there are no comments between the two nodes
    // as this prevents accidentally moving a valid token onto a line comment ed line
    var fixed = !options.token.getNextNonWhitespaceToken().isComment;

    var linesBetween = this._file.<span class="apidocCodeKeywordSpan">getLineCountBetween</span>(token, nextToken);

    var emitError = function(countPrefix, lineCount) {
var msgPrefix = token.value + ' and ' + nextToken.value;

var fix = function() {
    this._augmentLineCount(options, lineCount);
}.bind(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getLines" id="apidoc.element.jscs.js_file.prototype.getLines">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLines
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLines = function () {
    return this._lines;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Object} error
 * @param {Boolean} [colorize = false]
 * @returns {String}
 */
explainError: function(error, colorize) {
    var lineNumber = error.line - 1;
    var lines = this._file.<span class="apidocCodeKeywordSpan">getLines</span>();
    var result = [
        renderLine(lineNumber, lines[lineNumber], colorize),
        renderPointer(error.column, colorize)
    ];
    var i = lineNumber - 1;
    var linesAround = 2;
    while (i &gt;= 0 &amp;&amp; i &gt;= (lineNumber - linesAround)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getLinesWithCommentsRemoved" id="apidoc.element.jscs.js_file.prototype.getLinesWithCommentsRemoved">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getLinesWithCommentsRemoved
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLinesWithCommentsRemoved = function () {
    var lines = this.getLines().concat();

    this.getComments().concat().reverse().forEach(function(comment) {
        var loc = comment.getLoc();
        var startLine = loc.start.line;
        var startCol = loc.start.column;
        var endLine = loc.end.line;
        var endCol = loc.end.column;
        var i = startLine - 1;

        if (startLine === endLine) {
            // Remove tralling spaces (see gh-1968)
            lines[i] = lines[i].replace(/\*\/\s+/, '\*\/');
            lines[i] = lines[i].substring(0, startCol) + lines[i].substring(endCol);
        } else {
            lines[i] = lines[i].substring(0, startCol);
            for (var x = i + 1; x &lt; endLine - 1; x++) {
                lines[x] = '';
            }

            lines[x] = lines[x].substring(endCol);
        }
    });

    return lines;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },

    check: function(file, errors) {
        var maximumLineLength = this._maximumLineLength;

        var line;
        var lines = this._allowComments ?
file.<span class="apidocCodeKeywordSpan">getLinesWithCommentsRemoved</span>() : file.getLines();

        // This check should not be destructive
        lines = lines.slice();

        var removeLoc = function(tokenOrNode) {

// Just in case (See #2107 for example)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getNextToken" id="apidoc.element.jscs.js_file.prototype.getNextToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getNextToken
        <span class="apidocSignatureSpan">(token, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNextToken = function (token, options) {
    if (options &amp;&amp; options.includeComments) {
        return token.getNextNonWhitespaceToken();
    } else {
        return token.getNextCodeToken();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     *
     * @param {Object} token
     * @param {String} type
     * @param {String} [value]
     * @returns {Object|null}
     */
    findNextToken: function(token, type, value) {
        var nextToken = token.<span class="apidocCodeKeywordSpan">getNextToken</span>();

        while (nextToken) {
if (nextToken.type === type &amp;&amp; (value === undefined || nextToken.value === value)) {
    return nextToken;
}

nextToken = nextToken.getNextToken();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getNodesByType" id="apidoc.element.jscs.js_file.prototype.getNodesByType">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getNodesByType
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNodesByType = function (type) {
    type = Array.isArray(type) ? type : [type];
    var result = [];

    for (var i = 0, l = type.length; i &lt; l; i++) {
        var nodes = this._program.selectNodesByType(type[i]);

        if (nodes) {
            result = result.concat(nodes);
        }
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Calls passed function for every matched node.
 *
 * @param {String|String[]} type
 * @param {Function} cb
 * @param {Object} context
 */
iterateNodesByType: function(type, cb, context) {
    return this.<span class="apidocCodeKeywordSpan">getNodesByType</span>(type).forEach(cb, context || this);
},

/**
 * Iterates tokens by type(s) from the token array.
 * Calls passed function for every matched token.
 *
 * @param {String|String[]} type
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getParseErrors" id="apidoc.element.jscs.js_file.prototype.getParseErrors">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getParseErrors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParseErrors = function () {
    return this._parseErrors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    checkString: function(source, filename) {
filename = filename || 'input';

var file = this._createJsFileInstance(filename, source);

var errors = new Errors(file);

file.<span class="apidocCodeKeywordSpan">getParseErrors</span>().forEach(function(parseError) {
    if (!this._maxErrorsExceeded) {
        this._addParseError(errors, parseError, file);
    }
}, this);

if (!file._program || file._program.firstChild.type === 'EOF') {
    return errors;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getPrevToken" id="apidoc.element.jscs.js_file.prototype.getPrevToken">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getPrevToken
        <span class="apidocSignatureSpan">(token, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPrevToken = function (token, options) {
    if (options &amp;&amp; options.includeComments) {
        return token.getPreviousNonWhitespaceToken();
    }

    return token.getPreviousCodeToken();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     *
     * @param {Object} token
     * @param {String} type
     * @param {String} [value]
     * @returns {Object|null}
     */
    findPrevToken: function(token, type, value) {
var prevToken = this.<span class="apidocCodeKeywordSpan">getPrevToken</span>(token);
while (prevToken) {
    if (prevToken.type === type &amp;&amp; (value === undefined || prevToken.value === value)) {
        return prevToken;
    }

    prevToken = this.getPrevToken(prevToken);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getProgram" id="apidoc.element.jscs.js_file.prototype.getProgram">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getProgram
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getProgram = function () {
    return this._program;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if (!isFixed) {
                this._fixSpecificError(file, error);
            }
        } catch (e) {
            error.fixed = false;
            errors.add(
                getInternalErrorMessage(error.rule, e),
                file.<span class="apidocCodeKeywordSpan">getProgram</span>()
            );
        }
    }, this);
},

/**
 * Checks a file specified using JsFile instance.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getScopes" id="apidoc.element.jscs.js_file.prototype.getScopes">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getScopes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getScopes = function () {
    if (!this._scopes) {
        this._scopes = new ScopesApi(this._program);
    }

    return this._scopes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        errors.add('Pattern is not used', node);
    }
}

file.iterateNodesByType(
    ['FunctionDeclaration', 'FunctionExpression', 'ArrowFunctionExpression'],
    function(node) {
        var variableMap = file.<span class="apidocCodeKeywordSpan">getScopes</span>().acquire(node).getVariables()
            .filter(function(variable) {
                return variable.type === 'Parameter';
            })
            .reduce(function(obj, variable) {
                obj[variable.name] = variable;
                return obj;
            }, {});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getSource" id="apidoc.element.jscs.js_file.prototype.getSource">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSource = function () {
    return this._source;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }

            file = this._createJsFileInstance(filename, file.render());
            errors = new Errors(file);
            attempt++;
        } while (attempt &lt; MAX_FIX_ATTEMPTS);

        return {output: file.<span class="apidocCodeKeywordSpan">getSource</span>(), errors: errors};
    }
},

/**
 * Returns `true` if max erros limit is enabled.
 *
 * @returns {Boolean}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getTree" id="apidoc.element.jscs.js_file.prototype.getTree">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getTree
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTree = function () {
    return this._program || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.getWhitespaceBefore" id="apidoc.element.jscs.js_file.prototype.getWhitespaceBefore">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>getWhitespaceBefore
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getWhitespaceBefore = function (token) {
    if (!token.getPreviousToken) {
        console.log(token);
    }
    var prev = token.getPreviousToken();

    if (prev &amp;&amp; prev.isWhitespace) {
        return prev.getSourceCode();
    }

    return '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* for editing.
*
* @param {Object} token
* @param {Function} callback
*/
TokenAssert.prototype._updateWhitespaceByLine = function(token, callback) {
   var lineBreak = this._file.getLineBreakStyle();
   var lines = this._file.<span class="apidocCodeKeywordSpan">getWhitespaceBefore</span>(token).split(/\r\n|\r|\n/);

   lines = callback(lines);
   this._file.setWhitespaceBefore(token, lines.join(lineBreak));
};

/**
* Updates the whitespace of a line by passing split lines to a callback function
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.isOnTheSameLine" id="apidoc.element.jscs.js_file.prototype.isOnTheSameLine">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>isOnTheSameLine
        <span class="apidocSignatureSpan">(tokenBefore, tokenAfter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isOnTheSameLine = function (tokenBefore, tokenAfter) {
    if (tokenBefore === tokenAfter) {
        return true;
    }
    tokenBefore = tokenBefore instanceof Token ? tokenBefore : tokenBefore.getLastToken();
    tokenAfter = tokenAfter instanceof Token ? tokenAfter : tokenAfter.getFirstToken();
    var currentToken = tokenBefore;
    while (currentToken) {
        if (currentToken === tokenAfter) {
            return true;
        }
        if (currentToken !== tokenBefore &amp;&amp; currentToken.getNewlineCount() &gt; 0) {
            return false;
        }
        currentToken = currentToken.getNextToken();
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (!token || !nextToken) {
    return false;
}

this._validateOptions(options);

if (!options.disallowNewLine &amp;&amp; !this._file.<span class="apidocCodeKeywordSpan">isOnTheSameLine</span>(token, nextToken
)) {
    return false;
}

// Only attempt to remove or add lines if there are no comments between the two nodes
// as this prevents accidentally moving a valid token onto a line comment ed line
var fixed = !options.token.getNextNonWhitespaceToken().isComment;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.iterate" id="apidoc.element.jscs.js_file.prototype.iterate">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>iterate
        <span class="apidocSignatureSpan">(cb, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">iterate = function (cb, tree) {
    return treeIterator.iterate(tree || this._program, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Iterates through the token tree using tree iterator.
 * Calls passed function for every token.
 *
 * @param {Function} cb
 * @param {Object} [tree]
 */
iterate: function(cb, tree) {
    return treeIterator.<span class="apidocCodeKeywordSpan">iterate</span>(tree || this._program, cb);
},

/**
 * Returns nodes by type(s) from earlier built index.
 *
 * @param {String|String[]} type
 * @returns {Object[]}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.iterateNodesByType" id="apidoc.element.jscs.js_file.prototype.iterateNodesByType">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>iterateNodesByType
        <span class="apidocSignatureSpan">(type, cb, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">iterateNodesByType = function (type, cb, context) {
    return this.getNodesByType(type).forEach(cb, context || this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },

    getOptionName: function() {
        return 'disallowAnonymousFunctions';
    },

    check: function(file, errors) {
        file.<span class="apidocCodeKeywordSpan">iterateNodesByType</span>(['FunctionExpression', 'FunctionDeclaration
'], function(node) {
            if (node.id === null) {
                errors.add('Anonymous functions need to be named', node);
            }
        });
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.iterateTokensByType" id="apidoc.element.jscs.js_file.prototype.iterateTokensByType">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>iterateTokensByType
        <span class="apidocSignatureSpan">(type, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">iterateTokensByType = function (type, cb) {
    var tokens;

    if (Array.isArray(type)) {
        tokens = [];
        for (var i = 0; i &lt; type.length; i++) {
            var items = this._program.selectTokensByType(type[i]);
            tokens = tokens.concat(items);
        }
    } else {
        tokens = this._program.selectTokensByType(type);
    }

    tokens.forEach(cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
iterateTokensByTypeAndValue: function(type, value, cb) {
    var values = (typeof value === 'string') ? [value] : value;
    var valueIndex = {};
    values.forEach(function(type) {
        valueIndex[type] = true;
    });

    this.<span class="apidocCodeKeywordSpan">iterateTokensByType</span>(type, function(token) {
        if (valueIndex[token.value]) {
            cb(token);
        }
    });
},

getFirstTokenOnLineWith: function(element, options) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.iterateTokensByTypeAndValue" id="apidoc.element.jscs.js_file.prototype.iterateTokensByTypeAndValue">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>iterateTokensByTypeAndValue
        <span class="apidocSignatureSpan">(type, value, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">iterateTokensByTypeAndValue = function (type, value, cb) {
    var values = (typeof value === 'string') ? [value] : value;
    var valueIndex = {};
    values.forEach(function(type) {
        valueIndex[type] = true;
    });

    this.iterateTokensByType(type, function(token) {
        if (valueIndex[token.value]) {
            cb(token);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

return node.properties.some(function(property) {
    return property.value.type === 'FunctionExpression';
});
        }

        file.<span class="apidocCodeKeywordSpan">iterateTokensByTypeAndValue</span>('Punctuator', ',', function
(token) {
var nextToken = token.getNextCodeToken();

if (canSkip(token) || nextToken.value === ',') {
    return;
}

errors.assert.sameLine({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.render" id="apidoc.element.jscs.js_file.prototype.render">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>render
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function () {
    return this._program.getSourceCode();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                return err.fixed;
            });

            if (!hasFixes) {
                break;
            }

            file = this._createJsFileInstance(filename, file.<span class="apidocCodeKeywordSpan">render</span>());
            errors = new Errors(file);
            attempt++;
        } while (attempt &lt; MAX_FIX_ATTEMPTS);

        return {output: file.getSource(), errors: errors};
    }
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.js_file.prototype.setWhitespaceBefore" id="apidoc.element.jscs.js_file.prototype.setWhitespaceBefore">
        function <span class="apidocSignatureSpan">jscs.js_file.prototype.</span>setWhitespaceBefore
        <span class="apidocSignatureSpan">(token, whitespace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setWhitespaceBefore = function (token, whitespace) {
    var prevToken = token.getPreviousToken();
    var ws = new Token('Whitespace', whitespace);
    var fragment = new Fragment(ws);

    if (prevToken &amp;&amp; prevToken.isWhitespace) {
        if (whitespace === '') {
            prevToken.remove();
            return;
        }

        prevToken.parentElement.replaceChild(fragment, prevToken);
        return;
    }

    this._setTokenBefore(token, fragment);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    // Only attempt to remove or add lines if there are no comments between the two nodes
    // as this prevents accidentally moving a valid token onto a line comment ed line
    var fixed = !options.token.getNextNonWhitespaceToken().isComment;

    var emitError = function(countPrefix, spaceCount) {
var fix = function() {
    this._file.<span class="apidocCodeKeywordSpan">setWhitespaceBefore</span>(nextToken, new Array(spaceCount + 1).join(' &amp;#
x27;));
}.bind(this);

var msgPostfix = token.value + ' and ' + nextToken.value;

if (!options.message) {
    if (exactly === 0) {
        // support noWhitespaceBetween
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.jsdoc" id="apidoc.module.jscs.jsdoc">module jscs.jsdoc</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.jsdoc.jsdoc" id="apidoc.element.jscs.jsdoc.jsdoc">
        function <span class="apidocSignatureSpan">jscs.</span>jsdoc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsdoc = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.jsdoc.prototype" id="apidoc.module.jscs.jsdoc.prototype">module jscs.jsdoc.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.jsdoc.prototype._getReturnStatementsForNode" id="apidoc.element.jscs.jsdoc.prototype._getReturnStatementsForNode">
        function <span class="apidocSignatureSpan">jscs.jsdoc.prototype.</span>_getReturnStatementsForNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getReturnStatementsForNode = function (node) {
    if (node.jsdoc.returnStatements) {
        return node.jsdoc.returnStatements;
    }

    var statements = [];
    this._iterate(function(n) {
        if (n &amp;&amp; n.type === 'ReturnStatement' &amp;&amp; n.argument) {
            if (node === esprimaHelpers.closestScopeNode(n)) {
                statements.push(n.argument);
            }
        }
    }, node);

    node.jsdoc.returnStatements = statements;
    return statements;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.jsdoc.prototype.check" id="apidoc.element.jscs.jsdoc.prototype.check">
        function <span class="apidocSignatureSpan">jscs.jsdoc.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    patchNodesInFile(file);
    this._iterate = file.iterate;

    var _this = this;
    var scopes = {
        'function': functionNodeTypes,
    };

    // classic checker
    if (_this._rulesForNodes.file) {
        // call file checkers
        var validators = _this._rulesForNodes.file;
        if (validators) {
            validators.forEach(function(v) {
                v.call(_this, file, errors);
            });
        }
    }

    // iterate over scopes
    Object.keys(scopes).forEach(function(scope) {

        // skip unused
        if (!_this._rulesForNodes[scope] &amp;&amp; !_this._rulesForTags[scope]) {
            return;
        }

        // traverse ast tree and search scope node types
        file.iterateNodesByType(scopes[scope], function(node) {
            // init
            var validators;

            // call node checkers
            validators = _this._rulesForNodes[scope];
            if (validators) {
                validators.forEach(function(v) {
                    v.call(_this, node, addError);
                });
            }

            validators = _this._rulesForTags[scope];
            if (!validators || !node.jsdoc || !node.jsdoc.valid) {
                return;
            }

            // call rule checkers
            node.jsdoc.iterate(function(tag) {
                if (!validators['@' + tag.id]) {
                    return;
                }
                // call tag validator
                validators['@' + tag.id].forEach(function(v) {
                    v.call(_this, node, tag, fixErrLocation(addError, tag));
                });
            });

<span class="apidocCodeCommentSpan">            /**
             * Send error to jscs
             *
             * @param {string} text
             * @param {number|DocLocation} offset
             */
</span>            function addError(text, offset) {
                if (typeof offset === 'object') {
                    if (offset.type) {
                        errors.add(text, offset, 0);
                        return;
                    } else {
                        offset = offset.offset;
                    }
                }
                errors.add(text, node.jsdoc.node, offset);
            }

            /**
             * Generates function with location fixing logic to send error to jscs
             *
             * @param {function(string, number|Object)} err
             * @param {DocTag} tag
             * @returns {function(string, number|Object)}
             */
            function fixErrLocation(err, tag) {
                return function(text, offset) {
                    err(text, offset || tag.loc.offset);
                };
            }
        });

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.jsdoc.prototype.configure" id="apidoc.element.jscs.jsdoc.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.jsdoc.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(typeof options === 'object', 'jsDoc option requires object value');

    // rules structured by scopes-tags for jsdoc-tags
    var rulesForTags = this._rulesForTags = {};
    // rules structured by scopes for nodes
    var rulesForNodes = this._rulesForNodes = {};

    this._options = options;
    this._optionsList = Object.keys(options);

    // load validators
    this._validators = validators.load(this._optionsList);
    assert(this._validators.length, 'jsDoc plugin was not configured properly');

    // registering validators
    this._validators.forEach(function(v) {
        // check options
        if (v.options) {
            validators.checkOptions(v, options);
        }
        // configure
        if (v.configure) {
            v.configure.call(this, options);
        }
        // index rules by tags and scopes
        (v.scopes || ['']).forEach(function(scope) {
            if (!v.tags) {
                assert(v.length === 2, 'jsDoc rules: Wrong arity in ' + v._name + ' validator');
                rulesForNodes[scope] = rulesForNodes[scope] || [];
                rulesForNodes[scope].push(v);
                return;
            }
            assert(v.length === 3, 'jsDoc rules: Wrong arity in ' + v._name + ' validator');
            rulesForTags[scope] = rulesForTags[scope] || {};
            v.tags.forEach(function(tag) {
                var dtag = '@' + tag;
                rulesForTags[scope][dtag] = rulesForTags[scope][dtag] || [];
                rulesForTags[scope][dtag].push(v);
            });
        });
    }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.jsdoc.prototype.getOptionName" id="apidoc.element.jscs.jsdoc.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.jsdoc.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'jsDoc';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.maximum_line_length" id="apidoc.module.jscs.maximum_line_length">module jscs.maximum_line_length</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.maximum_line_length.maximum_line_length" id="apidoc.element.jscs.maximum_line_length.maximum_line_length">
        function <span class="apidocSignatureSpan">jscs.</span>maximum_line_length
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maximum_line_length = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.maximum_line_length.prototype" id="apidoc.module.jscs.maximum_line_length.prototype">module jscs.maximum_line_length.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.maximum_line_length.prototype.check" id="apidoc.element.jscs.maximum_line_length.prototype.check">
        function <span class="apidocSignatureSpan">jscs.maximum_line_length.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var maximumLineLength = this._maximumLineLength;

    var line;
    var lines = this._allowComments ?
        file.getLinesWithCommentsRemoved() : file.getLines();

    // This check should not be destructive
    lines = lines.slice();

    var removeLoc = function(tokenOrNode) {

        // Just in case (See #2107 for example)
        if (!tokenOrNode) {
            return;
        }

        for (var i = tokenOrNode.getLoc().start.line; i &lt;= tokenOrNode.getLoc().end.line; i++) {
            lines[i - 1] = '';
        }
    };

    if (this._allowRegex) {
        file.iterateTokensByType('RegularExpression', function(token) {
            removeLoc(token);
        });
    }

    if (this._allowUrlComments) {
        file.iterateTokensByType(['CommentLine', 'CommentBlock'], function(comment) {
            for (var i = comment.getLoc().start.line; i &lt;= comment.getLoc().end.line; i++) {
                lines[i - 1] = lines[i - 1].replace(/(http|https|ftp):\/\/[^\s$]+/, '');
            }
        });
    }

    if (this._allowFunctionSignature) {
        file.iterateNodesByType('FunctionDeclaration', function(node) {

            // Need to remove the first line, because we can't be sure there's any id or params
            lines[node.getLoc().start.line - 1] = '';
            removeLoc(node.id);
            node.params.forEach(removeLoc);
        });

        file.iterateNodesByType('ClassMethod', function(node) {
            removeLoc(node.key);
        });

        file.iterateNodesByType(['ArrowFunctionExpression', 'FunctionExpression'], function(node) {

            // Need to remove the first line, because we can't be sure there's any id or params
            lines[node.getLoc().start.line - 1] = '';
            removeLoc(node.id);
            node.params.forEach(removeLoc);
        });
    }

    if (this._allowRequire) {
        file.iterateNodesByType('CallExpression', function(node) {
            if (node.callee.name === 'require') {
                removeLoc(node);
            }
        });
    }

    for (var i = 0, l = lines.length; i &lt; l; i++) {
        line = this._tabSize ? lines[i].replace(/\t/g, this._tabSize) : lines[i];

        if (line.length &gt; maximumLineLength) {
            errors.add(
                'Line must be at most ' + maximumLineLength + ' characters',
                file.getLastTokenOnLine(i + 1, { includeComments: true })
            );
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.maximum_line_length.prototype.configure" id="apidoc.element.jscs.maximum_line_length.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.maximum_line_length.prototype.</span>configure
        <span class="apidocSignatureSpan">(maximumLineLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (maximumLineLength) {
    this._tabSize = '';
    this._allowRegex = false;
    this._allowComments = false;
    this._allowUrlComments = false;
    this._allowRequire = false;

    if (typeof maximumLineLength === 'object') {
        assert(
            typeof maximumLineLength.value === 'number',
            this.getOptionName() + ' option requires the "value" property to be defined'
        );

        this._maximumLineLength = maximumLineLength.value;
        var tabSize = maximumLineLength.tabSize || 0;

        while (tabSize--) {
            this._tabSize += ' ';
        }

        var exceptions = maximumLineLength.allExcept || [];
        this._allowRegex = (exceptions.indexOf('regex') !== -1);
        this._allowComments = (exceptions.indexOf('comments') !== -1);
        this._allowUrlComments = (exceptions.indexOf('urlComments') !== -1);
        this._allowFunctionSignature = (exceptions.indexOf('functionSignature') !== -1);
        this._allowRequire = (exceptions.indexOf('require') !== -1);

        if (maximumLineLength.hasOwnProperty('allowRegex')) {
            this._allowRegex = (maximumLineLength.allowRegex === true);
        }
        if (maximumLineLength.hasOwnProperty('allowComments')) {
            this._allowComments = (maximumLineLength.allowComments === true);
        }
        if (maximumLineLength.hasOwnProperty('allowUrlComments')) {
            this._allowUrlComments = (maximumLineLength.allowUrlComments === true);
        }

    } else {
        assert(
            typeof maximumLineLength === 'number',
            this.getOptionName() + ' option requires number value or options object'
        );

        this._maximumLineLength = maximumLineLength;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.maximum_line_length.prototype.getOptionName" id="apidoc.element.jscs.maximum_line_length.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.maximum_line_length.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'maximumLineLength';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.maximum_number_of_lines" id="apidoc.module.jscs.maximum_number_of_lines">module jscs.maximum_number_of_lines</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.maximum_number_of_lines.maximum_number_of_lines" id="apidoc.element.jscs.maximum_number_of_lines.maximum_number_of_lines">
        function <span class="apidocSignatureSpan">jscs.</span>maximum_number_of_lines
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maximum_number_of_lines = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.maximum_number_of_lines.prototype" id="apidoc.module.jscs.maximum_number_of_lines.prototype">module jscs.maximum_number_of_lines.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.maximum_number_of_lines.prototype.check" id="apidoc.element.jscs.maximum_number_of_lines.prototype.check">
        function <span class="apidocSignatureSpan">jscs.maximum_number_of_lines.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var firstToken = file.getFirstToken({includeComments: true});
    var lines = this._allowComments ?
         file.getLines() : file.getLinesWithCommentsRemoved();

    lines = lines.filter(function(line) {return line !== '';});

    if (lines.length &gt; this._maximumNumberOfLines) {
        errors.add(
            'File must be at most ' + this._maximumNumberOfLines + ' lines long',
            firstToken,
            firstToken.value.length
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.maximum_number_of_lines.prototype.configure" id="apidoc.element.jscs.maximum_number_of_lines.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.maximum_number_of_lines.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    this._allowComments = true;

    if (typeof options === 'number') {
        assert(
            typeof options === 'number',
            this.getOptionName() + ' option requires number value or options object'
        );
        this._maximumNumberOfLines = options;
    } else {
        assert(
            typeof options.value === 'number',
            this.getOptionName() + ' option requires the "value" property to be defined'
        );
        this._maximumNumberOfLines = options.value;

        var exceptions = options.allExcept || [];
        this._allowComments = (exceptions.indexOf('comments') === -1);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.maximum_number_of_lines.prototype.getOptionName" id="apidoc.element.jscs.maximum_number_of_lines.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.maximum_number_of_lines.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'maximumNumberOfLines';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.node_configuration" id="apidoc.module.jscs.node_configuration">module jscs.node_configuration</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.node_configuration.node_configuration" id="apidoc.element.jscs.node_configuration.node_configuration">
        function <span class="apidocSignatureSpan">jscs.</span>node_configuration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodeConfiguration() {
    Configuration.call(this);
    this._basePath = process.cwd();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.node_configuration.super_" id="apidoc.element.jscs.node_configuration.super_">
        function <span class="apidocSignatureSpan">jscs.node_configuration.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Configuration() {
<span class="apidocCodeCommentSpan">    /**
     * List of the registered (not used) presets.
     *
     * @protected
     * @type {Object}
     */
</span>    this._presets = {};

    /**
     * Name of the preset (if used).
     *
     * @protected
     * @type {String|null}
     */
    this._presetName = null;

    /**
     * List of loaded presets.
     *
     * @protected
     * @type {String|null}
     */
    this._loadedPresets = [];

    /**
     * List of rules instances.
     *
     * @protected
     * @type {Object}
     */
    this._rules = {};

    /**
     * List of configurated rule instances.
     *
     * @protected
     * @type {Object}
     */
    this._ruleSettings = {};

    /**
     * List of configured rules.
     *
     * @protected
     * @type {Array}
     */
    this._configuredRules = [];

    /**
     * List of unsupported rules.
     *
     * @protected
     * @type {Array}
     */
    this._unsupportedRuleNames = [];

    /**
     * File extensions that would be checked.
     *
     * @protected
     * @type {Array}
     */
    this._fileExtensions = [];

    /**
     * List of defined options (not complete).
     *
     * @protected
     * @type {Array}
     */
    this._definedOptions = [];

    /**
     * Default file extensions that would be checked.
     *
     * @protected
     * @type {Array}
     */
    this._defaultFileExtensions = ['.js'];

    /**
     * Exclusion masks.
     *
     * @protected
     * @type {Array}
     */
    this._excludedFileMasks = [];

    /**
     * Default exclusion masks, will be rewritten if user has their own masks.
     *
     * @protected
     * @type {Array}
     */
    this._defaultExcludedFileMasks = ['.git/**', 'node_modules/**'];

    /**
     * List of existing files that falls under exclusion masks.
     *
     * @protected
     * @type {Array}
     */
    this._excludedFileMatchers = [];

    /**
     * Extraction masks.
     *
     * @protected
     * @type {Array}
     */
    this._extractFileMasks = [];

    /**
     * Default extractions masks.
     *
     * @protected
     * @type {Array}
     */
    this._defaultExtractFileMasks = ['**/*.+(htm|html|xhtml)'];

    /**
     * List of file matchers from which to extract JavaScript.
     *
     * @protected
     * @type {Array}
     */
    this._extractFileMatchers = [];

    /**
     * Maxixum amount of error that would be reportered.
     *
     * @protected
     * @type {Number}
     */
    this._maxErrors = defaults.maxErrors;

    /**
     * JSCS CWD.
     *
     * @protected
     * @type {String}
     */
    this._basePath = defaults.cwd;

    /**
     * List of overrided options (usually from CLI).
     *
     * @protected
     * @type {Object}
     */
    this._overrides = {};

    /**
     * Is "ES3" mode enabled?.
     *
     * @protected
     * @type {Boolean}
     */
    this._es3Enabled = false;

    /**
     * A filter function that determines whether or not to report an error.
     *
     * @protected
     * @type {Function|null}
     */
    this._errorFilter = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.node_configuration.prototype" id="apidoc.module.jscs.node_configuration.prototype">module jscs.node_configuration.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.node_configuration.prototype._loadAdditionalRule" id="apidoc.element.jscs.node_configuration.prototype._loadAdditionalRule">
        function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>_loadAdditionalRule
        <span class="apidocSignatureSpan">(additionalRule, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadAdditionalRule = function (additionalRule, config) {
    config = config || this._basePath;

    if (typeof additionalRule === 'string') {
        if (glob.hasMagic(additionalRule)) {

            // In some cases there might not be a config
            // like if options are defined through direct initialization (grunt plugin case)
            config = fs.statSync(config).isDirectory() ? config : path.dirname(config);

            glob.sync(path.resolve(config, additionalRule)).forEach(function(p) {
                var Rule = require(p);
                Configuration.prototype._loadAdditionalRule.call(this, new Rule());
            }, this);
        } else {
            var Rule = this.loadExternal(additionalRule, 'rule', config);
            Configuration.prototype._loadAdditionalRule.call(this, new Rule());
        }
    } else {
        Configuration.prototype._loadAdditionalRule.call(this, additionalRule);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this._definedOptions.push('plugins');
    }
}

if (options.hasOwnProperty('additionalRules')) {
    assert(Array.isArray(options.additionalRules), '`additionalRules` option requires array value');
    options.additionalRules.forEach(function(rule) {
        this.<span class="apidocCodeKeywordSpan">_loadAdditionalRule</span>(rule, options.configPath);
    }, this);

    if (!this._isDefined('additionalRules')) {
        this._definedOptions.push('additionalRules');
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.node_configuration.prototype._loadErrorFilter" id="apidoc.element.jscs.node_configuration.prototype._loadErrorFilter">
        function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>_loadErrorFilter
        <span class="apidocSignatureSpan">(filter, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadErrorFilter = function (filter, config) {
    Configuration.prototype._loadErrorFilter.call(
        this,
        this.loadExternal(filter, 'errorFilter', config)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._loadMaxError(options);

if (options.hasOwnProperty('es3')) {
    this._loadES3(options.es3);
}

if (options.hasOwnProperty('errorFilter')) {
    this.<span class="apidocCodeKeywordSpan">_loadErrorFilter</span>(options.errorFilter, options.configPath);
}

// Apply presets
if (options.hasOwnProperty('preset')) {
    this._loadPreset(options.preset, options.configPath);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.node_configuration.prototype._loadPlugin" id="apidoc.element.jscs.node_configuration.prototype._loadPlugin">
        function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>_loadPlugin
        <span class="apidocSignatureSpan">(plugin, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadPlugin = function (plugin, config) {
    if (typeof plugin !== 'function') {
        plugin = this.loadExternal(plugin, 'plugin', config);
    }

    return Configuration.prototype._loadPlugin.call(this, plugin);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    );
    this._basePath = path.dirname(options.configPath);
}

if (options.hasOwnProperty('plugins')) {
    assert(Array.isArray(options.plugins), '`plugins` option requires array value');
    options.plugins.forEach(function(plugin) {
        this.<span class="apidocCodeKeywordSpan">_loadPlugin</span>(plugin, options.configPath);
    }, this);

    if (!this._isDefined('plugins')) {
        this._definedOptions.push('plugins');
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.node_configuration.prototype._loadPreset" id="apidoc.element.jscs.node_configuration.prototype._loadPreset">
        function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>_loadPreset
        <span class="apidocSignatureSpan">(preset, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadPreset = function (preset, config) {
    var name = path.basename(preset).split('.')[0];

    try {
        this.registerPreset(name, this.loadExternal(preset, 'preset', config));
    } catch (e) {
        var registeredPresets = this.getRegisteredPresets();

        if (preset in registeredPresets) {
            Configuration.prototype._loadPreset.call(this, preset);
            return;
        }
    }

    // If preset is an external module, error will be thrown by the caller
    Configuration.prototype._loadPreset.call(this, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   if (options.hasOwnProperty('errorFilter')) {
       this._loadErrorFilter(options.errorFilter, options.configPath);
   }

   // Apply presets
   if (options.hasOwnProperty('preset')) {
       this.<span class="apidocCodeKeywordSpan">_loadPreset</span>(options.preset, options.configPath);
   }

   this._loadRules(currentConfig);
};

/**
* Loads plugin data.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.node_configuration.prototype.loadExternal" id="apidoc.element.jscs.node_configuration.prototype.loadExternal">
        function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>loadExternal
        <span class="apidocSignatureSpan">(external, type, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadExternal = function (external, type, config) {
    assert(
        typeof external === 'string' || external === null,
        '"' + type + '" option requires a string or null value'
    );

    if (external === null) {
        return null;
    }

    var dir = config ? path.dirname(config) : this._basePath;
    var get = function(prefix, postfix) {
        prefix = prefix || '';
        postfix = postfix || '';

        try {
            return finder(
                utils.normalizePath(prefix + external + postfix, dir),
                dir
            );
        } catch (e) {}

        return null;
    }.bind(this);

    var finder;
    if (type === 'preset') {
        finder = configFinder.getContent;

    } else {
        finder = req;
    }

    var content;

    if (external.indexOf('jscs-') !== 0) {
        content = get('jscs-');

        if (!content &amp;&amp; type === 'preset') {
            content = get('jscs-preset-') || get('jscs-config-');

            if (!content &amp;&amp; external.indexOf('/') !== -1 &amp;&amp; !external.split('.')[1]) {
                content = get('jscs-', '.json') ||
                    get('jscs-', '.js') ||
                    get('jscs-preset-', '.json') ||
                    get('jscs-config-', '.json') ||
                    get('jscs-preset-', '.js') ||
                    get('jscs-config-', '.js');
            }
        }
    }

    return content || get();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @param {String|function(Configuration)} plugin
* @param {String} [config] - path to config relative to which plugin will be loaded
* @protected
*/
NodeConfiguration.prototype._loadPlugin = function(plugin, config) {
   if (typeof plugin !== 'function') {
       plugin = this.<span class="apidocCodeKeywordSpan">loadExternal</span>(plugin, 'plugin', config);
   }

   return Configuration.prototype._loadPlugin.call(this, plugin);
};

/**
* Loads preset.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.node_configuration.prototype.overrideFromCLI" id="apidoc.element.jscs.node_configuration.prototype.overrideFromCLI">
        function <span class="apidocSignatureSpan">jscs.node_configuration.prototype.</span>overrideFromCLI
        <span class="apidocSignatureSpan">(program)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">overrideFromCLI = function (program) {
    var overrides = {};

    OVERRIDE_OPTIONS.forEach(function(option) {
        if (option in program) {
            overrides[option] = program[option];
        }
    });

    this.override(overrides);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// To run autoconfigure over all errors in the path
if (program.autoConfigure) {
    program.maxErrors = Infinity;
}

checker.getConfiguration().<span class="apidocCodeKeywordSpan">overrideFromCLI</span>(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.configure(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_aligned_multiline_params" id="apidoc.module.jscs.require_aligned_multiline_params">module jscs.require_aligned_multiline_params</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_aligned_multiline_params.require_aligned_multiline_params" id="apidoc.element.jscs.require_aligned_multiline_params.require_aligned_multiline_params">
        function <span class="apidocSignatureSpan">jscs.</span>require_aligned_multiline_params
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_aligned_multiline_params = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_aligned_multiline_params.prototype" id="apidoc.module.jscs.require_aligned_multiline_params.prototype">module jscs.require_aligned_multiline_params.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_aligned_multiline_params.prototype.check" id="apidoc.element.jscs.require_aligned_multiline_params.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_aligned_multiline_params.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var _this = this;
    file.iterateNodesByType(['FunctionDeclaration', 'FunctionExpression'], function(node) {
        var params = node.params;

        // We can pass the check if there's no params
        if (params.length === 0) {
            return;
        }

        var firstParam = params[0];
        var referenceColumn;
        var body;

        if (_this._alignWithFirstParam) {
            referenceColumn = getNodeColumn(firstParam);
        } else {

            body = node.body.body[0];

            // If function doesn't have a body just bail out (#1988)
            if (!body) {
                return;
            }

            referenceColumn = body.getLoc().start.column + _this._indentationLevel;
        }

        var previousParam = firstParam;
        params.slice(1).forEach(function(param) {
            if (!file.isOnTheSameLine(previousParam, param)) {
                var paramColumn = getNodeColumn(param);
                if (paramColumn !== referenceColumn) {
                    errors.assert.indentation({
                        token: param.getFirstToken(),
                        actual: paramColumn,
                        expected: referenceColumn,
                        indentChar: ' '
                    });
                }

                previousParam = param;
            }
        });

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_aligned_multiline_params.prototype.configure" id="apidoc.element.jscs.require_aligned_multiline_params.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_aligned_multiline_params.prototype.</span>configure
        <span class="apidocSignatureSpan">(option)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (option) {
    if (typeof option === 'number') {
        this._indentationLevel = option;
    } else if (typeof option === 'string') {
        assert(
            option === 'firstParam',
            this.getOptionName() + ' option requires string value to be "firstParam"'
        );

        this._alignWithFirstParam = true;
    } else if (option === true) {
        this._indentationLevel = 0;
    } else {
        assert(
            false,
            this.getOptionName() + ' option requires a valid option'
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_aligned_multiline_params.prototype.getOptionName" id="apidoc.element.jscs.require_aligned_multiline_params.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_aligned_multiline_params.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireAlignedMultilineParams';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_aligned_object_values" id="apidoc.module.jscs.require_aligned_object_values">module jscs.require_aligned_object_values</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_aligned_object_values.require_aligned_object_values" id="apidoc.element.jscs.require_aligned_object_values.require_aligned_object_values">
        function <span class="apidocSignatureSpan">jscs.</span>require_aligned_object_values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_aligned_object_values = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_aligned_object_values.prototype" id="apidoc.module.jscs.require_aligned_object_values.prototype">module jscs.require_aligned_object_values.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_aligned_object_values.prototype.check" id="apidoc.element.jscs.require_aligned_object_values.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_aligned_object_values.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var mode = this._mode;

    file.iterateNodesByType('ObjectExpression', function(node) {
        if (node.getNewlineCount() === 0 || node.properties &lt; 2) {
            return;
        }

        var maxKeyEndPos = 0;
        var prevKeyEndPos = 0;
        var minColonPos = 0;
        var tokens = [];
        var skip = node.properties.some(function(property, index) {
            if (property.shorthand || property.method ||
                property.type === 'SpreadProperty') {
                return true;
            }

            if (mode === 'ignoreFunction' &amp;&amp; property.value.type === 'FunctionExpression') {
                return true;
            }

            if (mode === 'ignoreLineBreak' &amp;&amp; index &gt; 0 &amp;&amp;
                 node.properties[index - 1].getLoc().end.line !== property.getLoc().start.line - 1) {
                return true;
            }

            prevKeyEndPos = maxKeyEndPos;
            maxKeyEndPos = Math.max(maxKeyEndPos, property.key.getLoc().end.column);
            var keyToken = file.getFirstNodeToken(property.key);
            if (property.computed === true) {
                while (keyToken.value !== ']') {
                    keyToken = file.getNextToken(keyToken);
                }
            }
            var colon = file.getNextToken(keyToken);
            if (prevKeyEndPos &lt; maxKeyEndPos) {
                minColonPos = colon.getLoc().start.column;
            }
            tokens.push({key: keyToken, colon: colon});
        });

        if (skip) {
            return;
        }

        var space = minColonPos - maxKeyEndPos;
        tokens.forEach(function(pair) {
            errors.assert.spacesBetween({
                token: pair.key,
                nextToken: pair.colon,
                exactly: maxKeyEndPos - pair.key.getLoc().end.column + space,
                message: 'Alignment required'
            });
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_aligned_object_values.prototype.configure" id="apidoc.element.jscs.require_aligned_object_values.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_aligned_object_values.prototype.</span>configure
        <span class="apidocSignatureSpan">(mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (mode) {
    var modes = {
        'all': 'all',
        'ignoreFunction': 'ignoreFunction',
        'ignoreLineBreak': 'ignoreLineBreak',
        'skipWithFunction': 'ignoreFunction',
        'skipWithLineBreak': 'ignoreLineBreak'
    };
    assert(
        typeof mode === 'string' &amp;&amp; modes[mode],
        this.getOptionName() + ' requires one of the following values: ' + Object.keys(modes).join(', ')
    );
    this._mode = modes[mode];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_aligned_object_values.prototype.getOptionName" id="apidoc.element.jscs.require_aligned_object_values.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_aligned_object_values.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireAlignedObjectValues';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_anonymous_functions" id="apidoc.module.jscs.require_anonymous_functions">module jscs.require_anonymous_functions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_anonymous_functions.require_anonymous_functions" id="apidoc.element.jscs.require_anonymous_functions.require_anonymous_functions">
        function <span class="apidocSignatureSpan">jscs.</span>require_anonymous_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_anonymous_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_anonymous_functions.prototype" id="apidoc.module.jscs.require_anonymous_functions.prototype">module jscs.require_anonymous_functions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_anonymous_functions.prototype.check" id="apidoc.element.jscs.require_anonymous_functions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_anonymous_functions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptDeclarations = this._exceptDeclarations;

    file.iterateNodesByType(['FunctionExpression', 'FunctionDeclaration'], function(node) {
        if (exceptDeclarations &amp;&amp; node.type === 'FunctionDeclaration') {
            return;
        }
        if (node.id !== null) {
            errors.add('Functions must not be named', node);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_anonymous_functions.prototype.configure" id="apidoc.element.jscs.require_anonymous_functions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_anonymous_functions.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var optionName = this.getOptionName();

    if (typeof options === 'object') {
        assert(Array.isArray(options.allExcept), optionName + ' option requires "allExcept" to be an array');
        assert(options.allExcept.length &gt; 0, optionName + ' option requires "allExcept" to have at least one ' +
        ' item or be set to `true`');
        this._exceptDeclarations = options.allExcept.indexOf('declarations') &gt; -1;
    } else {
        assert(options === true, this.getOptionName() + ' option requires either a true value or an object');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_anonymous_functions.prototype.getOptionName" id="apidoc.element.jscs.require_anonymous_functions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_anonymous_functions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireAnonymousFunctions';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_array_destructuring" id="apidoc.module.jscs.require_array_destructuring">module jscs.require_array_destructuring</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_array_destructuring.require_array_destructuring" id="apidoc.element.jscs.require_array_destructuring.require_array_destructuring">
        function <span class="apidocSignatureSpan">jscs.</span>require_array_destructuring
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_array_destructuring = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_array_destructuring.prototype" id="apidoc.module.jscs.require_array_destructuring.prototype">module jscs.require_array_destructuring.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_array_destructuring.prototype.check" id="apidoc.element.jscs.require_array_destructuring.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_array_destructuring.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('VariableDeclaration', function(node) {

        node.declarations.forEach(function(declaration) {
            if (!declaration.init || declaration.init.type !== 'MemberExpression') {
                return;
            }

            var property = declaration.init.property || {};
            if (property.type.indexOf('Literal') &gt; -1 &amp;&amp; /^\d+$/.test(property.value)) {
                errors.add('Use array destructuring', property);
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_array_destructuring.prototype.configure" id="apidoc.element.jscs.require_array_destructuring.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_array_destructuring.prototype.</span>configure
        <span class="apidocSignatureSpan">(option)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (option) {
    assert(option === true, this.getOptionName() + ' requires a true value');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_array_destructuring.prototype.getOptionName" id="apidoc.element.jscs.require_array_destructuring.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_array_destructuring.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireArrayDestructuring';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_arrow_functions" id="apidoc.module.jscs.require_arrow_functions">module jscs.require_arrow_functions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_arrow_functions.require_arrow_functions" id="apidoc.element.jscs.require_arrow_functions.require_arrow_functions">
        function <span class="apidocSignatureSpan">jscs.</span>require_arrow_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_arrow_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_arrow_functions.prototype" id="apidoc.module.jscs.require_arrow_functions.prototype">module jscs.require_arrow_functions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_arrow_functions.prototype.check" id="apidoc.element.jscs.require_arrow_functions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_arrow_functions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {

    function isCallback(node) {
        return node.type === 'FunctionExpression' &amp;&amp; node.parentElement.type === 'CallExpression';
    }

    function isFunctionBindWithThis(node) {
        return node.callee &amp;&amp;
        node.callee.type === 'MemberExpression' &amp;&amp;
        node.callee.object.type === 'FunctionExpression' &amp;&amp;
        node.callee.property.type === 'Identifier' &amp;&amp;
        node.callee.property.name === 'bind' &amp;&amp;
        node.arguments &amp;&amp;
        node.arguments.length === 1 &amp;&amp; node.arguments[0].type === 'ThisExpression';
    }

    file.iterateNodesByType(['FunctionExpression', 'CallExpression'], function(node) {
        if (isCallback(node) || isFunctionBindWithThis(node)) {
            errors.add('Use arrow functions instead of function expressions', node);
        }

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_arrow_functions.prototype.configure" id="apidoc.element.jscs.require_arrow_functions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_arrow_functions.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_arrow_functions.prototype.getOptionName" id="apidoc.element.jscs.require_arrow_functions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_arrow_functions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireArrowFunctions';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_blocks_on_newline" id="apidoc.module.jscs.require_blocks_on_newline">module jscs.require_blocks_on_newline</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_blocks_on_newline.require_blocks_on_newline" id="apidoc.element.jscs.require_blocks_on_newline.require_blocks_on_newline">
        function <span class="apidocSignatureSpan">jscs.</span>require_blocks_on_newline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_blocks_on_newline = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_blocks_on_newline.prototype" id="apidoc.module.jscs.require_blocks_on_newline.prototype">module jscs.require_blocks_on_newline.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_blocks_on_newline.prototype.check" id="apidoc.element.jscs.require_blocks_on_newline.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_blocks_on_newline.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var minLines = this._minLines;
    var includeComments = this._includeComments;

    file.iterateNodesByType('BlockStatement', function(node) {
        var hasComment = false;
        if (includeComments === true) {
            hasComment = hasCommentInBlock(node);
        }

        if (hasComment === false &amp;&amp; node.body.length &lt;= minLines) {
            return;
        }

        var openingBracket = node.getFirstToken();
        var nextToken = file.getNextToken(openingBracket, { includeComments: includeComments });

        errors.assert.differentLine({
            token: openingBracket,
            nextToken: nextToken,
            message: 'Missing newline after opening curly brace'
        });

        var closingBracket = file.getLastNodeToken(node);
        var prevToken = file.getPrevToken(closingBracket, { includeComments: includeComments });

        errors.assert.differentLine({
            token: prevToken,
            nextToken: closingBracket,
            message: 'Missing newline before closing curly brace'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_blocks_on_newline.prototype.configure" id="apidoc.element.jscs.require_blocks_on_newline.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_blocks_on_newline.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var optionType = typeof options;
    assert(
        options === true || optionType === 'number' || optionType === 'object',
        this.getOptionName() + ' option requires the value true, an Integer or an object'
    );

    this._minLines = 0;
    this._includeComments = false;
    if (optionType === 'number') {
        this._minLines = options;
    } else if (optionType === 'object') {
        assert(
            options.includeComments === true,
            this.getOptionName() + ' option requires includeComments property to be true for object'
        );
        this._includeComments = options.includeComments;

        if (options.hasOwnProperty('minLines')) {
            assert(
                typeof options.minLines === 'number',
                this.getOptionName() + ' option requires minLines property to be an integer for object'
            );
            this._minLines = options.minLines;
        }
    }

    assert(
        this._minLines &gt;= 0,
        this.getOptionName() + ' option requires minimum statements setting to be &gt;= 0'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_blocks_on_newline.prototype.getOptionName" id="apidoc.element.jscs.require_blocks_on_newline.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_blocks_on_newline.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireBlocksOnNewline';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_camelcase_or_uppercase_identifiers" id="apidoc.module.jscs.require_camelcase_or_uppercase_identifiers">module jscs.require_camelcase_or_uppercase_identifiers</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.require_camelcase_or_uppercase_identifiers" id="apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.require_camelcase_or_uppercase_identifiers">
        function <span class="apidocSignatureSpan">jscs.</span>require_camelcase_or_uppercase_identifiers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_camelcase_or_uppercase_identifiers = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_camelcase_or_uppercase_identifiers.prototype" id="apidoc.module.jscs.require_camelcase_or_uppercase_identifiers.prototype">module jscs.require_camelcase_or_uppercase_identifiers.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.check" id="apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_camelcase_or_uppercase_identifiers.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByType('Identifier', function(token) {
        var value = token.value;

        // Leading and trailing underscores signify visibility/scope and do not affect
        // validation of the rule.  Remove them to simplify the checks.
        var isPrivate = (value[0] === '_');
        value = value.replace(/^_+|_+$/g, '');

        // Detect exceptions before stripping prefixes/suffixes.
        if (this._allExcept) {
            for (i = 0, len = this._allExcept.length; i &lt; len; ++i) {
                if (matchException(value, this._allExcept[i])) {
                    return;
                }
            }
        }

        // Strip at most one prefix permitted text from the identifier.  This transformation
        // cannot change an acceptable identifier into an unacceptable identifier so we can
        // continue with the normal verification of whatever it produces.
        var i;
        var len;
        if (this._allowedPrefixes) {
            for (i = 0, len = this._allowedPrefixes.length; i &lt; len; ++i) {
                var prefix = this._allowedPrefixes[i];
                var start;
                if (typeof prefix === 'string') {
                    start = startAfterStringPrefix(value, prefix);
                } else {
                    start = startAfterRegExpPrefix(value, prefix);
                }
                if (start !== undefined) {
                    value = value.substr(start);
                    break;
                }
            }
        }

        // As with prefix but for one suffix permitted text.
        if (this._allowedSuffixes) {
            for (i = 0, len = this._allowedSuffixes.length; i &lt; len; ++i) {
                var suffix = this._allowedSuffixes[i];
                var ends;
                if (typeof suffix === 'string') {
                    ends = endBeforeStringSuffix(value, suffix);
                } else {
                    ends = endBeforeRegExpSuffix(value, suffix);
                }
                if (ends !== undefined) {
                    value = value.substr(0, ends);
                    break;
                }
            }
        }

        if (value.indexOf('_') === -1 || value.toUpperCase() === value) {
            if (!this._strict) {return;}
            if (value.length === 0 || value[0].toUpperCase() !== value[0] || isPrivate) {
                return;
            }
        }
        if (this._ignoreProperties) {
            var nextToken = file.getNextToken(token);
            var prevToken = token.getPreviousCodeToken();

            if (nextToken &amp;&amp; nextToken.value === ':') {
                return;
            }

<span class="apidocCodeCommentSpan">            /* This enables an identifier to be snake cased via the object
             * destructuring pattern. We must check to see if the identifier
             * is being used to set values into an object to determine if
             * this is a legal assignment.
             * Example: ({camelCase: snake_case}) =&gt; camelCase.length
             */
</span>            if (prevToken &amp;&amp; prevToken.value === ':') {
                var node = token.parentElement;
                var parentElement = node.parentElement;
                if (parentElement &amp;&amp; parentElement.type === 'ObjectProperty') {
                    var grandpa = parentElement.parentElement;
                    if (grandpa &amp;&amp; grandpa.type === 'ObjectPattern') {
                        return;
                    }
                }
            }

            if (prevToken &amp;&amp; (prevToken.value === '.' ||
                prevToken.value === 'get' || prevToken.value === 'set')) {
                return;
            }
        }
        errors.add(
            'All identifiers must be camelCase or UPPER_CASE',
            token
        );
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.configure" id="apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_camelcase_or_uppercase_identifiers.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    if (typeof options !== 'object') {
        assert(
          options === true || options === 'ignoreProperties',
          this.getOptionName() + ' option requires a true value or `ignoreProperties`'
        );
        var _options = {
            ignoreProperties: options === 'ignoreProperties' ? true : false,
            strict: false
        };
        return this.configure(_options);
    }

    assert(
      !options.hasOwnProperty('ignoreProperties') || typeof options.ignoreProperties === 'boolean',
      this.getOptionName() + ' option should have boolean value for ignoreProperties'
    );
    this._ignoreProperties = options.ignoreProperties;

    assert(
      !options.hasOwnProperty('strict') || typeof options.strict === 'boolean',
      this.getOptionName() + ' option should have boolean value for strict'
    );
    this._strict = options.strict;

    var asre = processArrayOfStringOrRegExp(options.allowedPrefixes);
    assert(
      !options.hasOwnProperty('allowedPrefixes') || asre,
      this.getOptionName() + ' option should have array of string or RegExp for allowedPrefixes'
    );
    if (asre) {
        this._allowedPrefixes = asre;
    }

    asre = processArrayOfStringOrRegExp(options.allowedSuffixes);
    assert(
      !options.hasOwnProperty('allowedSuffixes') || asre,
      this.getOptionName() + ' option should have array of string or RegExp for allowedSuffixes'
    );
    if (asre) {
        this._allowedSuffixes = asre;
    }

    asre = processArrayOfStringOrRegExp(options.allExcept);
    assert(
      !options.hasOwnProperty('allExcept') || asre,
      this.getOptionName() + ' option should have array of string or RegExp for allExcept'
    );
    if (asre) {
        this._allExcept = asre;
    }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.getOptionName" id="apidoc.element.jscs.require_camelcase_or_uppercase_identifiers.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_camelcase_or_uppercase_identifiers.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireCamelCaseOrUpperCaseIdentifiers';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_capitalized_comments" id="apidoc.module.jscs.require_capitalized_comments">module jscs.require_capitalized_comments</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.require_capitalized_comments" id="apidoc.element.jscs.require_capitalized_comments.require_capitalized_comments">
        function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_capitalized_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_capitalized_comments.prototype" id="apidoc.module.jscs.require_capitalized_comments.prototype">module jscs.require_capitalized_comments.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype._fix" id="apidoc.element.jscs.require_capitalized_comments.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var comment = error.additional;
    var first = this._getFirstChar(comment);

    var newValue = comment.value.replace(first, first.toUpperCase());
    var newComment = new cst.Token(comment.type, newValue);

    comment.parentElement.replaceChild(newComment, comment);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &amp;&amp; instance._fix) {
        // "error.fixed = true" should go first, so rule can
        // decide for itself (with "error.fixed = false")
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype._getFirstChar" id="apidoc.element.jscs.require_capitalized_comments.prototype._getFirstChar">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_getFirstChar
        <span class="apidocSignatureSpan">(comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getFirstChar = function (comment) {
    return comment.value.replace(/[\n\s\*]/g, '')[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

_isException: function(comment) {
    return this._isPragma(comment.value);
},

_isValid: function(comment) {
    var first = this.<span class="apidocCodeKeywordSpan">_getFirstChar</span>(comment);

    return first &amp;&amp; upperCasePattern.test(first);
},

_isLetter: function(comment) {
    var first = this._getFirstChar(comment);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype._isException" id="apidoc.element.jscs.require_capitalized_comments.prototype._isException">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isException
        <span class="apidocSignatureSpan">(comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isException = function (comment) {
    return this._isPragma(comment.value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    message: 'Comments must start with an uppercase letter, unless it is part of a textblock',
    element: comment,
    additional: comment
});
        }

        file.iterateTokensByType('CommentLine', function(comment) {
if (_this.<span class="apidocCodeKeywordSpan">_isException</span>(comment)) {
    return;
}

if (_this._isUrl(comment)) {
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype._isLetter" id="apidoc.element.jscs.require_capitalized_comments.prototype._isLetter">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isLetter
        <span class="apidocSignatureSpan">(comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isLetter = function (comment) {
    var first = this._getFirstChar(comment);

    return first &amp;&amp; letterPattern.test(first);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
}

if (_this._isUrl(comment)) {
    return;
}

if (!_this.<span class="apidocCodeKeywordSpan">_isLetter</span>(comment)) {
    return;
}

if (_this._isTextBlock(file, comment)) {
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype._isTextBlock" id="apidoc.element.jscs.require_capitalized_comments.prototype._isTextBlock">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isTextBlock
        <span class="apidocSignatureSpan">(file, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isTextBlock = function (file, comment) {
    var prevComment = file.getPrevToken(comment, {includeComments: true});

    if (prevComment) {
        return prevComment.type === 'CommentLine' &amp;&amp;
            !file.isOnTheSameLine(comment, prevComment) &amp;&amp;
            prevComment.value.trim().length &gt; 0;
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
}

if (!_this._isLetter(comment)) {
    return;
}

if (_this.<span class="apidocCodeKeywordSpan">_isTextBlock</span>(file, comment)) {
    return;
}

if (_this._isValid(comment)) {
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype._isUrl" id="apidoc.element.jscs.require_capitalized_comments.prototype._isUrl">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isUrl
        <span class="apidocSignatureSpan">(comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isUrl = function (comment) {
    var protocolParts = comment.value.split('://');

    if (protocolParts.length === 1) {
        return false;
    }

    return comment.value.indexOf(protocolParts[0]) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }

        file.iterateTokensByType('CommentLine', function(comment) {
if (_this._isException(comment)) {
    return;
}

if (_this.<span class="apidocCodeKeywordSpan">_isUrl</span>(comment)) {
    return;
}

if (!_this._isLetter(comment)) {
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype._isValid" id="apidoc.element.jscs.require_capitalized_comments.prototype._isValid">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_isValid
        <span class="apidocSignatureSpan">(comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isValid = function (comment) {
    var first = this._getFirstChar(comment);

    return first &amp;&amp; upperCasePattern.test(first);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return;
    }

    if (_this._isTextBlock(file, comment)) {
        return;
    }

    if (_this.<span class="apidocCodeKeywordSpan">_isValid</span>(comment)) {
        return;
    }

    add(comment);
});

file.iterateTokensByType('CommentBlock', function(comment) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype._shouldIgnoreIfInTheMiddle" id="apidoc.element.jscs.require_capitalized_comments.prototype._shouldIgnoreIfInTheMiddle">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>_shouldIgnoreIfInTheMiddle
        <span class="apidocSignatureSpan">(file, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_shouldIgnoreIfInTheMiddle = function (file, comment) {
    if (!this.inlined) {
        return false;
    }

    var firstToken = comment.getFirstToken();
    var otherToken = firstToken.getPreviousNonWhitespaceToken();

    return otherToken ? file.isOnTheSameLine(otherToken, firstToken) : false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
}

if (!_this._isLetter(comment)) {
    return;
}

if (_this.<span class="apidocCodeKeywordSpan">_shouldIgnoreIfInTheMiddle</span>(file, comment)) {
    return;
}

if (_this._isValid(comment)) {
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype.check" id="apidoc.element.jscs.require_capitalized_comments.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var _this = this;

    function add(comment) {
        errors.cast({
            message: 'Comments must start with an uppercase letter, unless it is part of a textblock',
            element: comment,
            additional: comment
        });
    }

    file.iterateTokensByType('CommentLine', function(comment) {
        if (_this._isException(comment)) {
            return;
        }

        if (_this._isUrl(comment)) {
            return;
        }

        if (!_this._isLetter(comment)) {
            return;
        }

        if (_this._isTextBlock(file, comment)) {
            return;
        }

        if (_this._isValid(comment)) {
            return;
        }

        add(comment);
    });

    file.iterateTokensByType('CommentBlock', function(comment) {
        if (_this._isException(comment)) {
            return;
        }

        if (_this._isUrl(comment)) {
            return;
        }

        if (!_this._isLetter(comment)) {
            return;
        }

        if (_this._shouldIgnoreIfInTheMiddle(file, comment)) {
            return;
        }

        if (_this._isValid(comment)) {
            return;
        }

        add(comment);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype.configure" id="apidoc.element.jscs.require_capitalized_comments.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var exceptions;

    this.inlined = false;
    this._isPragma = null;

    var optionName = this.getOptionName();

    var isObject = typeof options === 'object';
    var error = optionName + ' option requires a true value ' +
        'or an object with String[] `allExcept` property or true with `inlined`';

    assert(
        options === true ||
        isObject,
        error
    );

    if (isObject &amp;&amp; options.allExcept) {
        exceptions = options.allExcept;

        // verify items in `allExcept` property in object are string values
        assert(
            Array.isArray(exceptions) &amp;&amp;
            exceptions.every(function(el) { return typeof el === 'string'; }),
            'Property `allExcept` in ' + optionName + ' should be an array of strings'
        );

        this._isPragma = isPragma(exceptions);
    }

    if (!this._isPragma) {
        this._isPragma = isPragma();
    }

    if (isObject &amp;&amp; options.inlined) {
        this.inlined = true;
    }

    if (isObject &amp;&amp; !options.allExcept &amp;&amp; !options.inlined) {
        assert(false, error);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_comments.prototype.getOptionName" id="apidoc.element.jscs.require_capitalized_comments.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_comments.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireCapitalizedComments';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_capitalized_constructors" id="apidoc.module.jscs.require_capitalized_constructors">module jscs.require_capitalized_constructors</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors.require_capitalized_constructors" id="apidoc.element.jscs.require_capitalized_constructors.require_capitalized_constructors">
        function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_capitalized_constructors = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_capitalized_constructors.prototype" id="apidoc.module.jscs.require_capitalized_constructors.prototype">module jscs.require_capitalized_constructors.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors.prototype.check" id="apidoc.element.jscs.require_capitalized_constructors.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var allowedConstructors = this._allowedConstructors;

    file.iterateNodesByType('NewExpression', function(node) {
        if (node.callee.type === 'Identifier' &amp;&amp;
            !allowedConstructors[node.callee.name] &amp;&amp;
            node.callee.name[0].toUpperCase() !== node.callee.name[0]
        ) {
            errors.add(
                'Constructor functions should be capitalized',
                node.callee
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors.prototype.configure" id="apidoc.element.jscs.require_capitalized_constructors.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || Array.isArray(options.allExcept),
        this.getOptionName() + ' option requires a true value or an object of exceptions'
    );
    this._allowedConstructors = {};

    var allExcept = options.allExcept;
    if (allExcept) {
        for (var i = 0, l = allExcept.length; i &lt; l; i++) {
            this._allowedConstructors[allExcept[i]] = true;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors.prototype.getOptionName" id="apidoc.element.jscs.require_capitalized_constructors.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireCapitalizedConstructors';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_capitalized_constructors_new" id="apidoc.module.jscs.require_capitalized_constructors_new">module jscs.require_capitalized_constructors_new</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors_new.require_capitalized_constructors_new" id="apidoc.element.jscs.require_capitalized_constructors_new.require_capitalized_constructors_new">
        function <span class="apidocSignatureSpan">jscs.</span>require_capitalized_constructors_new
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_capitalized_constructors_new = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_capitalized_constructors_new.prototype" id="apidoc.module.jscs.require_capitalized_constructors_new.prototype">module jscs.require_capitalized_constructors_new.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors_new.prototype.check" id="apidoc.element.jscs.require_capitalized_constructors_new.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors_new.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var allowedConstructors = this._allowedConstructors;

    file.iterateNodesByType('CallExpression', function(node) {
        if (node.callee.type === 'Identifier' &amp;&amp;
            !allowedConstructors[node.callee.name] &amp;&amp;
            node.callee.name[0].toLowerCase() !== node.callee.name[0]
        ) {
            errors.add(
                'Constructor functions should use the "new" keyword',
                node.callee
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors_new.prototype.configure" id="apidoc.element.jscs.require_capitalized_constructors_new.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors_new.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || Array.isArray(options.allExcept),
        this.getOptionName() + ' option requires a true value or an object of exceptions'
    );
    this._allowedConstructors = {};

    var allExcept = options.allExcept;
    if (allExcept) {
        for (var i = 0, l = allExcept.length; i &lt; l; i++) {
            this._allowedConstructors[allExcept[i]] = true;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_capitalized_constructors_new.prototype.getOptionName" id="apidoc.element.jscs.require_capitalized_constructors_new.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_capitalized_constructors_new.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireCapitalizedConstructorsNew';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_comma_before_line_break" id="apidoc.module.jscs.require_comma_before_line_break">module jscs.require_comma_before_line_break</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_comma_before_line_break.require_comma_before_line_break" id="apidoc.element.jscs.require_comma_before_line_break.require_comma_before_line_break">
        function <span class="apidocSignatureSpan">jscs.</span>require_comma_before_line_break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_comma_before_line_break = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_comma_before_line_break.prototype" id="apidoc.module.jscs.require_comma_before_line_break.prototype">module jscs.require_comma_before_line_break.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_comma_before_line_break.prototype.check" id="apidoc.element.jscs.require_comma_before_line_break.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_comma_before_line_break.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
        var prevToken = token.getPreviousCodeToken();

        if (prevToken.value === ',') {
            return;
        }
        errors.assert.sameLine({
            token: prevToken,
            nextToken: token,
            message: 'Commas should not be placed on new line'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_comma_before_line_break.prototype.configure" id="apidoc.element.jscs.require_comma_before_line_break.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_comma_before_line_break.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_comma_before_line_break.prototype.getOptionName" id="apidoc.element.jscs.require_comma_before_line_break.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_comma_before_line_break.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireCommaBeforeLineBreak';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_curly_braces" id="apidoc.module.jscs.require_curly_braces">module jscs.require_curly_braces</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_curly_braces.require_curly_braces" id="apidoc.element.jscs.require_curly_braces.require_curly_braces">
        function <span class="apidocSignatureSpan">jscs.</span>require_curly_braces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_curly_braces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_curly_braces.prototype" id="apidoc.module.jscs.require_curly_braces.prototype">module jscs.require_curly_braces.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_curly_braces.prototype.check" id="apidoc.element.jscs.require_curly_braces.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_curly_braces.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var typeIndex = this._typeIndex;
    var exceptions = this._exceptions;

    function isNotABlockStatement(node) {
        return node &amp;&amp; node.type !== 'BlockStatement';
    }

    function addError(typeString, entity) {
        errors.add(
            typeString + ' statement without curly braces',
            entity
        );
    }

    function checkBody(type, typeString) {
        file.iterateNodesByType(type, function(node) {
            if (isNotABlockStatement(node.body)) {
                addError(typeString, node);
            }
        });
    }

    if (typeIndex.if || typeIndex.else) {
        file.iterateNodesByType('IfStatement', function(node) {
            if (typeIndex.if &amp;&amp; isNotABlockStatement(node.consequent) &amp;&amp;
                // check exceptions for if and else
                !(exceptions &amp;&amp; exceptions.indexOf(node.consequent.type) !== -1)) {
                // console.log(node.firstChild.getSourceCode());
                addError('If', node.firstChild);
            }
            if (typeIndex.else &amp;&amp; isNotABlockStatement(node.alternate) &amp;&amp;
                node.alternate.type !== 'IfStatement' &amp;&amp;
                // check exceptions for if and else
                !(exceptions &amp;&amp; exceptions.indexOf(node.consequent.type) !== -1)) {
                addError('Else', node.alternate.getPreviousCodeToken());
            }
        });
    }

    if (typeIndex.case || typeIndex.default) {
        file.iterateNodesByType('SwitchCase', function(node) {
            // empty case statement
            if (node.consequent.length === 0) {
                return;
            }

            if (node.consequent.length === 1 &amp;&amp; node.consequent[0].type === 'BlockStatement') {
                return;
            }

            if (node.test === null &amp;&amp; typeIndex.default) {
                addError('Default', node);
            }

            if (node.test !== null &amp;&amp; typeIndex.case) {
                addError('Case', node);
            }
        });
    }

    if (typeIndex.while) {
        checkBody('WhileStatement', 'While');
    }

    if (typeIndex.for) {
        checkBody('ForStatement', 'For');
        checkBody('ForInStatement', 'For in');
        checkBody('ForOfStatement', 'For of');
    }

    if (typeIndex.do) {
        checkBody('DoWhileStatement', 'Do while');
    }

    if (typeIndex.with) {
        checkBody('WithStatement', 'With');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_curly_braces.prototype.configure" id="apidoc.element.jscs.require_curly_braces.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_curly_braces.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        Array.isArray(options) || options === true || typeof options === 'object',
        this.getOptionName() + ' option requires array, true value, or object'
    );

    var keywordMap = {
        'return': 'ReturnStatement',
        'break': 'BreakStatement',
        'continue': 'ContinueStatement'
    };

    if (options === true) {
        options = defaultKeywords;
    }

    if (!Array.isArray(options)) {
        assert(
            Array.isArray(options.allExcept),
            this.getOptionName() + '.allExcept ' +
            'property requires an array value'
        );
        assert(
            Array.isArray(options.keywords) || options.keywords === true,
            this.getOptionName() + '.keywords ' +
            'property requires an array value or a value of true'
        );

        if (options.keywords === true) {
            options.keywords = defaultKeywords;
        }

        this._exceptions = options.allExcept.map(function(statementType) {
            return keywordMap[statementType];
        });
        options = options.keywords;
    }

    this._typeIndex = {};
    for (var i = 0, l = options.length; i &lt; l; i++) {
        this._typeIndex[options[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_curly_braces.prototype.getOptionName" id="apidoc.element.jscs.require_curly_braces.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_curly_braces.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireCurlyBraces';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_dollar_before_jquery_assignment" id="apidoc.module.jscs.require_dollar_before_jquery_assignment">module jscs.require_dollar_before_jquery_assignment</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_dollar_before_jquery_assignment.require_dollar_before_jquery_assignment" id="apidoc.element.jscs.require_dollar_before_jquery_assignment.require_dollar_before_jquery_assignment">
        function <span class="apidocSignatureSpan">jscs.</span>require_dollar_before_jquery_assignment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_dollar_before_jquery_assignment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_dollar_before_jquery_assignment.prototype" id="apidoc.module.jscs.require_dollar_before_jquery_assignment.prototype">module jscs.require_dollar_before_jquery_assignment.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.check" id="apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_dollar_before_jquery_assignment.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var ignoreProperties = this._ignoreProperties;

    file.iterateNodesByType(['VariableDeclarator', 'AssignmentExpression', 'ObjectExpression'], function(node) {
        var type = node.type;
        var left;
        var varName;
        var right;

        function checkIfVarNameShouldStartWithDollar(varName, left, right) {

            if (/^_?\$/.test(varName)) {
                return;
            }

            if (!right || right.type !== 'CallExpression') {
                return;
            }

            var nextToken = right.callee.firstChild;
            if (nextToken.value !== '$') {
                return;
            }

            nextToken = file.getNextToken(nextToken);
            if (nextToken.value !== '(') {
                return;
            }

            while (!(nextToken.type === 'Punctuator' &amp;&amp; nextToken.value === ')')) {
                nextToken = file.getNextToken(nextToken);
            }

            nextToken = file.getNextToken(nextToken);
            if (!nextToken || !(nextToken.type === 'Punctuator' &amp;&amp; nextToken.value === '.')) {
                errors.add(
                    'jQuery identifiers must start with a $',
                    left
                );
            }
        }

        if (type === 'VariableDeclarator') {
            if (node.id.type === 'ObjectPattern' || node.id.type === 'ArrayPattern') {
                return;
            }

            left = node.id;
            varName = left.name;
            right = node.init;
            checkIfVarNameShouldStartWithDollar(varName, left, right);
        } else if (ignoreProperties) {
            return;

        } else if (type === 'AssignmentExpression') {
            left = node.left;
            if (left.computed || left.type === 'ArrayPattern') {
                return;
            }

            varName = left.name || left.property.name;
            right = node.right;
            checkIfVarNameShouldStartWithDollar(varName, left, right);
        } else {// type === 'ObjectExpression'
            var props = node.properties;

            if (!props) {
                return;
            }

            props.forEach(function(prop) {
                left = prop.key;

                if (!left || !left.name) {
                    return;
                }

                varName = left.name;
                right = prop.value;
                checkIfVarNameShouldStartWithDollar(varName, left, right);
            });
        }

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.configure" id="apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_dollar_before_jquery_assignment.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || options === 'ignoreProperties',
        this.getOptionName() + ' option requires true or "ignoreProperties" value, or should be removed'
    );

    this._ignoreProperties = (options === 'ignoreProperties');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.getOptionName" id="apidoc.element.jscs.require_dollar_before_jquery_assignment.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_dollar_before_jquery_assignment.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireDollarBeforejQueryAssignment';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_dot_notation" id="apidoc.module.jscs.require_dot_notation">module jscs.require_dot_notation</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_dot_notation.require_dot_notation" id="apidoc.element.jscs.require_dot_notation.require_dot_notation">
        function <span class="apidocSignatureSpan">jscs.</span>require_dot_notation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_dot_notation = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_dot_notation.prototype" id="apidoc.module.jscs.require_dot_notation.prototype">module jscs.require_dot_notation.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_dot_notation.prototype.check" id="apidoc.element.jscs.require_dot_notation.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_dot_notation.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptSnakeCase = this._exceptSnakeCase;
    var exceptKeywords = this._exceptKeywords;

    var dialect = file.getDialect();
    file.iterateNodesByType('MemberExpression', function(node) {
        if (!node.computed || node.property.type !== 'StringLiteral') {
            return;
        }

        var value = node.property.value;
        if (// allow numbers, nulls, and anything else
            typeof value !== 'string' ||
            // allow invalid identifiers
            !utils.isValidIdentifierName(value, file.getDialect()) ||
            // allow quoted snake cased identifiers if allExcept: ['snake_case']
            (exceptSnakeCase &amp;&amp; utils.isSnakeCased(utils.trimUnderscores(value))) ||
            // allow quoted reserved words if allExcept: ['keywords']
            ((dialect === 'es3' || exceptKeywords) &amp;&amp; reservedWords.check(value, dialect, true))
        ) {
            return;
        }

        errors.add('Use dot notation instead of brackets for member expressions', node.property);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_dot_notation.prototype.configure" id="apidoc.element.jscs.require_dot_notation.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_dot_notation.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    if (typeof options !== 'object') {
        assert(
            options === true || options === 'except_snake_case',
            this.getOptionName() + ' option requires either a true value or an object'
        );

        var _options = {};
        if (options === 'except_snake_case') {
            _options.allExcept = ['snake_case'];
        }

        return this.configure(_options);
    }

    assert(
        !options.allExcept || Array.isArray(options.allExcept),
        'allExcept value of ' + this.getOptionName() + ' option requires an array with exceptions'
    );

    if (Array.isArray(options.allExcept)) {
        this._exceptSnakeCase = options.allExcept.indexOf('snake_case') &gt; -1;
        this._exceptKeywords = options.allExcept.indexOf('keywords') &gt; -1;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_dot_notation.prototype.getOptionName" id="apidoc.element.jscs.require_dot_notation.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_dot_notation.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireDotNotation';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_early_return" id="apidoc.module.jscs.require_early_return">module jscs.require_early_return</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_early_return.require_early_return" id="apidoc.element.jscs.require_early_return.require_early_return">
        function <span class="apidocSignatureSpan">jscs.</span>require_early_return
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_early_return = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_early_return.prototype" id="apidoc.module.jscs.require_early_return.prototype">module jscs.require_early_return.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_early_return.prototype.check" id="apidoc.element.jscs.require_early_return.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_early_return.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    function addError(entity) {
        errors.add(
            'Use of else after return',
            entity
        );
    }

    // Check if the IfStatement node contain a ReturnStatement.
    // If the node has a block, check all the statements in backward order to see if there is one.
    // This is to ensure that code like this will still return true:
    //
    // if (true) {
    //    return;
    //    eval();
    // }
    function hasNodeReturn(node) {
        if (node.type === 'BlockStatement') {
            for (var i = node.body.length - 1; i &gt;= 0; i--) {
                if (node.body[i].type === 'ReturnStatement') {
                    return true;
                }
            }
            return false;
        }
        return node.type === 'ReturnStatement';
    }

    file.iterateNodesByType('IfStatement', function(node) {
        if (!node.alternate) {
            return;
        }

        // Check if all the parents have a return statement, if not continue to the following IfStatement node.
        //
        // Example:
        //
        // if (foo) {
        //     return;
        // } else if (bar) {  &lt;-- error
        //     bar();
        // } else if (baz) {  &lt;-- safe
        //     return baz();
        // } else {           &lt;-- safe
        //     bas();
        // }
        for (var nodeIf = node; nodeIf &amp;&amp; nodeIf.type === 'IfStatement'; nodeIf = nodeIf.parentElement) {
            if (nodeIf.alternate &amp;&amp; !hasNodeReturn(nodeIf.consequent)) {
                return;
            }
        }

        return addError(file.getPrevToken(file.getFirstNodeToken(node.alternate)));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_early_return.prototype.configure" id="apidoc.element.jscs.require_early_return.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_early_return.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option allow only the `true` value'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_early_return.prototype.getOptionName" id="apidoc.element.jscs.require_early_return.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_early_return.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireEarlyReturn';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_enhanced_object_literals" id="apidoc.module.jscs.require_enhanced_object_literals">module jscs.require_enhanced_object_literals</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_enhanced_object_literals.require_enhanced_object_literals" id="apidoc.element.jscs.require_enhanced_object_literals.require_enhanced_object_literals">
        function <span class="apidocSignatureSpan">jscs.</span>require_enhanced_object_literals
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_enhanced_object_literals = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_enhanced_object_literals.prototype" id="apidoc.module.jscs.require_enhanced_object_literals.prototype">module jscs.require_enhanced_object_literals.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_enhanced_object_literals.prototype._fix" id="apidoc.element.jscs.require_enhanced_object_literals.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.require_enhanced_object_literals.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var elem = error.element;

    // Can't fix it yet
    if (elem.value.type === 'FunctionExpression') {
        return;
    }

    var element = parse(elem.key.name);
    element.remove();
    elem.parentElement.replaceChild(element, elem);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &amp;&amp; instance._fix) {
        // "error.fixed = true" should go first, so rule can
        // decide for itself (with "error.fixed = false")
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_enhanced_object_literals.prototype.check" id="apidoc.element.jscs.require_enhanced_object_literals.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_enhanced_object_literals.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('ObjectProperty', function(node) {
        // node.key.name is used when the property key is an unquoted identifier
        // node.key.value is used when the property key is a quoted string
        var propertyName = node.key.name || node.key.value;
        var valueName = node.value.name;
        var shorthand = node.shorthand;
        var computed = node.computed;

        // check for non-shorthand properties
        if (propertyName &amp;&amp; propertyName === valueName &amp;&amp; !(shorthand || computed)) {
            errors.add(
              'Property assignment should use enhanced object literal function.\n' +
              ' `{ propName: propName }` is not allowed.',
              node
            );
        }

        // check for non-method function properties
        var valueType = node.value.type;
        var valueIsMethod = node.method;
        if (valueType === 'FunctionExpression' &amp;&amp; !valueIsMethod) {
            errors.add(
              'Property assignment should use enhanced object literal function.\n' +
              ' `{ funcName: function() {} }` is not allowed.',
              node
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_enhanced_object_literals.prototype.configure" id="apidoc.element.jscs.require_enhanced_object_literals.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_enhanced_object_literals.prototype.</span>configure
        <span class="apidocSignatureSpan">(option)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (option) {
    assert(option === true, this.getOptionName() + ' requires a true value');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_enhanced_object_literals.prototype.getOptionName" id="apidoc.element.jscs.require_enhanced_object_literals.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_enhanced_object_literals.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireEnhancedObjectLiterals';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_function_declarations" id="apidoc.module.jscs.require_function_declarations">module jscs.require_function_declarations</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_function_declarations.require_function_declarations" id="apidoc.element.jscs.require_function_declarations.require_function_declarations">
        function <span class="apidocSignatureSpan">jscs.</span>require_function_declarations
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_function_declarations = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_function_declarations.prototype" id="apidoc.module.jscs.require_function_declarations.prototype">module jscs.require_function_declarations.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_function_declarations.prototype.check" id="apidoc.element.jscs.require_function_declarations.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_function_declarations.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(
        'VariableDeclarator',
        function(node) {
            if (node.init &amp;&amp; node.init.type === 'FunctionExpression') {
                errors.add('Use a function declaration instead', node);
            }
        }
    );

    file.iterateNodesByType(
        'AssignmentExpression',
        function(node) {
            if (node.left.type !== 'MemberExpression' &amp;&amp;
                node.right.type === 'FunctionExpression') {
                errors.add('Use a function declaration instead', node);
            }
        }
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_function_declarations.prototype.configure" id="apidoc.element.jscs.require_function_declarations.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_function_declarations.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_function_declarations.prototype.getOptionName" id="apidoc.element.jscs.require_function_declarations.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_function_declarations.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireFunctionDeclarations';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_imports_alphabetized" id="apidoc.module.jscs.require_imports_alphabetized">module jscs.require_imports_alphabetized</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_imports_alphabetized.require_imports_alphabetized" id="apidoc.element.jscs.require_imports_alphabetized.require_imports_alphabetized">
        function <span class="apidocSignatureSpan">jscs.</span>require_imports_alphabetized
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_imports_alphabetized = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_imports_alphabetized.prototype" id="apidoc.module.jscs.require_imports_alphabetized.prototype">module jscs.require_imports_alphabetized.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_imports_alphabetized.prototype.check" id="apidoc.element.jscs.require_imports_alphabetized.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_imports_alphabetized.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {

    var previous;
    var current;

    var createSpecHash = function(specifier) {

        var imported = '';
        var local = '';

        if (specifier.imported &amp;&amp; specifier.imported.name) {
            imported = specifier.imported.name;
        }

        if (specifier.local &amp;&amp; specifier.local.name) {
            local = specifier.local.name;
        }

        return imported === local ? imported : imported + local;

    };

    file.iterateNodesByType(
        'ImportDeclaration',
        function(node) {

            current = '';

            for (var i = 0; i &lt; node.specifiers.length; i++) {
                current += createSpecHash(node.specifiers[i]);
            }

            if (node.source &amp;&amp; node.source.value) {
                current += node.source.value;
            }

            if (previous &amp;&amp; previous &gt; current) {
                errors.add('imports must be alphabetized', node);
            }

            previous = current;
        }
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_imports_alphabetized.prototype.configure" id="apidoc.element.jscs.require_imports_alphabetized.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_imports_alphabetized.prototype.</span>configure
        <span class="apidocSignatureSpan">(option)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (option) {
    assert(
        option === true,
        this.getOptionName() + ' option requires true value'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_imports_alphabetized.prototype.getOptionName" id="apidoc.element.jscs.require_imports_alphabetized.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_imports_alphabetized.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireImportAlphabetized';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_keywords_on_new_line" id="apidoc.module.jscs.require_keywords_on_new_line">module jscs.require_keywords_on_new_line</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_keywords_on_new_line.require_keywords_on_new_line" id="apidoc.element.jscs.require_keywords_on_new_line.require_keywords_on_new_line">
        function <span class="apidocSignatureSpan">jscs.</span>require_keywords_on_new_line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_keywords_on_new_line = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_keywords_on_new_line.prototype" id="apidoc.module.jscs.require_keywords_on_new_line.prototype">module jscs.require_keywords_on_new_line.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_keywords_on_new_line.prototype.check" id="apidoc.element.jscs.require_keywords_on_new_line.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_keywords_on_new_line.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
        errors.assert.differentLine({
            token: token.getPreviousCodeToken(),
            nextToken: token
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_keywords_on_new_line.prototype.configure" id="apidoc.element.jscs.require_keywords_on_new_line.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_keywords_on_new_line.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(Array.isArray(keywords), this.getOptionName() + ' option requires array value');
    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_keywords_on_new_line.prototype.getOptionName" id="apidoc.element.jscs.require_keywords_on_new_line.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_keywords_on_new_line.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireKeywordsOnNewLine';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_line_break_after_variable_assignment" id="apidoc.module.jscs.require_line_break_after_variable_assignment">module jscs.require_line_break_after_variable_assignment</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_line_break_after_variable_assignment.require_line_break_after_variable_assignment" id="apidoc.element.jscs.require_line_break_after_variable_assignment.require_line_break_after_variable_assignment">
        function <span class="apidocSignatureSpan">jscs.</span>require_line_break_after_variable_assignment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_line_break_after_variable_assignment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_line_break_after_variable_assignment.prototype" id="apidoc.module.jscs.require_line_break_after_variable_assignment.prototype">module jscs.require_line_break_after_variable_assignment.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.check" id="apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_line_break_after_variable_assignment.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var lastDeclaration;
    file.iterateNodesByType('VariableDeclaration', function(node) {
        if (node.parentElement.type === 'ForStatement' ||
            node.parentElement.type === 'ForInStatement' ||
            node.parentElement.type === 'ForOfStatement') {
            return;
        }

        for (var i = 0; i &lt; node.declarations.length; i++) {
            var thisDeclaration = node.declarations[i];
            if (thisDeclaration.parentElement.kind === 'var' ||
                thisDeclaration.parentElement.kind === 'let' ||
                thisDeclaration.parentElement.kind === 'const') {
                if (lastDeclaration &amp;&amp; lastDeclaration.init) {
                    errors.assert.differentLine({
                        token: lastDeclaration,
                        nextToken: thisDeclaration,
                        message: 'Variable assignments should be followed by new line'
                    });
                }
                lastDeclaration = thisDeclaration;
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.configure" id="apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_line_break_after_variable_assignment.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.getOptionName" id="apidoc.element.jscs.require_line_break_after_variable_assignment.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_line_break_after_variable_assignment.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireLineBreakAfterVariableAssignment';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_line_feed_at_file_end" id="apidoc.module.jscs.require_line_feed_at_file_end">module jscs.require_line_feed_at_file_end</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_line_feed_at_file_end.require_line_feed_at_file_end" id="apidoc.element.jscs.require_line_feed_at_file_end.require_line_feed_at_file_end">
        function <span class="apidocSignatureSpan">jscs.</span>require_line_feed_at_file_end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_line_feed_at_file_end = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_line_feed_at_file_end.prototype" id="apidoc.module.jscs.require_line_feed_at_file_end.prototype">module jscs.require_line_feed_at_file_end.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_line_feed_at_file_end.prototype.check" id="apidoc.element.jscs.require_line_feed_at_file_end.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_line_feed_at_file_end.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var lastToken = file.getLastToken({includeComments: true});
    var prevToken = file.getPrevToken(lastToken, {includeComments: true});
    errors.assert.differentLine({
        token: prevToken,
        nextToken: lastToken,
        message: 'Missing line feed at file end'
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_line_feed_at_file_end.prototype.configure" id="apidoc.element.jscs.require_line_feed_at_file_end.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_line_feed_at_file_end.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_line_feed_at_file_end.prototype.getOptionName" id="apidoc.element.jscs.require_line_feed_at_file_end.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_line_feed_at_file_end.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireLineFeedAtFileEnd';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_matching_function_name" id="apidoc.module.jscs.require_matching_function_name">module jscs.require_matching_function_name</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_matching_function_name.require_matching_function_name" id="apidoc.element.jscs.require_matching_function_name.require_matching_function_name">
        function <span class="apidocSignatureSpan">jscs.</span>require_matching_function_name
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_matching_function_name = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_matching_function_name.prototype" id="apidoc.module.jscs.require_matching_function_name.prototype">module jscs.require_matching_function_name.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_matching_function_name.prototype.check" id="apidoc.element.jscs.require_matching_function_name.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_matching_function_name.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var _includeModuleExports = this._includeModuleExports;
    file.iterateNodesByType(['FunctionExpression'], function(node) {
        switch (node.parentElement.type) {
            // var foo = function bar() {}
            // object.foo = function bar() {}
            // object['foo'] = function bar() {}
            case 'AssignmentExpression':
                if (_includeModuleExports || !_isModuleExports(node.parentElement.left)) {
                    checkForMember(node.parentElement, skip, errors);
                }
                break;

            // object = {foo: function bar() {}}
            case 'ObjectProperty':
                checkForProperty(node.parentElement, skip, errors);
                break;
        }
    });

    function skip(key, value) {
        // We don't care about anonymous functions as
        // those should be enforced by separate rule
        if (!value.id) {
            return true;
        }

        // Relax a bit when reserved word is detected
        if (reservedWords.check(key, file.getDialect(), true)) {
            return true;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_matching_function_name.prototype.configure" id="apidoc.element.jscs.require_matching_function_name.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_matching_function_name.prototype.</span>configure
        <span class="apidocSignatureSpan">(requireMatchingFunctionName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (requireMatchingFunctionName) {
    if (typeof requireMatchingFunctionName === 'object') {
        assert(requireMatchingFunctionName.includeModuleExports === true,
            'requireMatchingFunctionName option requires includeModuleExports property to be true for object');
        this._includeModuleExports = requireMatchingFunctionName.includeModuleExports;
    } else {
        assert(
            requireMatchingFunctionName === true,
            'requireMatchingFunctionName option requires true value or should be removed'
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_matching_function_name.prototype.getOptionName" id="apidoc.element.jscs.require_matching_function_name.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_matching_function_name.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireMatchingFunctionName';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_multi_line_ternary" id="apidoc.module.jscs.require_multi_line_ternary">module jscs.require_multi_line_ternary</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_multi_line_ternary.require_multi_line_ternary" id="apidoc.element.jscs.require_multi_line_ternary.require_multi_line_ternary">
        function <span class="apidocSignatureSpan">jscs.</span>require_multi_line_ternary
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_multi_line_ternary = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_multi_line_ternary.prototype" id="apidoc.module.jscs.require_multi_line_ternary.prototype">module jscs.require_multi_line_ternary.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_multi_line_ternary.prototype.check" id="apidoc.element.jscs.require_multi_line_ternary.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_multi_line_ternary.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('ConditionalExpression', function(node) {

        errors.assert.differentLine({
            token: node.test,
            nextToken: node.consequent,
            message: 'Missing new line after test'
        });

        errors.assert.differentLine({
            token: node.consequent,
            nextToken: node.alternate,
            message: 'Missing new line after consequent'
        });

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_multi_line_ternary.prototype.configure" id="apidoc.element.jscs.require_multi_line_ternary.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_multi_line_ternary.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_multi_line_ternary.prototype.getOptionName" id="apidoc.element.jscs.require_multi_line_ternary.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_multi_line_ternary.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireMultiLineTernary';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_multiple_var_decl" id="apidoc.module.jscs.require_multiple_var_decl">module jscs.require_multiple_var_decl</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_multiple_var_decl.require_multiple_var_decl" id="apidoc.element.jscs.require_multiple_var_decl.require_multiple_var_decl">
        function <span class="apidocSignatureSpan">jscs.</span>require_multiple_var_decl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_multiple_var_decl = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_multiple_var_decl.prototype" id="apidoc.module.jscs.require_multiple_var_decl.prototype">module jscs.require_multiple_var_decl.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_multiple_var_decl.prototype.check" id="apidoc.element.jscs.require_multiple_var_decl.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_multiple_var_decl.prototype.</span>check
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function () {
    return this._check.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_multiple_var_decl.prototype.configure" id="apidoc.element.jscs.require_multiple_var_decl.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_multiple_var_decl.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var isExceptRequire = typeof options === 'object' &amp;&amp;
                          options.allExcept.length &amp;&amp;
                          options.allExcept.indexOf('require') !== -1;

    assert(
        options === true ||
        options === 'onevar' ||
        isExceptRequire,
        this.getOptionName() + ' option requires a true value, `onevar` or {allExcept: [\'require\']}'
    );

    var checkers = {
        'true': consecutive,
        onevar: onevar
    };

    this._isExceptRequire = isExceptRequire;
    this._check = isExceptRequire ? consecutive : checkers[options];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_multiple_var_decl.prototype.getOptionName" id="apidoc.element.jscs.require_multiple_var_decl.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_multiple_var_decl.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireMultipleVarDecl';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_named_unassigned_functions" id="apidoc.module.jscs.require_named_unassigned_functions">module jscs.require_named_unassigned_functions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_named_unassigned_functions.require_named_unassigned_functions" id="apidoc.element.jscs.require_named_unassigned_functions.require_named_unassigned_functions">
        function <span class="apidocSignatureSpan">jscs.</span>require_named_unassigned_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_named_unassigned_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_named_unassigned_functions.prototype" id="apidoc.module.jscs.require_named_unassigned_functions.prototype">module jscs.require_named_unassigned_functions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_named_unassigned_functions.prototype.check" id="apidoc.element.jscs.require_named_unassigned_functions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_named_unassigned_functions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var _this = this;
    file.iterateNodesByType('FunctionExpression', function(node) {
        var parentElement = node.parentElement;
        // If the function has been named via left hand assignment, skip it
        //   e.g. `var hello = function() {`, `foo.bar = function() {`
        if (parentElement.type.match(/VariableDeclarator|Property|AssignmentExpression/)) {
            return;
        }

        // If the function has been named, skip it
        //   e.g. `[].forEach(function hello() {`
        if (node.id !== null) {
            return;
        }

        // If we have exceptions and the function is being invoked, detect whether we excepted it
        if (_this._allExceptItems &amp;&amp; parentElement.type === 'CallExpression') {
            // Determine the path that resolves to our call expression
            // We must cover both direct calls (e.g. `it(function() {`) and
            //   member expressions (e.g. `foo.bar(function() {`)
            var memberNode = parentElement.callee;
            var canBeRepresented = true;
            var fullpathParts = [];
            while (memberNode) {
                if (memberNode.type.match(/Identifier|Literal/)) {
                    fullpathParts.unshift(getNodeName(memberNode));
                } else if (memberNode.type === 'MemberExpression') {
                    fullpathParts.unshift(getNodeName(memberNode.property));
                } else {
                    canBeRepresented = false;
                    break;
                }
                memberNode = memberNode.object;
            }

            // If the path is not-dynamic (i.e. can be represented by static parts),
            //   then check it against our exceptions
            if (canBeRepresented) {
                var fullpath = JSON.stringify(fullpathParts);
                for (var i = 0, l = _this._allExceptItems.length; i &lt; l; i++) {
                    if (fullpath === _this._allExceptItems[i]) {
                        return;
                    }
                }
            }
        }

        // Complain that this function must be named
        errors.add('Inline functions need to be named', node);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_named_unassigned_functions.prototype.configure" id="apidoc.element.jscs.require_named_unassigned_functions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_named_unassigned_functions.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true ||
        typeof options === 'object',
        this.getOptionName() + ' option requires true value ' +
        'or an object with String[] `allExcept` property'
    );

    // verify first item in `allExcept` property in object (if it's an object)
    assert(
        typeof options !== 'object' ||
        Array.isArray(options.allExcept) &amp;&amp;
        typeof options.allExcept[0] === 'string',
        'Property `allExcept` in ' + this.getOptionName() + ' should be an array of strings'
    );

    if (options.allExcept) {
        this._allExceptItems = options.allExcept.map(function(item) {
            var parts = pathval.parse(item).map(function extractPart(part) {
                return part.i !== undefined ? part.i : part.p;
            });
            return JSON.stringify(parts);
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_named_unassigned_functions.prototype.getOptionName" id="apidoc.element.jscs.require_named_unassigned_functions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_named_unassigned_functions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireNamedUnassignedFunctions';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_newline_before_block_statements" id="apidoc.module.jscs.require_newline_before_block_statements">module jscs.require_newline_before_block_statements</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_block_statements.require_newline_before_block_statements" id="apidoc.element.jscs.require_newline_before_block_statements.require_newline_before_block_statements">
        function <span class="apidocSignatureSpan">jscs.</span>require_newline_before_block_statements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_newline_before_block_statements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_newline_before_block_statements.prototype" id="apidoc.module.jscs.require_newline_before_block_statements.prototype">module jscs.require_newline_before_block_statements.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_block_statements.prototype.check" id="apidoc.element.jscs.require_newline_before_block_statements.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_newline_before_block_statements.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var setting = this._setting;

    function assertDifferentLine(token, nextToken) {
        errors.assert.differentLine({
            token: token,
            nextToken: nextToken,
            message: 'Newline before curly brace for block statement is required'
        });
    }

    file.iterateNodesByType('BlockStatement', function(node) {
        if (setting === true || setting.indexOf(getBlockType(node)) !== -1) {
            var openingBrace = node.getFirstToken();
            var prevToken = openingBrace.getPreviousCodeToken();

            assertDifferentLine(prevToken, openingBrace);
        }
    });
    if (setting === true || setting.indexOf('switch') !== -1) {
        file.iterateNodesByType(['SwitchStatement'], function(node) {
            var openingBrace = file.findNextToken(file.getLastNodeToken(node.discriminant), 'Punctuator', '{');
            var prevToken = file.getPrevToken(openingBrace);

            assertDifferentLine(prevToken, openingBrace);
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_block_statements.prototype.configure" id="apidoc.element.jscs.require_newline_before_block_statements.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_newline_before_block_statements.prototype.</span>configure
        <span class="apidocSignatureSpan">(settingValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (settingValue) {
    assert(
        Array.isArray(settingValue) &amp;&amp; settingValue.length || settingValue === true,
        'requireNewlineBeforeBlockStatements option requires non-empty array value or true value'
    );

    this._setting = settingValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_block_statements.prototype.getOptionName" id="apidoc.element.jscs.require_newline_before_block_statements.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_newline_before_block_statements.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireNewlineBeforeBlockStatements';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_newline_before_single_statements_in_if" id="apidoc.module.jscs.require_newline_before_single_statements_in_if">module jscs.require_newline_before_single_statements_in_if</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_single_statements_in_if.require_newline_before_single_statements_in_if" id="apidoc.element.jscs.require_newline_before_single_statements_in_if.require_newline_before_single_statements_in_if">
        function <span class="apidocSignatureSpan">jscs.</span>require_newline_before_single_statements_in_if
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_newline_before_single_statements_in_if = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_newline_before_single_statements_in_if.prototype" id="apidoc.module.jscs.require_newline_before_single_statements_in_if.prototype">module jscs.require_newline_before_single_statements_in_if.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.check" id="apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_newline_before_single_statements_in_if.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    function assertDifferentLine(token, nextToken) {
        errors.assert.differentLine({
            token: token,
            nextToken: nextToken,
            message: 'Newline before single statement in if is required'
        });
    }

    // Recursively locate a token based on it's type.
    function getToken(entity, tokenType, tokenProperty) {
        if (entity.type === tokenType || !entity[tokenProperty]) {
            return entity;
        } else {
            return getToken(entity[tokenProperty], tokenType, tokenProperty);
        }
    }

    file.iterateNodesByType('IfStatement', function(node) {
        var consequentNode = getFirstStatement(node.consequent);
        var alternateNode = getFirstStatement(node.alternate);

        if (consequentNode) {
            assertDifferentLine(
                getToken(consequentNode, 'Keyword', 'previousSibling'),
                consequentNode
            );
        }

        if (alternateNode &amp;&amp; alternateNode.type !== 'IfStatement' &amp;&amp; alternateNode.type !== 'BlockStatement') {
            assertDifferentLine(
                getToken(alternateNode, 'Keyword', 'previousSibling'),
                alternateNode
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.configure" id="apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_newline_before_single_statements_in_if.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    assert(
        value === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.getOptionName" id="apidoc.element.jscs.require_newline_before_single_statements_in_if.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_newline_before_single_statements_in_if.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireNewlineBeforeSingleStatementsInIf';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_numeric_literals" id="apidoc.module.jscs.require_numeric_literals">module jscs.require_numeric_literals</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_numeric_literals.require_numeric_literals" id="apidoc.element.jscs.require_numeric_literals.require_numeric_literals">
        function <span class="apidocSignatureSpan">jscs.</span>require_numeric_literals
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_numeric_literals = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_numeric_literals.prototype" id="apidoc.module.jscs.require_numeric_literals.prototype">module jscs.require_numeric_literals.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_numeric_literals.prototype.check" id="apidoc.element.jscs.require_numeric_literals.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_numeric_literals.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var radixMap = this._radixMap;
    file.iterateNodesByType(['CallExpression'], function(node) {
        // don't check for parseInt(1)
        if (node.arguments.length !== 2) {
            return;
        }

        // only error if the radix is 2, 8, or 16
        var radixName = radixMap[node.arguments[1].value];

        if (node.callee.type === 'Identifier' &amp;&amp;
            node.callee.name === 'parseInt' &amp;&amp;
            radixName &amp;&amp;
            node.arguments[0].type.indexOf('Literal') &gt; -1
        ) {
            errors.add('Use ' + radixName + ' literals instead of parseInt', node);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_numeric_literals.prototype.configure" id="apidoc.element.jscs.require_numeric_literals.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_numeric_literals.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );

    this._radixMap = {
        2: 'binary',
        8: 'octal',
        16: 'hexadecimal'
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_numeric_literals.prototype.getOptionName" id="apidoc.element.jscs.require_numeric_literals.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_numeric_literals.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireNumericLiterals';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_object_destructuring" id="apidoc.module.jscs.require_object_destructuring">module jscs.require_object_destructuring</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_object_destructuring.require_object_destructuring" id="apidoc.element.jscs.require_object_destructuring.require_object_destructuring">
        function <span class="apidocSignatureSpan">jscs.</span>require_object_destructuring
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_object_destructuring = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_object_destructuring.prototype" id="apidoc.module.jscs.require_object_destructuring.prototype">module jscs.require_object_destructuring.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_object_destructuring.prototype.check" id="apidoc.element.jscs.require_object_destructuring.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_object_destructuring.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var propertyExceptions = this._propertyExceptions;

    file.iterateNodesByType('VariableDeclaration', function(node) {

        node.declarations.forEach(function(declaration) {
            var declarationId = declaration.id || {};
            var declarationInit = declaration.init || {};

            if (declarationId.type !== 'Identifier' || declarationInit.type !== 'MemberExpression') {
                return;
            }

            var propertyName = declarationInit.property &amp;&amp; declarationInit.property.name;

            if (declarationId.name === propertyName &amp;&amp;
                propertyExceptions.indexOf(propertyName) &lt; 0) {

                errors.add('Property assignments should use destructuring', node);
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_object_destructuring.prototype.configure" id="apidoc.element.jscs.require_object_destructuring.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_object_destructuring.prototype.</span>configure
        <span class="apidocSignatureSpan">(option)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (option) {
    var isTrue = option === true;

    assert(
        isTrue || (typeof option === 'object' &amp;&amp; Array.isArray(option.allExcept)),
        this.getOptionName() + ' requires the value `true` ' +
          'or an object with an `allExcept` array property'
    );

    this._propertyExceptions = !isTrue &amp;&amp; option.allExcept || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_object_destructuring.prototype.getOptionName" id="apidoc.element.jscs.require_object_destructuring.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_object_destructuring.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireObjectDestructuring';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_object_keys_on_new_line" id="apidoc.module.jscs.require_object_keys_on_new_line">module jscs.require_object_keys_on_new_line</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_object_keys_on_new_line.require_object_keys_on_new_line" id="apidoc.element.jscs.require_object_keys_on_new_line.require_object_keys_on_new_line">
        function <span class="apidocSignatureSpan">jscs.</span>require_object_keys_on_new_line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_object_keys_on_new_line = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_object_keys_on_new_line.prototype" id="apidoc.module.jscs.require_object_keys_on_new_line.prototype">module jscs.require_object_keys_on_new_line.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_object_keys_on_new_line.prototype.check" id="apidoc.element.jscs.require_object_keys_on_new_line.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_object_keys_on_new_line.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var message = 'Object keys must go on a new line';
    var isSameLine = this._isSameLine;

    if (isSameLine) {
        message = 'Object keys must go on a new line if they aren\'t all on the same line';
    }

    file.iterateNodesByType('ObjectExpression', function(node) {
        var firstKeyToken;
        var lastValueToken;
        var lastProp;

        if (isSameLine) {
            if (node.properties.length &gt; 1) {
                firstKeyToken = file.getFirstNodeToken(node.properties[0].key);
                lastProp = node.properties[node.properties.length - 1];
                lastValueToken = file.getLastNodeToken(lastProp.value || lastProp.key);

                if (firstKeyToken.getLoc().end.line === lastValueToken.getLoc().start.line) {
                    // It's ok, all keys and values are on the same line.
                    return;
                }
            }
        }

        for (var i = 1; i &lt; node.properties.length; i++) {
            var prop = node.properties[i - 1];
            lastValueToken = file.getLastNodeToken(prop.value || prop.body);
            var comma = file.findNextToken(lastValueToken, 'Punctuator', ',');

            firstKeyToken = file.getFirstNodeToken(node.properties[i].key);

            errors.assert.differentLine({
                token: comma,
                nextToken: firstKeyToken,
                message: message
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_object_keys_on_new_line.prototype.configure" id="apidoc.element.jscs.require_object_keys_on_new_line.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_object_keys_on_new_line.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || Array.isArray(options.allExcept),
        this.getOptionName() + ' option requires a true value or an object of exceptions'
    );

    this._isSameLine = false;
    if (Array.isArray(options.allExcept)) {
        this._isSameLine = options.allExcept[0] === 'sameLine';
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_object_keys_on_new_line.prototype.getOptionName" id="apidoc.element.jscs.require_object_keys_on_new_line.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_object_keys_on_new_line.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireObjectKeysOnNewLine';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_operator_before_line_break" id="apidoc.module.jscs.require_operator_before_line_break">module jscs.require_operator_before_line_break</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_operator_before_line_break.require_operator_before_line_break" id="apidoc.element.jscs.require_operator_before_line_break.require_operator_before_line_break">
        function <span class="apidocSignatureSpan">jscs.</span>require_operator_before_line_break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_operator_before_line_break = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_operator_before_line_break.prototype" id="apidoc.module.jscs.require_operator_before_line_break.prototype">module jscs.require_operator_before_line_break.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_operator_before_line_break.prototype.check" id="apidoc.element.jscs.require_operator_before_line_break.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_operator_before_line_break.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operators = this._operatorIndex;
    var throughTokens = ['?', ','];

    function errorIfApplicable(operatorToken) {
        errors.assert.sameLine({
            token: file.getPrevToken(operatorToken),
            nextToken: operatorToken,
            message: 'Operator ' + operatorToken.value + ' should not be on a new line',
            stickToPreviousToken: true
        });
    }

    throughTokens = throughTokens.filter(function(operator) {
        return operators[operator];
    });

    if (throughTokens.length) {
        file.iterateTokensByType('Punctuator', function(token) {
            var operator = token.value;

            if (throughTokens.every(function() {
                return throughTokens.indexOf(operator) &gt;= 0;
            })) {
                errorIfApplicable(token);
            }
        });
    }

    file.iterateNodesByType(
        ['BinaryExpression', 'AssignmentExpression', 'LogicalExpression'],
        function(node) {
            var operator = node.operator;

            if (!operators[operator]) {
                return;
            }

            var nextToken = file.getFirstNodeToken(node.argument || node.right);
            var token = file.findPrevOperatorToken(nextToken, operator);

            errorIfApplicable(token);
        }
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_operator_before_line_break.prototype.configure" id="apidoc.element.jscs.require_operator_before_line_break.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_operator_before_line_break.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + ' option requires array value or true value'
    );

    if (isTrue) {
        operators = defaultOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &lt; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_operator_before_line_break.prototype.getOptionName" id="apidoc.element.jscs.require_operator_before_line_break.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_operator_before_line_break.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireOperatorBeforeLineBreak';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newline_after_variable_declaration" id="apidoc.module.jscs.require_padding_newline_after_variable_declaration">module jscs.require_padding_newline_after_variable_declaration</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration.require_padding_newline_after_variable_declaration" id="apidoc.element.jscs.require_padding_newline_after_variable_declaration.require_padding_newline_after_variable_declaration">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newline_after_variable_declaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newline_after_variable_declaration = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newline_after_variable_declaration.prototype" id="apidoc.module.jscs.require_padding_newline_after_variable_declaration.prototype">module jscs.require_padding_newline_after_variable_declaration.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.check" id="apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_padding_newline_after_variable_declaration.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('VariableDeclaration', function(node) {
        if (node.parentElement.type === 'ForStatement' ||
            node.parentElement.type === 'ForInStatement' ||
            node.parentElement.type === 'ForOfStatement') {
            return;
        }

        var endOfDeclaration = file.getLastNodeToken(node);
        var nextToken = file.getNextToken(endOfDeclaration);

        // check export declaration
        if (nextToken.value === 'export') {
            nextToken = file.getNextToken(nextToken);
        }

        if (nextToken.value in {'var': true, 'let': true, 'const': true}) {
            return;
        }

        if (nextToken.value === '}') {
            return;
        }

        if (nextToken.type === 'EOF') {
            return;
        }

        errors.assert.linesBetween({
            atLeast: 2,
            token: endOfDeclaration,
            nextToken: nextToken
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.configure" id="apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_padding_newline_after_variable_declaration.prototype.</span>configure
        <span class="apidocSignatureSpan">(requirePaddingNewLineAfterVariableDeclaration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (requirePaddingNewLineAfterVariableDeclaration) {
    assert(
        requirePaddingNewLineAfterVariableDeclaration === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.getOptionName" id="apidoc.element.jscs.require_padding_newline_after_variable_declaration.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_padding_newline_after_variable_declaration.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requirePaddingNewLineAfterVariableDeclaration';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_after_blocks" id="apidoc.module.jscs.require_padding_newlines_after_blocks">module jscs.require_padding_newlines_after_blocks</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_blocks.require_padding_newlines_after_blocks" id="apidoc.element.jscs.require_padding_newlines_after_blocks.require_padding_newlines_after_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_after_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_after_blocks.prototype" id="apidoc.module.jscs.require_padding_newlines_after_blocks.prototype">module jscs.require_padding_newlines_after_blocks.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.check" id="apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_blocks.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    function isException(node, parent, exceptions) {
        var grandpa = parent.parentElement;

        // Check if this block is used in call or array expression
        if (grandpa &amp;&amp; exceptions[grandpa.type]) {
            return true;
        }

        var first = node.getFirstToken();
        var last = node.getLastToken();

        if (exceptions.SingleLine &amp;&amp; file.isOnTheSameLine(first, last)) {
            return true;
        }

        return false;
    }

    file.iterateNodesByType('BlockStatement', (function(node) {

        var endToken = file.getLastNodeToken(node);
        var parentElement = node.parentElement;
        var tokens = {
            next: endToken.getNextCodeToken(),
            token: endToken
        };

        if (isException(node, parentElement, this.exceptions)) {
            return;
        }

        while (tokens.next.type !== 'EOF') {
            var excludeValues = excludes[parentElement.type];
            if (excludeValues &amp;&amp; excludeValues.indexOf(tokens.next.value) !== -1) {
                return;
            }

            if (file.isOnTheSameLine(tokens.token, tokens.next)) {
                endToken = tokens.next;
                tokens.next = tokens.next.getNextCodeToken();
                continue;
            }

            if (tokens.next.type === 'Punctuator' &amp;&amp; (
                tokens.next.value === '}' ||
                tokens.next.value === ']' ||
                tokens.next.value === '&gt;' ||
                tokens.next.value === ')')
            ) {
                return;
            }

            errors.assert.linesBetween({
                token: tokens.token,
                nextToken: tokens.next,
                atLeast: 2,
                message: 'Missing newline after block'
            });

            return;
        }
    }).bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.configure" id="apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_blocks.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    this.exceptions = {
        'CallExpression': false,
        'NewExpression': false,
        'ArrayExpression': false,
        'ObjectProperty': false,
        'SingleLine': false
    };

    var optionName = this.getOptionName();

    if (typeof value === 'object') {
        assert(Array.isArray(value.allExcept), optionName + ' option requires "allExcept" ' +
            'to be an array');
        assert(value.allExcept.length &gt; 0, optionName + ' option requires "allExcept" ' +
            'to have at least one item or be set to `true`');

        value.allExcept.forEach(function(except) {
            if (except === 'inCallExpressions') {
                this.exceptions.CallExpression = true;
            } else if (except === 'inNewExpressions') {
                this.exceptions.NewExpression = true;
            } else if (except === 'inArrayExpressions') {
                this.exceptions.ArrayExpression = true;
            } else if (except === 'inProperties') {
                this.exceptions.ObjectProperty = true;
            } else if (except === 'singleLine') {
                this.exceptions.SingleLine = true;
            } else {
                assert(false, optionName + ' option requires "allExcept" to only have ' +
                    'one of "inCallExpressions", "inNewExpressions",' +
                    '"inArrayExpressions", "inProperties" or "singleLine"');
            }
        }, this);
    } else {
        assert(value === true,
            optionName + ' option requires true value or object'
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.getOptionName" id="apidoc.element.jscs.require_padding_newlines_after_blocks.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_blocks.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requirePaddingNewLinesAfterBlocks';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_after_use_strict" id="apidoc.module.jscs.require_padding_newlines_after_use_strict">module jscs.require_padding_newlines_after_use_strict</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_use_strict.require_padding_newlines_after_use_strict" id="apidoc.element.jscs.require_padding_newlines_after_use_strict.require_padding_newlines_after_use_strict">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_after_use_strict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_after_use_strict = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_after_use_strict.prototype" id="apidoc.module.jscs.require_padding_newlines_after_use_strict.prototype">module jscs.require_padding_newlines_after_use_strict.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.check" id="apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_use_strict.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptRequire = this._exceptRequire;
    file.iterateNodesByType('Directive', function(node) {
        var literal = node.value;

        if (literal.value !== 'use strict') {
            return;
        }

        var endOfNode = file.getLastNodeToken(node);
        if (exceptRequire) {
            var requireToken = file.findNextToken(endOfNode, 'Identifier', 'require');
            if (requireToken &amp;&amp; node.getLoc().start.line + 1 === requireToken.getLoc().start.line) {

                // Ensure the detected require is the first declaration of this line
                var keywordToken = file.getNextToken(endOfNode, {
                    includeComments: true
                });
                var identifierToken = file.getNextToken(file.getLastNodeToken(keywordToken), {
                    includeComments: true
                });
                var punctuatorToken = file.getNextToken(file.getLastNodeToken(identifierToken), {
                    includeComments: true
                });
                requireToken = file.getNextToken(file.getLastNodeToken(punctuatorToken), {
                    includeComments: true
                });

                if (
                    keywordToken.type === 'Keyword' &amp;&amp;
                    identifierToken.type === 'Identifier' &amp;&amp;
                    punctuatorToken.type === 'Punctuator' &amp;&amp;
                    requireToken.type === 'Identifier' &amp;&amp;
                    requireToken.value === 'require'
                ) {
                    return;
                }
            }
        }

        var nextToken = file.getNextToken(endOfNode, {
            includeComments: true
        });

        errors.assert.linesBetween({
            atLeast: 2,
            token: endOfNode,
            nextToken: nextToken
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.configure" id="apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_use_strict.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    if (typeof options !== 'object') {
        assert(
            options === true,
            this.getOptionName() + ' option requires either a true value or an object'
        );

        var _options = {allExcept: []};
        return this.configure(_options);
    }

    if (Array.isArray(options.allExcept)) {
        this._exceptRequire = options.allExcept.indexOf('require') &gt; -1;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.getOptionName" id="apidoc.element.jscs.require_padding_newlines_after_use_strict.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_after_use_strict.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requirePaddingNewLinesAfterUseStrict';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_before_export" id="apidoc.module.jscs.require_padding_newlines_before_export">module jscs.require_padding_newlines_before_export</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_export.require_padding_newlines_before_export" id="apidoc.element.jscs.require_padding_newlines_before_export.require_padding_newlines_before_export">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_export
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_before_export = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_before_export.prototype" id="apidoc.module.jscs.require_padding_newlines_before_export.prototype">module jscs.require_padding_newlines_before_export.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_export.prototype.check" id="apidoc.element.jscs.require_padding_newlines_before_export.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_export.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('AssignmentExpression', function(node) {
        var left = node.left;
        var greatGrandpa = node.parentElement.parentElement;
        if (!(
            left.object &amp;&amp;
            left.object.name === 'module' &amp;&amp;
            left.property &amp;&amp;
            left.property.name === 'exports')) {
            return;
        }

        // module.exports is in a block and is the only statement.
        if (greatGrandpa.type === 'BlockStatement' &amp;&amp; greatGrandpa.body.length === 1) {
            return;
        }

        var firstToken = node.getFirstToken();
        var prevToken = file.getPrevToken(firstToken);

        errors.assert.linesBetween({
            atLeast: 2,
            token: prevToken,
            nextToken: firstToken,
            message: 'Missing newline before export'
        });
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_export.prototype.configure" id="apidoc.element.jscs.require_padding_newlines_before_export.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_export.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    assert(
        value === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_export.prototype.getOptionName" id="apidoc.element.jscs.require_padding_newlines_before_export.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_export.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requirePaddingNewLinesBeforeExport';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_before_keywords" id="apidoc.module.jscs.require_padding_newlines_before_keywords">module jscs.require_padding_newlines_before_keywords</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_keywords.require_padding_newlines_before_keywords" id="apidoc.element.jscs.require_padding_newlines_before_keywords.require_padding_newlines_before_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_before_keywords = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_before_keywords.prototype" id="apidoc.module.jscs.require_padding_newlines_before_keywords.prototype">module jscs.require_padding_newlines_before_keywords.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.check" id="apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_keywords.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var excludedTokens = [':', ',', '(', '='];
    var specialCases = { 'if': 'else' };
    file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
        var prevToken = token.getPreviousCodeToken();

        if (!prevToken) {
            return;
        }

        // Handle special cases listed in specialCasesToken array
        if (prevToken.value === specialCases[token.value]) {
            return;
        }

        // allow returning a function
        if (prevToken.value === 'return' &amp;&amp; token.value === 'function') {
            return;
        }

        // Do not report `do...while` statements
        if (token.value === 'while' &amp;&amp; token.parentElement.type === 'DoWhileStatement') {
            return;
        }

        // Handle excludedTokens
        if (excludedTokens.indexOf(prevToken.value) &gt; -1) {
            return;
        }

        // Handle all other cases
        // The { character is there to handle the case of a matching token which happens to be the first
        //   statement in a block
        // The ) character is there to handle the case of `if (...) matchingKeyword` in which case
        //   requiring padding would break the statement
        if (prevToken.value !== '{' &amp;&amp; prevToken.value !== ')') {
            errors.assert.linesBetween({
                token: prevToken,
                nextToken: token,
                atLeast: 2,
                message: 'Keyword `' + token.value + '` should have an empty line above it'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.configure" id="apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_keywords.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(Array.isArray(keywords) || keywords === true,
        this.getOptionName() + ' option requires array or true value');

    if (keywords === true) {
        keywords = defaultKeywords;
    }

    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.getOptionName" id="apidoc.element.jscs.require_padding_newlines_before_keywords.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_keywords.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requirePaddingNewlinesBeforeKeywords';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_before_line_comments" id="apidoc.module.jscs.require_padding_newlines_before_line_comments">module jscs.require_padding_newlines_before_line_comments</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_line_comments.require_padding_newlines_before_line_comments" id="apidoc.element.jscs.require_padding_newlines_before_line_comments.require_padding_newlines_before_line_comments">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_before_line_comments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_before_line_comments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_before_line_comments.prototype" id="apidoc.module.jscs.require_padding_newlines_before_line_comments.prototype">module jscs.require_padding_newlines_before_line_comments.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.check" id="apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_line_comments.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var allowFirstAfterCurly = this._allowFirstAfterCurly;

    file.iterateTokensByType('CommentLine', function(comment) {
        if (comment.getLoc().start.line === 1) {
            return;
        }

        var firstToken = file.getFirstTokenOnLineWith(comment);

        // Should not consider code and comment on the same line (#1194)
        if (firstToken !== null &amp;&amp; firstToken.type !== 'EOF') {
            return;
        }

        var prevToken = file.getPrevToken(comment, {includeComments: true});

        if (!prevToken || prevToken.type === 'CommentLine') {
            return;
        }

        if (allowFirstAfterCurly &amp;&amp; prevToken.type === 'Punctuator' &amp;&amp; prevToken.value === '{') {
            return;
        }

        errors.assert.linesBetween({
            token: prevToken,
            nextToken: comment,
            atLeast: 2,
            message: 'Line comments must be preceded with a blank line'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.configure" id="apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_line_comments.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    this._allowFirstAfterCurly = false;

    if (typeof value === 'object') {
        assert(typeof value.allExcept === 'string' &amp;&amp; value.allExcept === 'firstAfterCurly',
            this.getOptionName() + ' option requires the "allExcept" ' +
             'property to equal "firstAfterCurly"');
        this._allowFirstAfterCurly = true;
    } else {
        assert(value === true,
            this.getOptionName() + ' option requires true value or object'
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.getOptionName" id="apidoc.element.jscs.require_padding_newlines_before_line_comments.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_before_line_comments.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requirePaddingNewLinesBeforeLineComments';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_in_blocks" id="apidoc.module.jscs.require_padding_newlines_in_blocks">module jscs.require_padding_newlines_in_blocks</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_blocks.require_padding_newlines_in_blocks" id="apidoc.element.jscs.require_padding_newlines_in_blocks.require_padding_newlines_in_blocks">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_blocks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_in_blocks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_in_blocks.prototype" id="apidoc.module.jscs.require_padding_newlines_in_blocks.prototype">module jscs.require_padding_newlines_in_blocks.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.check" id="apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_blocks.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var minLines = this._minLines;
    var exceptConditionals = this._exceptConditionals;
    var exceptFunctions = this._exceptFunctions;
    var checkOpen = this._checkOpen;
    var checkClose = this._checkClose;

    file.iterateNodesByType('BlockStatement', function(node) {
        var openingBracket;
        var closingBracket;

        if (node.body.length &lt;= minLines) {
            return;
        }

        if (exceptConditionals &amp;&amp; node.parentElement.type === 'IfStatement' ||
            exceptFunctions &amp;&amp; (node.parentElement.type === 'FunctionExpression' ||
            node.parentElement.type === 'FunctionDeclaration')) {
            return;
        }

        if (checkOpen === true) {
            openingBracket = node.getFirstToken();

            errors.assert.linesBetween({
                token: openingBracket,
                nextToken: file.getNextToken(openingBracket, {includeComments: true}),
                atLeast: 2,
                message: 'Expected a padding newline after opening curly brace'
            });
        }

        if (checkClose === true) {
            closingBracket = file.getLastNodeToken(node);

            errors.assert.linesBetween({
                token: file.getPrevToken(closingBracket, {includeComments: true}),
                nextToken: closingBracket,
                atLeast: 2,
                message: 'Expected a padding newline before closing curly brace'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.configure" id="apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_blocks.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var optionName = this.getOptionName();

    assert(
        options === true || typeof options === 'number' || typeof options === 'object',
        optionName + ' option requires the value true, an Integer or an object'
    );

    this._checkOpen = true;
    this._checkClose = true;
    this._minLines = 0;

    if (typeof options === 'object') {
        assert(options.allExcept || options.open || options.close,
        optionName + 'option requires either "open", "close", "allExcept"');

        if (options.allExcept) {
            assert(Array.isArray(options.allExcept), optionName + ' option requires "allExcept" to be an array');
            assert(options.allExcept.length &gt; 0, optionName + ' option requires "allExcept" to have at least one ' +
            'item or be set to `true`');
            this._exceptConditionals = options.allExcept.indexOf('conditionals') &gt; -1;
            this._exceptFunctions = options.allExcept.indexOf('functions') &gt; -1;
        }

        if (options.open || options.close) {
            assert(typeof options.open === 'boolean' &amp;&amp; typeof options.close === 'boolean',
              this.getOptionName() + ' option requires the "open" and "close" ' +
              'properties to be booleans');

            this._checkOpen = options.open;
            this._checkClose = options.close;
        }
    } else if (typeof options === 'number') {
        this._minLines = options;
    } else {
        assert(options === true, this.getOptionName() + ' option requires either a true value, or an object');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.getOptionName" id="apidoc.element.jscs.require_padding_newlines_in_blocks.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_blocks.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requirePaddingNewlinesInBlocks';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_in_objects" id="apidoc.module.jscs.require_padding_newlines_in_objects">module jscs.require_padding_newlines_in_objects</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_objects.require_padding_newlines_in_objects" id="apidoc.element.jscs.require_padding_newlines_in_objects.require_padding_newlines_in_objects">
        function <span class="apidocSignatureSpan">jscs.</span>require_padding_newlines_in_objects
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_padding_newlines_in_objects = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_padding_newlines_in_objects.prototype" id="apidoc.module.jscs.require_padding_newlines_in_objects.prototype">module jscs.require_padding_newlines_in_objects.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_objects.prototype.check" id="apidoc.element.jscs.require_padding_newlines_in_objects.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_objects.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('ObjectExpression', function(node) {
        var openingBracket = node.getFirstToken();
        var nextToken = file.getNextToken(openingBracket);

        if (nextToken.type === 'Punctuator' &amp;&amp; nextToken.value === '}') {
            return;
        }

        errors.assert.differentLine({
            token: openingBracket,
            nextToken: nextToken,
            message: 'Missing newline after opening curly brace'
        });

        var closingBracket = file.getLastNodeToken(node);

        errors.assert.differentLine({
            token: file.getPrevToken(closingBracket),
            nextToken: closingBracket,
            message: 'Missing newline before closing curly brace'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_objects.prototype.configure" id="apidoc.element.jscs.require_padding_newlines_in_objects.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_objects.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    assert(
        value === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_padding_newlines_in_objects.prototype.getOptionName" id="apidoc.element.jscs.require_padding_newlines_in_objects.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_padding_newlines_in_objects.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requirePaddingNewLinesInObjects';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_parentheses_around_arrow_param" id="apidoc.module.jscs.require_parentheses_around_arrow_param">module jscs.require_parentheses_around_arrow_param</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_arrow_param.require_parentheses_around_arrow_param" id="apidoc.element.jscs.require_parentheses_around_arrow_param.require_parentheses_around_arrow_param">
        function <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_arrow_param
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_parentheses_around_arrow_param = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_parentheses_around_arrow_param.prototype" id="apidoc.module.jscs.require_parentheses_around_arrow_param.prototype">module jscs.require_parentheses_around_arrow_param.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.check" id="apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_parentheses_around_arrow_param.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    function isWrapped(node) {
        var openParensToken = file.getPrevToken(file.getFirstNodeToken(node));
        var closingParensToken = file.getNextToken(file.getLastNodeToken(node));
        var closingTokenValue = closingParensToken ? closingParensToken.value : '';

        return openParensToken.value + closingTokenValue === '()';
    }

    file.iterateNodesByType('ArrowFunctionExpression', function(node) {
        var params = node.params;
        var firstParam = params[0];

        if (params.length === 1 &amp;&amp; !isWrapped(firstParam)) {
            errors.add(
                'Wrap arrow function expressions in parentheses',
                firstParam
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.configure" id="apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_parentheses_around_arrow_param.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.getOptionName" id="apidoc.element.jscs.require_parentheses_around_arrow_param.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_parentheses_around_arrow_param.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireParenthesesAroundArrowParam';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_parentheses_around_iife" id="apidoc.module.jscs.require_parentheses_around_iife">module jscs.require_parentheses_around_iife</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_iife.require_parentheses_around_iife" id="apidoc.element.jscs.require_parentheses_around_iife.require_parentheses_around_iife">
        function <span class="apidocSignatureSpan">jscs.</span>require_parentheses_around_iife
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_parentheses_around_iife = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_parentheses_around_iife.prototype" id="apidoc.module.jscs.require_parentheses_around_iife.prototype">module jscs.require_parentheses_around_iife.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_iife.prototype.check" id="apidoc.element.jscs.require_parentheses_around_iife.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_parentheses_around_iife.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {

    function isWrapped(node) {
        var openParensToken = file.getPrevToken(file.getFirstNodeToken(node));

        var closingParensToken = file.getNextToken(file.getLastNodeToken(node));
        var closingTokenValue = closingParensToken ? closingParensToken.value : '';

        return openParensToken.value + closingTokenValue === '()';
    }

    file.iterateNodesByType('CallExpression', function(node) {
        var inner = utils.getFunctionNodeFromIIFE(node);

        if (inner &amp;&amp; !isWrapped(inner) &amp;&amp; !isWrapped(node)) {
            errors.add(
                'Wrap immediately invoked function expressions in parentheses',
                node
            );

        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_iife.prototype.configure" id="apidoc.element.jscs.require_parentheses_around_iife.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_parentheses_around_iife.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_parentheses_around_iife.prototype.getOptionName" id="apidoc.element.jscs.require_parentheses_around_iife.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_parentheses_around_iife.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireParenthesesAroundIIFE';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_quoted_keys_in_objects" id="apidoc.module.jscs.require_quoted_keys_in_objects">module jscs.require_quoted_keys_in_objects</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_quoted_keys_in_objects.require_quoted_keys_in_objects" id="apidoc.element.jscs.require_quoted_keys_in_objects.require_quoted_keys_in_objects">
        function <span class="apidocSignatureSpan">jscs.</span>require_quoted_keys_in_objects
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_quoted_keys_in_objects = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_quoted_keys_in_objects.prototype" id="apidoc.module.jscs.require_quoted_keys_in_objects.prototype">module jscs.require_quoted_keys_in_objects.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_quoted_keys_in_objects.prototype._fix" id="apidoc.element.jscs.require_quoted_keys_in_objects.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.require_quoted_keys_in_objects.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var element = error.element.firstChild;
    var newElem = new cst.Token(element.type, '"' + element.getSourceCode() + '"');

    element.parentElement.replaceChild(
        newElem,
        element
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &amp;&amp; instance._fix) {
        // "error.fixed = true" should go first, so rule can
        // decide for itself (with "error.fixed = false")
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_quoted_keys_in_objects.prototype.check" id="apidoc.element.jscs.require_quoted_keys_in_objects.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_quoted_keys_in_objects.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('ObjectExpression', function(node) {
        node.properties.forEach(function(property) {
            if (
                property.type === 'ObjectMethod' &amp;&amp;
                (property.kind === 'get' || property.kind === 'set')
            ) {
                return;
            }

            if (property.shorthand || property.method ||
                node.type === 'SpreadProperty') {
                return;
            }

            var key = property.key;
            if (key &amp;&amp; !(typeof key.value === 'string' &amp;&amp; key.type.indexOf('Literal') &gt; -1)) {
                errors.cast({
                    message: 'Object key without surrounding quotes',
                    element: property.firstChild
                });
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_quoted_keys_in_objects.prototype.configure" id="apidoc.element.jscs.require_quoted_keys_in_objects.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_quoted_keys_in_objects.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_quoted_keys_in_objects.prototype.getOptionName" id="apidoc.element.jscs.require_quoted_keys_in_objects.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_quoted_keys_in_objects.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireQuotedKeysInObjects';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_semicolons" id="apidoc.module.jscs.require_semicolons">module jscs.require_semicolons</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_semicolons.require_semicolons" id="apidoc.element.jscs.require_semicolons.require_semicolons">
        function <span class="apidocSignatureSpan">jscs.</span>require_semicolons
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_semicolons = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_semicolons.prototype" id="apidoc.module.jscs.require_semicolons.prototype">module jscs.require_semicolons.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_semicolons.prototype._fix" id="apidoc.element.jscs.require_semicolons.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.require_semicolons.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var element = error.element;
    var semicolon = new cst.Token('Punctuator', ';');

    while (element) {
        try {
            element.appendChild(semicolon);
            break;
        } catch (e) {}

        element = element.parentElement;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &amp;&amp; instance._fix) {
        // "error.fixed = true" should go first, so rule can
        // decide for itself (with "error.fixed = false")
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_semicolons.prototype.check" id="apidoc.element.jscs.require_semicolons.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_semicolons.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType([
        'VariableDeclaration',
        'ImportDeclaration',
        'ExportDeclaration',
        'ExportDefaultDeclaration',
        'ExportNamedDeclaration',
        'ExpressionStatement',
        'DoWhileStatement',
        'ReturnStatement',
        'ThrowStatement',
        'BreakStatement',
        'ContinueStatement',
        'DebuggerStatement',
        'ClassProperty'
    ], function(node) {
        // ignore variable declaration inside for and for-in
        if (node.type === 'VariableDeclaration') {
            if ((node.parentElement.type === 'ForInStatement' &amp;&amp; node.parentElement.left === node) ||
                (node.parentElement.type === 'ForOfStatement' &amp;&amp; node.parentElement.left === node) ||
                (node.parentElement.type === 'ForStatement' &amp;&amp; node.parentElement.init === node)) {
                return;
            }
        }

        // don't require semicolon for class and function exports
        if (node.type === 'ExportDefaultDeclaration' ||
            node.type === 'ExportNamedDeclaration') {
            if (node.declaration) {
                if (node.declaration.type === 'ClassDeclaration' ||
                    node.declaration.type === 'FunctionDeclaration') {
                    return;
                }
            }
        }

        // get last token inside node
        var lastToken = file.getLastNodeToken(node);
        var checkToken = lastToken;

        // if last token is not a semicolon punctuator, try to get next token in file
        if (checkToken &amp;&amp; (checkToken.type !== 'Punctuator' || checkToken.value !== ';')) {
            checkToken = file.getNextToken(checkToken);
        }

        // check token is semicolon
        if (!checkToken || checkToken.type !== 'Punctuator' || checkToken.value !== ';') {
            var entity = lastToken || node;

            errors.cast({
                message: 'Missing semicolon after statement',
                element: entity
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_semicolons.prototype.configure" id="apidoc.element.jscs.require_semicolons.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_semicolons.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_semicolons.prototype.getOptionName" id="apidoc.element.jscs.require_semicolons.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_semicolons.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSemicolons';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_shorthand_arrow_functions" id="apidoc.module.jscs.require_shorthand_arrow_functions">module jscs.require_shorthand_arrow_functions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_shorthand_arrow_functions.require_shorthand_arrow_functions" id="apidoc.element.jscs.require_shorthand_arrow_functions.require_shorthand_arrow_functions">
        function <span class="apidocSignatureSpan">jscs.</span>require_shorthand_arrow_functions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_shorthand_arrow_functions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_shorthand_arrow_functions.prototype" id="apidoc.module.jscs.require_shorthand_arrow_functions.prototype">module jscs.require_shorthand_arrow_functions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_shorthand_arrow_functions.prototype.check" id="apidoc.element.jscs.require_shorthand_arrow_functions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_shorthand_arrow_functions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('ArrowFunctionExpression', function(node) {
        var body = node.body;
        if (body.type === 'BlockStatement' &amp;&amp;
            body.body.length === 1 &amp;&amp;
            body.body[0].type === 'ReturnStatement') {
            errors.add(
                'Use the shorthand arrow function form',
                node.body
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_shorthand_arrow_functions.prototype.configure" id="apidoc.element.jscs.require_shorthand_arrow_functions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_shorthand_arrow_functions.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_shorthand_arrow_functions.prototype.getOptionName" id="apidoc.element.jscs.require_shorthand_arrow_functions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_shorthand_arrow_functions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireShorthandArrowFunctions';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_binary_operators" id="apidoc.module.jscs.require_space_after_binary_operators">module jscs.require_space_after_binary_operators</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_binary_operators.require_space_after_binary_operators" id="apidoc.element.jscs.require_space_after_binary_operators.require_space_after_binary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_binary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_binary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_binary_operators.prototype" id="apidoc.module.jscs.require_space_after_binary_operators.prototype">module jscs.require_space_after_binary_operators.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_binary_operators.prototype.check" id="apidoc.element.jscs.require_space_after_binary_operators.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_after_binary_operators.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operators = this._operatorIndex;

    // Comma
    if (operators[',']) {
        file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
            errors.assert.whitespaceBetween({
                token: token,
                nextToken: file.getNextToken(token),
                message: 'Operator , should not stick to following expression'
            });
        });
    }

    // For everything else
    file.iterateNodesByType(
        ['BinaryExpression', 'AssignmentExpression', 'VariableDeclarator', 'LogicalExpression'],
        function(node) {
            var operator;
            var expression;

            if (node.type === 'VariableDeclarator') {
                expression = node.init;
                operator = '=';
            } else {
                operator = node.operator;
                expression = node.right;
            }

            if (expression === null) {
                return;
            }

            var operatorToken = file.findPrevOperatorToken(
                file.getFirstNodeToken(expression),
                operator
            );

            var nextToken = file.getNextToken(operatorToken);

            if (operators[operator]) {
                errors.assert.whitespaceBetween({
                    token: operatorToken,
                    nextToken: nextToken,
                    message: 'Operator ' + operator + ' should not stick to following expression'
                });
            }
        }
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_binary_operators.prototype.configure" id="apidoc.element.jscs.require_space_after_binary_operators.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_after_binary_operators.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + ' option requires array or true value'
    );

    if (isTrue) {
        operators = allOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &lt; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_binary_operators.prototype.getOptionName" id="apidoc.element.jscs.require_space_after_binary_operators.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_after_binary_operators.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpaceAfterBinaryOperators';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_comma" id="apidoc.module.jscs.require_space_after_comma">module jscs.require_space_after_comma</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_comma.require_space_after_comma" id="apidoc.element.jscs.require_space_after_comma.require_space_after_comma">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_comma = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_comma.prototype" id="apidoc.module.jscs.require_space_after_comma.prototype">module jscs.require_space_after_comma.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_comma.prototype.check" id="apidoc.element.jscs.require_space_after_comma.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_after_comma.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptTrailingCommas = this._exceptTrailingCommas;
    file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
        if (exceptTrailingCommas &amp;&amp; [']', '}'].indexOf(file.getNextToken(token).value) &gt;= 0) {
            return;
        }
        errors.assert.whitespaceBetween({
            token: token,
            nextToken: file.getNextToken(token),
            message: 'Space required after comma'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_comma.prototype.configure" id="apidoc.element.jscs.require_space_after_comma.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_after_comma.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    if (typeof options !== 'object') {
        assert(
            options === true,
            this.getOptionName() + ' option requires true value or an object'
        );
        var _options = {allExcept: []};
        return this.configure(_options);
    }

    assert(
        Array.isArray(options.allExcept),
        ' property `allExcept` in ' + this.getOptionName() + ' should be an array of strings'
    );
    this._exceptTrailingCommas = options.allExcept.indexOf('trailing') &gt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_comma.prototype.getOptionName" id="apidoc.element.jscs.require_space_after_comma.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_after_comma.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpaceAfterComma';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_keywords" id="apidoc.module.jscs.require_space_after_keywords">module jscs.require_space_after_keywords</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_keywords.require_space_after_keywords" id="apidoc.element.jscs.require_space_after_keywords.require_space_after_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_keywords.prototype" id="apidoc.module.jscs.require_space_after_keywords.prototype">module jscs.require_space_after_keywords.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_keywords.prototype.check" id="apidoc.element.jscs.require_space_after_keywords.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_after_keywords.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
        var nextToken = file.getNextToken(token, {includeComments: true});

        if (nextToken.type === 'Punctuator' &amp;&amp; nextToken.value === ';') {
            return;
        }

        errors.assert.spacesBetween({
            token: token,
            nextToken: nextToken,
            exactly: 1,
            message: 'One space required after "' + token.value + '" keyword'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_keywords.prototype.configure" id="apidoc.element.jscs.require_space_after_keywords.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_after_keywords.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(
        Array.isArray(keywords) || keywords === true,
        this.getOptionName() + ' option requires array or true value');

    if (keywords === true) {
        keywords = defaultKeywords;
    }

    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_keywords.prototype.getOptionName" id="apidoc.element.jscs.require_space_after_keywords.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_after_keywords.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpaceAfterKeywords';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_line_comment" id="apidoc.module.jscs.require_space_after_line_comment">module jscs.require_space_after_line_comment</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_line_comment.require_space_after_line_comment" id="apidoc.element.jscs.require_space_after_line_comment.require_space_after_line_comment">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_line_comment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_line_comment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_line_comment.prototype" id="apidoc.module.jscs.require_space_after_line_comment.prototype">module jscs.require_space_after_line_comment.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_line_comment.prototype.check" id="apidoc.element.jscs.require_space_after_line_comment.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_after_line_comment.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var allExcept = this._allExcept;

    file.iterateTokensByType('CommentLine', function(comment) {
        var value = comment.value;

        // cutout exceptions
        allExcept.forEach(function(el) {
            if (value.indexOf(el) === 0) {
                value = value.substr(el.length);
            }
        });

        if (value.length === 0) {
            return;
        }

        if (value[0] !== ' ') {
            errors.add('Missing space after line comment', comment);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_line_comment.prototype.configure" id="apidoc.element.jscs.require_space_after_line_comment.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_after_line_comment.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true ||
        options === 'allowSlash' ||
        typeof options === 'object',
        this.getOptionName() + ' option requires a true value ' +
        'or an object with String[] `allExcept` property'
    );

    // verify first item in `allExcept` property in object (if it's an object)
    assert(
        typeof options !== 'object' ||
        Array.isArray(options.allExcept) &amp;&amp;
        typeof options.allExcept[0] === 'string',
        'Property `allExcept` in ' + this.getOptionName() + ' should be an array of strings'
    );

    // don't check triple slashed comments, microsoft js doc convention. see #593
    // exceptions. see #592
    // need to drop allowSlash support in 2.0. Fixes #697
    this._allExcept = options === 'allowSlash' ? ['/'] :
        options.allExcept || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_line_comment.prototype.getOptionName" id="apidoc.element.jscs.require_space_after_line_comment.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_after_line_comment.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpaceAfterLineComment';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_object_keys" id="apidoc.module.jscs.require_space_after_object_keys">module jscs.require_space_after_object_keys</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_object_keys.require_space_after_object_keys" id="apidoc.element.jscs.require_space_after_object_keys.require_space_after_object_keys">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_object_keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_object_keys = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_object_keys.prototype" id="apidoc.module.jscs.require_space_after_object_keys.prototype">module jscs.require_space_after_object_keys.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_object_keys.prototype.check" id="apidoc.element.jscs.require_space_after_object_keys.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_after_object_keys.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('ObjectExpression', function(node) {
        node.properties.forEach(function(property) {
            if (
                property.type === 'ObjectMethod' &amp;&amp;
                (property.kind === 'get' || property.kind === 'set')
            ) {
                return;
            }

            if (property.shorthand ||
                property.type === 'SpreadProperty') {
                return;
            }

            var token = file.getLastNodeToken(property.key);

            if (property.computed === true) {
                token = file.getNextToken(token);
            }

            errors.assert.whitespaceBetween({
                token: token,
                nextToken: file.getNextToken(token),
                message: 'Missing space after key'
            });
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_object_keys.prototype.configure" id="apidoc.element.jscs.require_space_after_object_keys.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_after_object_keys.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_object_keys.prototype.getOptionName" id="apidoc.element.jscs.require_space_after_object_keys.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_after_object_keys.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpaceAfterObjectKeys';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_prefix_unary_operators" id="apidoc.module.jscs.require_space_after_prefix_unary_operators">module jscs.require_space_after_prefix_unary_operators</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_prefix_unary_operators.require_space_after_prefix_unary_operators" id="apidoc.element.jscs.require_space_after_prefix_unary_operators.require_space_after_prefix_unary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_after_prefix_unary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_after_prefix_unary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_after_prefix_unary_operators.prototype" id="apidoc.module.jscs.require_space_after_prefix_unary_operators.prototype">module jscs.require_space_after_prefix_unary_operators.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.check" id="apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_after_prefix_unary_operators.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operatorIndex = this._operatorIndex;

    file.iterateNodesByType(['UnaryExpression', 'UpdateExpression'], function(node) {
        // Check "node.prefix" for prefix type of (inc|dec)rement
        if (node.prefix &amp;&amp; operatorIndex[node.operator]) {
            var argument = node.argument.type;
            var operatorToken = node.getFirstToken();
            var nextToken = file.getNextToken(operatorToken);

            // Do not report consecutive operators (#405)
            if (
                argument === 'UnaryExpression' || argument === 'UpdateExpression' &amp;&amp;
                nextToken.value !== '('
            ) {
                return;
            }

            errors.assert.whitespaceBetween({
                token: operatorToken,
                nextToken: nextToken,
                message: 'Operator ' + node.operator + ' should not stick to operand'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.configure" id="apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_after_prefix_unary_operators.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + ' option requires array or true value'
    );

    if (isTrue) {
        operators = defaultOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &lt; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.getOptionName" id="apidoc.element.jscs.require_space_after_prefix_unary_operators.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_after_prefix_unary_operators.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpaceAfterPrefixUnaryOperators';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_binary_operators" id="apidoc.module.jscs.require_space_before_binary_operators">module jscs.require_space_before_binary_operators</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_binary_operators.require_space_before_binary_operators" id="apidoc.element.jscs.require_space_before_binary_operators.require_space_before_binary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_binary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_binary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_binary_operators.prototype" id="apidoc.module.jscs.require_space_before_binary_operators.prototype">module jscs.require_space_before_binary_operators.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_binary_operators.prototype.check" id="apidoc.element.jscs.require_space_before_binary_operators.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_before_binary_operators.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operators = this._operatorIndex;

    // Comma
    if (operators[',']) {
        file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
            errors.assert.whitespaceBetween({
                token: file.getPrevToken(token),
                nextToken: token,
                message: 'Operator , should not stick to preceding expression'
            });
        });
    }

    // For everything else
    file.iterateNodesByType(
        ['BinaryExpression', 'AssignmentExpression', 'VariableDeclarator', 'LogicalExpression'],
        function(node) {
            var operator;
            var expression;

            if (node.type === 'VariableDeclarator') {
                expression = node.init;
                operator = '=';
            } else {
                operator = node.operator;
                expression = node.right;
            }

            if (expression === null) {
                return;
            }

            var operatorToken = file.findPrevOperatorToken(
                file.getFirstNodeToken(expression),
                operator
            );

            var prevToken = file.getPrevToken(operatorToken);

            if (operators[operator]) {
                errors.assert.whitespaceBetween({
                    token: prevToken,
                    nextToken: operatorToken,
                    message: 'Operator ' + operator + ' should not stick to preceding expression'
                });
            }
        }
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_binary_operators.prototype.configure" id="apidoc.element.jscs.require_space_before_binary_operators.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_before_binary_operators.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + ' option requires array or true value'
    );

    if (isTrue) {
        operators = allOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &lt; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_binary_operators.prototype.getOptionName" id="apidoc.element.jscs.require_space_before_binary_operators.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_before_binary_operators.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpaceBeforeBinaryOperators';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_block_statements" id="apidoc.module.jscs.require_space_before_block_statements">module jscs.require_space_before_block_statements</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_block_statements.require_space_before_block_statements" id="apidoc.element.jscs.require_space_before_block_statements.require_space_before_block_statements">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_block_statements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_block_statements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_block_statements.prototype" id="apidoc.module.jscs.require_space_before_block_statements.prototype">module jscs.require_space_before_block_statements.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_block_statements.prototype.check" id="apidoc.element.jscs.require_space_before_block_statements.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_before_block_statements.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var count = this._count;
    file.iterateNodesByType('BlockStatement', function(node) {
        var first = node.getFirstToken();

        errors.assert.spacesBetween({
            token: file.getPrevToken(first),
            nextToken: first,
            atLeast: count,
            disallowNewLine: true,
            message: 'One (or more) spaces required before opening brace for block expressions'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_block_statements.prototype.configure" id="apidoc.element.jscs.require_space_before_block_statements.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_before_block_statements.prototype.</span>configure
        <span class="apidocSignatureSpan">(requireSpaceBeforeBlockStatements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (requireSpaceBeforeBlockStatements) {
    assert(
        typeof requireSpaceBeforeBlockStatements === 'boolean' ||
        typeof requireSpaceBeforeBlockStatements === 'number',
        this.getOptionName() + ' option requires number or bolean'
    );
    assert(
        requireSpaceBeforeBlockStatements &gt;= 1,
        this.getOptionName() +
          ' option requires true value or a number greater than equal to 1 or should be removed'
    );
    this._count = +requireSpaceBeforeBlockStatements;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_block_statements.prototype.getOptionName" id="apidoc.element.jscs.require_space_before_block_statements.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_before_block_statements.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpaceBeforeBlockStatements';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_comma" id="apidoc.module.jscs.require_space_before_comma">module jscs.require_space_before_comma</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_comma.require_space_before_comma" id="apidoc.element.jscs.require_space_before_comma.require_space_before_comma">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_comma = function () {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_comma.prototype" id="apidoc.module.jscs.require_space_before_comma.prototype">module jscs.require_space_before_comma.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_comma.prototype.check" id="apidoc.element.jscs.require_space_before_comma.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_before_comma.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
        var prevToken = token.getPreviousCodeToken();

        errors.assert.whitespaceBetween({
            token: prevToken,
            nextToken: token,
            message: 'Space required before comma'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_comma.prototype.configure" id="apidoc.element.jscs.require_space_before_comma.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_before_comma.prototype.</span>configure
        <span class="apidocSignatureSpan">(option)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (option) {
    assert(
        option === true,
        this.getOptionName() + ' option requires true value'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_comma.prototype.getOptionName" id="apidoc.element.jscs.require_space_before_comma.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_before_comma.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpaceBeforeComma';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_destructured_values" id="apidoc.module.jscs.require_space_before_destructured_values">module jscs.require_space_before_destructured_values</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_destructured_values.require_space_before_destructured_values" id="apidoc.element.jscs.require_space_before_destructured_values.require_space_before_destructured_values">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_destructured_values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_destructured_values = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_destructured_values.prototype" id="apidoc.module.jscs.require_space_before_destructured_values.prototype">module jscs.require_space_before_destructured_values.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_destructured_values.prototype.check" id="apidoc.element.jscs.require_space_before_destructured_values.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_before_destructured_values.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var checkSpaceMissing = function(propKey) {
        var keyToken = file.getFirstNodeToken(propKey);
        var colon    = file.findNextToken(keyToken, 'Punctuator', ':');

        errors.assert.whitespaceBetween({
            token: colon,
            nextToken: file.getNextToken(colon),
            message: 'Missing space after key colon'
        });
    };

    var letsCheckThisOne = function(item) {

        if (!item) {
            return;
        }

        if (item.type === 'ObjectPattern') {
            item.properties.forEach(function(property) {

                if (property.shorthand || property.method) {
                    return;
                }

                checkSpaceMissing(property.key);

                //Strategy for nested structures
                var propValue = property.value;

                if (!propValue) {
                    return;
                }

                letsCheckThisOne(propValue);
            });
        }

        if (item.type === 'ArrayPattern') {
            item.elements.forEach(letsCheckThisOne);
        }
    };

    file.iterateNodesByType(['VariableDeclaration', 'AssignmentExpression'], function(node) {

        if (node.type === 'VariableDeclaration') {
            node.declarations.forEach(function(declaration) {
                letsCheckThisOne(declaration.id || {});
            });
        }

        if (node.type === 'AssignmentExpression') {
            var left = node.left;

            if (left) {
                letsCheckThisOne(left);
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_destructured_values.prototype.configure" id="apidoc.element.jscs.require_space_before_destructured_values.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_before_destructured_values.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_destructured_values.prototype.getOptionName" id="apidoc.element.jscs.require_space_before_destructured_values.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_before_destructured_values.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpaceBeforeDestructuredValues';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_keywords" id="apidoc.module.jscs.require_space_before_keywords">module jscs.require_space_before_keywords</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_keywords.require_space_before_keywords" id="apidoc.element.jscs.require_space_before_keywords.require_space_before_keywords">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_keywords
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_keywords = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_keywords.prototype" id="apidoc.module.jscs.require_space_before_keywords.prototype">module jscs.require_space_before_keywords.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_keywords.prototype.check" id="apidoc.element.jscs.require_space_before_keywords.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_before_keywords.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
        var prevToken = file.getPrevToken(token, {includeComments: true});
        if (!prevToken || prevToken.isComment) {
            return;
        }

        if (prevToken.type !== 'Punctuator' || prevToken.value !== ';') {
            errors.assert.whitespaceBetween({
                token: prevToken,
                nextToken: token,
                message: 'Missing space before "' + token.value + '" keyword'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_keywords.prototype.configure" id="apidoc.element.jscs.require_space_before_keywords.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_before_keywords.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    var isValidObject = (keywords === Object(keywords) &amp;&amp; keywords.hasOwnProperty('allExcept'));

    assert(
        Array.isArray(keywords) || keywords === true || isValidObject,
        this.getOptionName() + ' option requires array, object with "allExcept" property or true value');

    var excludedKeywords = ignoredKeywords;
    if (isValidObject) {
        excludedKeywords = keywords.allExcept;
    }

    if (!Array.isArray(keywords)) {
        keywords = defaultKeywords.filter(function(keyword) {
            return (excludedKeywords.indexOf(keyword) === -1);
        });
    }

    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_keywords.prototype.getOptionName" id="apidoc.element.jscs.require_space_before_keywords.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_before_keywords.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpaceBeforeKeywords';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_object_values" id="apidoc.module.jscs.require_space_before_object_values">module jscs.require_space_before_object_values</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_object_values.require_space_before_object_values" id="apidoc.element.jscs.require_space_before_object_values.require_space_before_object_values">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_object_values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_object_values = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_object_values.prototype" id="apidoc.module.jscs.require_space_before_object_values.prototype">module jscs.require_space_before_object_values.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_object_values.prototype.check" id="apidoc.element.jscs.require_space_before_object_values.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_before_object_values.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('ObjectExpression', function(node) {
        node.properties.forEach(function(property) {
            if (
               property.type === 'ObjectMethod' &amp;&amp;
               (property.kind === 'get' || property.kind === 'set')
           ) {
                return;
            }

            if (property.shorthand || property.method ||
                property.type === 'SpreadProperty') {
                return;
            }

            var keyToken = file.getFirstNodeToken(property.key);

            var colon = file.findNextToken(keyToken, 'Punctuator', ':');

            errors.assert.whitespaceBetween({
                token: colon,
                nextToken: file.getNextToken(colon),
                message: 'Missing space after key colon'
            });
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_object_values.prototype.configure" id="apidoc.element.jscs.require_space_before_object_values.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_before_object_values.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_object_values.prototype.getOptionName" id="apidoc.element.jscs.require_space_before_object_values.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_before_object_values.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpaceBeforeObjectValues';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_postfix_unary_operators" id="apidoc.module.jscs.require_space_before_postfix_unary_operators">module jscs.require_space_before_postfix_unary_operators</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_postfix_unary_operators.require_space_before_postfix_unary_operators" id="apidoc.element.jscs.require_space_before_postfix_unary_operators.require_space_before_postfix_unary_operators">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_before_postfix_unary_operators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_before_postfix_unary_operators = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_before_postfix_unary_operators.prototype" id="apidoc.module.jscs.require_space_before_postfix_unary_operators.prototype">module jscs.require_space_before_postfix_unary_operators.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.check" id="apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_before_postfix_unary_operators.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operatorIndex = this._operatorIndex;

    // 'UpdateExpression' involve only ++ and -- operators
    file.iterateNodesByType('UpdateExpression', function(node) {
        // "!node.prefix" means postfix type of (inc|dec)rement
        if (!node.prefix &amp;&amp; operatorIndex[node.operator]) {
            var operatorToken = file.getLastNodeToken(node);

            errors.assert.whitespaceBetween({
                token: file.getPrevToken(operatorToken),
                nextToken: operatorToken,
                message: 'Operator ' + node.operator + ' should not stick to operand'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.configure" id="apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_before_postfix_unary_operators.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + ' option requires array or true value'
    );

    if (isTrue) {
        operators = defaultOperators;
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &lt; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.getOptionName" id="apidoc.element.jscs.require_space_before_postfix_unary_operators.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_before_postfix_unary_operators.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpaceBeforePostfixUnaryOperators';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_between_arguments" id="apidoc.module.jscs.require_space_between_arguments">module jscs.require_space_between_arguments</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_between_arguments.require_space_between_arguments" id="apidoc.element.jscs.require_space_between_arguments.require_space_between_arguments">
        function <span class="apidocSignatureSpan">jscs.</span>require_space_between_arguments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_space_between_arguments = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_space_between_arguments.prototype" id="apidoc.module.jscs.require_space_between_arguments.prototype">module jscs.require_space_between_arguments.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_space_between_arguments.prototype.check" id="apidoc.element.jscs.require_space_between_arguments.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_space_between_arguments.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(['CallExpression'], function(node) {
        node.arguments.forEach(function(param) {
            var punctuatorToken = file.getPrevToken(file.getFirstNodeToken(param));
            if (punctuatorToken.value === ',') {
                errors.assert.whitespaceBetween({
                    token: punctuatorToken,
                    nextToken: file.getNextToken(punctuatorToken)
                });
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_between_arguments.prototype.configure" id="apidoc.element.jscs.require_space_between_arguments.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_space_between_arguments.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_space_between_arguments.prototype.getOptionName" id="apidoc.element.jscs.require_space_between_arguments.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_space_between_arguments.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpaceBetweenArguments';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_anonymous_function_expression" id="apidoc.module.jscs.require_spaces_in_anonymous_function_expression">module jscs.require_spaces_in_anonymous_function_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression.require_spaces_in_anonymous_function_expression" id="apidoc.element.jscs.require_spaces_in_anonymous_function_expression.require_spaces_in_anonymous_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_anonymous_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_anonymous_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_anonymous_function_expression.prototype" id="apidoc.module.jscs.require_spaces_in_anonymous_function_expression.prototype">module jscs.require_spaces_in_anonymous_function_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.check" id="apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_anonymous_function_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;
    var exceptions = this._exceptions;

    file.iterateNodesByType(['FunctionExpression'], function(node) {
        var functionNode = node;
        var parent = node.parentElement;

        // Ignore syntactic sugar for getters and setters.
        if (parent.type === 'Property' &amp;&amp; (parent.kind === 'get' || parent.kind === 'set')) {
            return;
        }

        // shorthand or constructor methods
        if (parent.method || parent.type === 'MethodDefinition') {
            functionNode = parent.key;
            if (exceptions.shorthand) {
                return;
            }
        }

        // anonymous function expressions only
        if (node.id) {
            return;
        }

        if (beforeOpeningRoundBrace) {
            var functionToken = file.getFirstNodeToken(functionNode);
            if (node.async &amp;&amp; functionToken.value === 'async') {
                functionToken = file.getNextToken(functionToken);
            }
            // if generator, set token to be * instead
            if (node.generator &amp;&amp; functionToken.value === 'function') {
                functionToken = file.getNextToken(functionToken);
            }
            errors.assert.whitespaceBetween({
                token: functionToken,
                nextToken: file.getNextToken(functionToken),
                message: 'Missing space before opening round brace'
            });
        }

        if (beforeOpeningCurlyBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            errors.assert.whitespaceBetween({
                token: file.getPrevToken(bodyToken),
                nextToken: bodyToken,
                message: 'Missing space before opening curly brace'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.configure" id="apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_anonymous_function_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    this._exceptions = {
        'shorthand': false
    };

    assert(
        typeof options === 'object',
        this.getOptionName() + ' option must be the object'
    );

    if ('beforeOpeningRoundBrace' in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + '.beforeOpeningRoundBrace ' +
            'property requires true value or should be removed'
        );
    }

    if ('beforeOpeningCurlyBrace' in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + '.beforeOpeningCurlyBrace ' +
            'property requires true value or should be removed'
        );
    }

    if ('allExcept' in options) {
        if (typeof options.allExcept === 'object') {
            assert(
                Array.isArray(options.allExcept),
                this.getOptionName() + ' option requires "allExcept" to be ' +
                'an array'
            );
            assert(
                options.allExcept.length &gt; 0,
                this.getOptionName() + ' option requires "allExcept" to have ' +
                'at least one item or be set to `true`'
            );
            options.allExcept.forEach(function(except) {
                if (except === 'shorthand') {
                    this._exceptions.shorthand = true;
                } else {
                    assert(false, this.getOptionName() + ' option requires ' +
                    '"allExcept" to be an array containing "shorthand"');
                }
            }, this);
        } else {
            assert(
                options.allExcept === true,
                this.getOptionName() + ' option requires a true value or array'
            );
            this._exceptions.shorthand = true;
        }
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + ' must have beforeOpeningCurlyBrace ' +
        ' or beforeOpeningRoundBrace property'
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_anonymous_function_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_anonymous_function_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpacesInAnonymousFunctionExpression';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_call_expression" id="apidoc.module.jscs.require_spaces_in_call_expression">module jscs.require_spaces_in_call_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_call_expression.require_spaces_in_call_expression" id="apidoc.element.jscs.require_spaces_in_call_expression.require_spaces_in_call_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_call_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_call_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_call_expression.prototype" id="apidoc.module.jscs.require_spaces_in_call_expression.prototype">module jscs.require_spaces_in_call_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_call_expression.prototype.check" id="apidoc.element.jscs.require_spaces_in_call_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_call_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('CallExpression', function(node) {
        var lastCalleeToken = file.getLastNodeToken(node.callee);
        var roundBraceToken = file.findNextToken(lastCalleeToken, 'Punctuator', '(');

        errors.assert.whitespaceBetween({
            token: file.getPrevToken(roundBraceToken),
            nextToken: roundBraceToken,
            message: 'Missing space before opening round brace'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_call_expression.prototype.configure" id="apidoc.element.jscs.require_spaces_in_call_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_call_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_call_expression.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_call_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_call_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpacesInCallExpression';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_conditional_expression" id="apidoc.module.jscs.require_spaces_in_conditional_expression">module jscs.require_spaces_in_conditional_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_conditional_expression.require_spaces_in_conditional_expression" id="apidoc.element.jscs.require_spaces_in_conditional_expression.require_spaces_in_conditional_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_conditional_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_conditional_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_conditional_expression.prototype" id="apidoc.module.jscs.require_spaces_in_conditional_expression.prototype">module jscs.require_spaces_in_conditional_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.check" id="apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_conditional_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(['ConditionalExpression'], function(node) {
        var consequent = node.consequent;
        var alternate = node.alternate;
        var consequentToken = file.getFirstNodeToken(consequent);
        var alternateToken = file.getFirstNodeToken(alternate);
        var questionMarkToken = file.findPrevOperatorToken(consequentToken, '?');
        var colonToken = file.findPrevOperatorToken(alternateToken, ':');
        var token;

        if (this._afterTest) {
            token = file.getPrevToken(questionMarkToken);
            errors.assert.whitespaceBetween({
                token: token,
                nextToken: questionMarkToken,
                message: 'Missing space after test'
            });
        }

        if (this._beforeConsequent) {
            token = file.getNextToken(questionMarkToken);
            errors.assert.whitespaceBetween({
                token: questionMarkToken,
                nextToken: token,
                message: 'Missing space before consequent'
            });
        }

        if (this._afterConsequent) {
            token = file.getPrevToken(colonToken);
            errors.assert.whitespaceBetween({
                token: token,
                nextToken: colonToken,
                message: 'Missing space after consequent'
            });
        }

        if (this._beforeAlternate) {
            token = file.getNextToken(colonToken);
            errors.assert.whitespaceBetween({
                token: colonToken,
                nextToken: token,
                message: 'Missing space before alternate'
            });
        }
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.configure" id="apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_conditional_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var validProperties = [
        'afterTest',
        'beforeConsequent',
        'afterConsequent',
        'beforeAlternate'
    ];
    var optionName = this.getOptionName();

    if (options === true) {
        options = {
            'afterTest': true,
            'beforeConsequent': true,
            'afterConsequent': true,
            'beforeAlternate': true
        };
    }

    assert(
        typeof options === 'object',
        optionName + ' option requires a true value or an object'
    );

    var isProperlyConfigured = validProperties.some(function(key) {
        var isPresent = key in options;

        if (isPresent) {
            assert(
                options[key] === true,
                optionName + '.' + key + ' property requires true value or should be removed'
            );
        }

        return isPresent;
    });

    assert(
        isProperlyConfigured,
        optionName + ' must have at least 1 of the following properties: ' + validProperties.join(', ')
    );

    validProperties.forEach(function(property) {
        this['_' + property] = Boolean(options[property]);
    }.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_conditional_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_conditional_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpacesInConditionalExpression';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_for_statement" id="apidoc.module.jscs.require_spaces_in_for_statement">module jscs.require_spaces_in_for_statement</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_for_statement.require_spaces_in_for_statement" id="apidoc.element.jscs.require_spaces_in_for_statement.require_spaces_in_for_statement">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_for_statement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_for_statement = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_for_statement.prototype" id="apidoc.module.jscs.require_spaces_in_for_statement.prototype">module jscs.require_spaces_in_for_statement.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_for_statement.prototype.check" id="apidoc.element.jscs.require_spaces_in_for_statement.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_for_statement.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('ForStatement', function(node) {
        if (node.test) {
            var testToken = file.getFirstNodeToken(node.test);
            var prevToken = file.getPrevToken(testToken);

            if (prevToken.value === '(' &amp;&amp;
                TokenCategorizer.categorizeOpenParen(prevToken) === 'ParenthesizedExpression') {
                testToken = prevToken;
                prevToken = file.getPrevToken(prevToken);
            }
            errors.assert.spacesBetween({
                token: prevToken,
                nextToken: testToken,
                exactly: 1,
                message: 'One space required after semicolon'
            });
        }
        if (node.update) {
            var updateToken = file.getFirstNodeToken(node.update);
            errors.assert.spacesBetween({
                token: file.getPrevToken(updateToken),
                nextToken: updateToken,
                exactly: 1,
                message: 'One space required after semicolon'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_for_statement.prototype.configure" id="apidoc.element.jscs.require_spaces_in_for_statement.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_for_statement.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_for_statement.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_for_statement.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_for_statement.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpacesInForStatement';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_function" id="apidoc.module.jscs.require_spaces_in_function">module jscs.require_spaces_in_function</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function.require_spaces_in_function" id="apidoc.element.jscs.require_spaces_in_function.require_spaces_in_function">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_function = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_function.prototype" id="apidoc.module.jscs.require_spaces_in_function.prototype">module jscs.require_spaces_in_function.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function.prototype.check" id="apidoc.element.jscs.require_spaces_in_function.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType(['FunctionDeclaration', 'FunctionExpression'], function(node) {
        // for a named function, use node.id
        var functionNode = node.id || node;
        var parent = node.parentElement;

        // Ignore syntactic sugar for getters and setters.
        if (parent.type === 'Property' &amp;&amp; (parent.kind === 'get' || parent.kind === 'set')) {
            return;
        }

        // shorthand or constructor methods
        if (parent.method || parent.type === 'MethodDefinition') {
            functionNode = parent.key;
        }

        if (beforeOpeningRoundBrace) {
            var functionToken = file.getFirstNodeToken(functionNode);
            if (node.async &amp;&amp; functionToken.value === 'async') {
                functionToken = file.getNextToken(functionToken);
            }
            // if generator, set token to be * instead
            if (node.generator &amp;&amp; functionToken.value === 'function') {
                functionToken = file.getNextToken(functionToken);
            }
            errors.assert.whitespaceBetween({
                token: functionToken,
                nextToken: file.getNextToken(functionToken),
                message: 'Missing space before opening round brace'
            });
        }

        if (beforeOpeningCurlyBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            errors.assert.whitespaceBetween({
                token: file.getPrevToken(bodyToken),
                nextToken: bodyToken,
                message: 'Missing space before opening curly brace'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function.prototype.configure" id="apidoc.element.jscs.require_spaces_in_function.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === 'object',
        this.getOptionName() + ' option must be the object'
    );

    if ('beforeOpeningRoundBrace' in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + '.beforeOpeningRoundBrace ' +
            'property requires true value or should be removed'
        );
    }

    if ('beforeOpeningCurlyBrace' in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + '.beforeOpeningCurlyBrace ' +
            'property requires true value or should be removed'
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + ' must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property'
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_function.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpacesInFunction';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_function_declaration" id="apidoc.module.jscs.require_spaces_in_function_declaration">module jscs.require_spaces_in_function_declaration</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_declaration.require_spaces_in_function_declaration" id="apidoc.element.jscs.require_spaces_in_function_declaration.require_spaces_in_function_declaration">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_declaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_function_declaration = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_function_declaration.prototype" id="apidoc.module.jscs.require_spaces_in_function_declaration.prototype">module jscs.require_spaces_in_function_declaration.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_declaration.prototype.check" id="apidoc.element.jscs.require_spaces_in_function_declaration.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_declaration.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType(['FunctionDeclaration'], function(node) {
        // Exception for `export default function` #1376
        if (!node.id) {
            return;
        }

        if (beforeOpeningRoundBrace) {
            // for a named function, use node.id
            var functionToken = file.getFirstNodeToken(node.id || node);
            if (node.async &amp;&amp; functionToken.value === 'async') {
                functionToken = file.getNextToken(functionToken);
            }
            // if generator, set token to be * instead
            if (node.generator &amp;&amp; functionToken.value === 'function') {
                functionToken = file.getNextToken(functionToken);
            }
            errors.assert.whitespaceBetween({
                token: functionToken,
                nextToken: file.getNextToken(functionToken),
                message: 'Missing space before opening round brace'
            });
        }

        if (beforeOpeningCurlyBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            errors.assert.whitespaceBetween({
                token: file.getPrevToken(bodyToken),
                nextToken: bodyToken,
                message: 'Missing space before opening curly brace'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_declaration.prototype.configure" id="apidoc.element.jscs.require_spaces_in_function_declaration.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_declaration.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === 'object',
        this.getOptionName() + ' option must be the object'
    );

    if ('beforeOpeningRoundBrace' in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + '.beforeOpeningRoundBrace ' +
            'property requires true value or should be removed'
        );
    }

    if ('beforeOpeningCurlyBrace' in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + '.beforeOpeningCurlyBrace ' +
            'property requires true value or should be removed'
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + ' must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property'
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_declaration.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_function_declaration.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_declaration.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpacesInFunctionDeclaration';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_function_expression" id="apidoc.module.jscs.require_spaces_in_function_expression">module jscs.require_spaces_in_function_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_expression.require_spaces_in_function_expression" id="apidoc.element.jscs.require_spaces_in_function_expression.require_spaces_in_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_function_expression.prototype" id="apidoc.module.jscs.require_spaces_in_function_expression.prototype">module jscs.require_spaces_in_function_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_expression.prototype.check" id="apidoc.element.jscs.require_spaces_in_function_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType('FunctionExpression', function(node) {
        // for a named function, use node.id
        var functionNode = node.id || node;
        var parent = node.parentElement;

        // Ignore syntactic sugar for getters and setters.
        if (parent.type === 'Property' &amp;&amp; (parent.kind === 'get' || parent.kind === 'set')) {
            return;
        }

        // shorthand or constructor methods
        if (parent.method || parent.type === 'MethodDefinition') {
            functionNode = parent.key;
        }

        if (beforeOpeningRoundBrace) {
            var functionToken = file.getFirstNodeToken(functionNode);
            if (node.async &amp;&amp; functionToken.value === 'async') {
                functionToken = file.getNextToken(functionToken);
            }
            // if generator, set token to be * instead
            if (node.generator &amp;&amp; functionToken.value === 'function') {
                functionToken = file.getNextToken(functionToken);
            }
            errors.assert.whitespaceBetween({
                token: functionToken,
                nextToken: file.getNextToken(functionToken),
                message: 'Missing space before opening round brace'
            });
        }

        if (beforeOpeningCurlyBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            errors.assert.whitespaceBetween({
                token: file.getPrevToken(bodyToken),
                nextToken: bodyToken,
                message: 'Missing space before opening curly brace'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_expression.prototype.configure" id="apidoc.element.jscs.require_spaces_in_function_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === 'object',
        this.getOptionName() + ' option must be the object'
    );

    if ('beforeOpeningRoundBrace' in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + '.beforeOpeningRoundBrace ' +
            'property requires true value or should be removed'
        );
    }

    if ('beforeOpeningCurlyBrace' in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + '.beforeOpeningCurlyBrace ' +
            'property requires true value or should be removed'
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + ' must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property'
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_function_expression.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_function_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_function_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpacesInFunctionExpression';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_generator" id="apidoc.module.jscs.require_spaces_in_generator">module jscs.require_spaces_in_generator</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_generator.require_spaces_in_generator" id="apidoc.element.jscs.require_spaces_in_generator.require_spaces_in_generator">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_generator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_generator = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_generator.prototype" id="apidoc.module.jscs.require_spaces_in_generator.prototype">module jscs.require_spaces_in_generator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_generator.prototype.check" id="apidoc.element.jscs.require_spaces_in_generator.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_generator.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeStar = this._beforeStar;
    var afterStar = this._afterStar;

    file.iterateNodesByType(['FunctionDeclaration', 'FunctionExpression'], function(node) {
        if (!node.generator) {
            return;
        }

        var parent = node.parentElement;
        var shorthand = false;

        // shorthand or constructor methods
        if (parent.method || parent.type === 'MethodDefinition') {
            shorthand = true;
            node = parent.key;
        }

        var currentToken = node.getFirstToken();

        if (node.async &amp;&amp; currentToken.value === 'async') {
            currentToken = file.getNextToken(currentToken);
        }

        if (beforeStar &amp;&amp; !shorthand) {
            // currentToken assigned outside of function
            errors.assert.whitespaceBetween({
                token: currentToken,
                nextToken: file.getNextToken(currentToken),
                message: 'Missing space before star'
            });
        }

        if (afterStar) {
            if (shorthand) {
                currentToken = file.getPrevToken(currentToken);
            } else {
                // currentToken reassigned for star token
                currentToken = file.getNextToken(currentToken);
            }

            errors.assert.whitespaceBetween({
                token: currentToken,
                nextToken: file.getNextToken(currentToken),
                message: 'Missing space after star'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_generator.prototype.configure" id="apidoc.element.jscs.require_spaces_in_generator.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_generator.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === 'object',
        this.getOptionName() + ' option must be an object'
    );

    if ('beforeStar' in options) {
        assert(
            options.beforeStar === true,
            this.getOptionName() + '.beforeStar ' +
            'property requires true value or should be removed'
        );
    }
    if ('afterStar' in options) {
        assert(
            options.afterStar === true,
            this.getOptionName() + '.afterStar ' +
            'property requires true value or should be removed'
        );
    }

    assert(
        options.beforeStar || options.afterStar,
        this.getOptionName() + ' must have beforeStar or afterStar property'
    );

    this._beforeStar = options.beforeStar;
    this._afterStar = options.afterStar;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_generator.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_generator.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_generator.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpacesInGenerator';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_named_function_expression" id="apidoc.module.jscs.require_spaces_in_named_function_expression">module jscs.require_spaces_in_named_function_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_named_function_expression.require_spaces_in_named_function_expression" id="apidoc.element.jscs.require_spaces_in_named_function_expression.require_spaces_in_named_function_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_in_named_function_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_in_named_function_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_in_named_function_expression.prototype" id="apidoc.module.jscs.require_spaces_in_named_function_expression.prototype">module jscs.require_spaces_in_named_function_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.check" id="apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_named_function_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
    var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

    file.iterateNodesByType(['FunctionExpression'], function(node) {
        var functionNode = node.id;
        var parent = node.parentElement;

        // Ignore syntactic sugar for getters and setters.
        if (parent.type === 'Property' &amp;&amp; (parent.kind === 'get' || parent.kind === 'set')) {
            return;
        }

        // shorthand or constructor methods
        if (parent.method || parent.type === 'MethodDefinition') {
            functionNode = parent.key;
        }

        // named function expressions only
        if (node.id) {
            if (beforeOpeningRoundBrace) {
                var functionToken = file.getFirstNodeToken(functionNode);
                if (node.async &amp;&amp; functionToken.value === 'async') {
                    functionToken = file.getNextToken(functionToken);
                }
                errors.assert.whitespaceBetween({
                    token: functionToken,
                    nextToken: file.getNextToken(functionToken),
                    message: 'Missing space before opening round brace'
                });
            }

            if (beforeOpeningCurlyBrace) {
                var bodyToken = file.getFirstNodeToken(node.body);
                errors.assert.whitespaceBetween({
                    token: file.getPrevToken(bodyToken),
                    nextToken: bodyToken,
                    message: 'Missing space before opening curly brace'
                });
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.configure" id="apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_named_function_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === 'object',
        this.getOptionName() + ' option must be the object'
    );

    if ('beforeOpeningRoundBrace' in options) {
        assert(
            options.beforeOpeningRoundBrace === true,
            this.getOptionName() + '.beforeOpeningRoundBrace ' +
            'property requires true value or should be removed'
        );
    }

    if ('beforeOpeningCurlyBrace' in options) {
        assert(
            options.beforeOpeningCurlyBrace === true,
            this.getOptionName() + '.beforeOpeningCurlyBrace ' +
            'property requires true value or should be removed'
        );
    }

    assert(
        options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
        this.getOptionName() + ' must have beforeOpeningCurlyBrace ' +
        'or beforeOpeningRoundBrace property'
    );

    this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
    this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_in_named_function_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_in_named_function_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpacesInNamedFunctionExpression';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_array_brackets" id="apidoc.module.jscs.require_spaces_inside_array_brackets">module jscs.require_spaces_inside_array_brackets</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_array_brackets.require_spaces_inside_array_brackets" id="apidoc.element.jscs.require_spaces_inside_array_brackets.require_spaces_inside_array_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_array_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_array_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_array_brackets.prototype" id="apidoc.module.jscs.require_spaces_inside_array_brackets.prototype">module jscs.require_spaces_inside_array_brackets.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.check" id="apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_array_brackets.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateNodesByType('ArrayExpression', function(node) {
        var openBracket = node.getFirstToken();
        var afterOpen = file.getNextToken(openBracket, {includeComments: true});
        var closeBracket = file.getLastNodeToken(node);
        var beforeClose = file.getPrevToken(closeBracket, {includeComments: true});

        // Skip for empty array brackets
        if (afterOpen.value === ']') {
            return;
        }

        if (!(afterOpen.value in exceptions)) {
            errors.assert.spacesBetween({
                token: openBracket,
                nextToken: afterOpen,
                exactly: 1,
                message: 'One space required after opening bracket'
            });
        }

        if (!(beforeClose.value in exceptions)) {
            errors.assert.spacesBetween({
                token: beforeClose,
                nextToken: closeBracket,
                exactly: 1,
                message: 'One space required before closing bracket'
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.configure" id="apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_array_brackets.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var mode;
    var modes = {
        'all': true,
        'allButNested': true
    };
    var isObject = typeof value === 'object';

    var error = this.getOptionName() + ' rule' +
    ' requires string value "all" or "allButNested" or object';

    if (typeof value === 'string') {
        assert(modes[value], error);

    } else if (isObject) {
        assert('allExcept' in value, error);
    } else {
        assert(false, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);

    } else {
        mode = value;
    }

    if (mode === 'allButNested') {
        this._exceptions['['] = this._exceptions[']'] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_inside_array_brackets.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_array_brackets.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpacesInsideArrayBrackets';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_brackets" id="apidoc.module.jscs.require_spaces_inside_brackets">module jscs.require_spaces_inside_brackets</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_brackets.require_spaces_inside_brackets" id="apidoc.element.jscs.require_spaces_inside_brackets.require_spaces_inside_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_brackets.prototype" id="apidoc.module.jscs.require_spaces_inside_brackets.prototype">module jscs.require_spaces_inside_brackets.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_brackets.prototype.check" id="apidoc.element.jscs.require_spaces_inside_brackets.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_brackets.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateTokensByTypeAndValue('Punctuator', '[', function(token) {
        var nextToken = file.getNextToken(token, { includeComments: true });
        var value = nextToken.value;

        if (value in exceptions) {
            return;
        }

        // Skip for empty array brackets
        if (value === ']') {
            return;
        }

        errors.assert.spacesBetween({
            token: token,
            nextToken: nextToken,
            exactly: 1,
            message: 'One space required after opening bracket'
        });
    });

    file.iterateTokensByTypeAndValue('Punctuator', ']', function(token) {
        var prevToken = file.getPrevToken(token, { includeComments: true });
        var value = prevToken.value;

        if (value in exceptions) {
            return;
        }

        // Skip for empty array brackets
        if (value === '[') {
            return;
        }

        errors.assert.spacesBetween({
            token: prevToken,
            nextToken: token,
            exactly: 1,
            message: 'One space required before closing bracket'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_brackets.prototype.configure" id="apidoc.element.jscs.require_spaces_inside_brackets.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_brackets.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var isObject = typeof value === 'object';

    var error = this.getOptionName() + ' rule requires string value true or object';

    if (isObject) {
        assert('allExcept' in value, error);
    } else {
        assert(value === true, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_brackets.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_inside_brackets.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_brackets.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpacesInsideBrackets';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_imported_object_braces" id="apidoc.module.jscs.require_spaces_inside_imported_object_braces">module jscs.require_spaces_inside_imported_object_braces</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces.require_spaces_inside_imported_object_braces" id="apidoc.element.jscs.require_spaces_inside_imported_object_braces.require_spaces_inside_imported_object_braces">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_imported_object_braces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_imported_object_braces = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_imported_object_braces.prototype" id="apidoc.module.jscs.require_spaces_inside_imported_object_braces.prototype">module jscs.require_spaces_inside_imported_object_braces.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.check" id="apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_imported_object_braces.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(['ImportDeclaration'], function(node) {

        if (!node.specifiers) {
            return;
        }

        node.specifiers.forEach(function(specifier) {

            if (specifier.type !== 'ImportSpecifier') {
                return;
            }

            var maybeOpeningBrace = file.getPrevToken(specifier.getFirstToken());
            var maybeClosingBrace = file.getNextToken(specifier.getLastToken());

            if (maybeOpeningBrace.value === '{') {
                errors.assert.spacesBetween({
                    token: maybeOpeningBrace,
                    nextToken: specifier.getFirstToken(),
                    exactly: 1,
                    message: 'One space required after opening curly brace'
                });
            }

            if (maybeClosingBrace.value === '}') {
                errors.assert.spacesBetween({
                    token: specifier.getLastToken(),
                    nextToken: maybeClosingBrace,
                    exactly: 1,
                    message: 'One space required before closing curly brace'
                });
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.configure" id="apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_imported_object_braces.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_inside_imported_object_braces.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_imported_object_braces.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpacesInsideImportedObjectBraces';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_object_brackets" id="apidoc.module.jscs.require_spaces_inside_object_brackets">module jscs.require_spaces_inside_object_brackets</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_object_brackets.require_spaces_inside_object_brackets" id="apidoc.element.jscs.require_spaces_inside_object_brackets.require_spaces_inside_object_brackets">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_object_brackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_object_brackets = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_object_brackets.prototype" id="apidoc.module.jscs.require_spaces_inside_object_brackets.prototype">module jscs.require_spaces_inside_object_brackets.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.check" id="apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_object_brackets.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateNodesByType(['ObjectExpression', 'ObjectPattern'], function(node) {
        var openingBracket = node.getFirstToken();
        var nextToken = file.getNextToken(openingBracket);

        // Don't check empty object
        if (nextToken.value === '}') {
            return;
        }

        errors.assert.spacesBetween({
            token: openingBracket,
            nextToken: nextToken,
            exactly: 1,
            message: 'One space required after opening curly brace'
        });

        var closingBracket = file.getLastNodeToken(node);
        var prevToken = file.getPrevToken(closingBracket);

        if (prevToken.value in exceptions) {
            return;
        }

        errors.assert.spacesBetween({
            token: prevToken,
            nextToken: closingBracket,
            exactly: 1,
            message: 'One space required before closing curly brace'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.configure" id="apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_object_brackets.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var mode;
    var modes = {
        'all': true,
        'allButNested': true
    };
    var isObject = typeof value === 'object';

    var error = this.getOptionName() + ' rule' +
    ' requires string value \'all\' or \'allButNested\' or object';

    if (typeof value === 'string') {
        assert(modes[value], error);

    } else if (isObject) {
        assert('allExcept' in value, error);
    } else {
        assert(false, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);

    } else {
        mode = value;
    }

    if (mode === 'allButNested') {
        this._exceptions['}'] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_inside_object_brackets.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_object_brackets.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpacesInsideObjectBrackets';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_parentheses" id="apidoc.module.jscs.require_spaces_inside_parentheses">module jscs.require_spaces_inside_parentheses</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parentheses.require_spaces_inside_parentheses" id="apidoc.element.jscs.require_spaces_inside_parentheses.require_spaces_inside_parentheses">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parentheses
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_parentheses = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_parentheses.prototype" id="apidoc.module.jscs.require_spaces_inside_parentheses.prototype">module jscs.require_spaces_inside_parentheses.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parentheses.prototype.check" id="apidoc.element.jscs.require_spaces_inside_parentheses.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parentheses.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;
    var singleQuote = this._exceptSingleQuote;
    var doubleQuote = this._exceptDoubleQuote;
    var ignoreParenthesizedExpression = this._ignoreParenthesizedExpression;

    file.iterateTokensByTypeAndValue('Punctuator', '(', function(token) {
        var nextToken = file.getNextToken(token, {includeComments: true});
        var value = nextToken.getSourceCode();

        if (
            ignoreParenthesizedExpression &amp;&amp;
            TokenCategorizer.categorizeOpenParen(token) === 'ParenthesizedExpression'
        ) {
            return;
        }

        if (value in exceptions) {
            return;
        }

        if (doubleQuote &amp;&amp; nextToken.type === 'String' &amp;&amp; value[0] === '"') {
            return;
        }

        if (singleQuote &amp;&amp; nextToken.type === 'String' &amp;&amp; value[0] === '\'') {
            return;
        }

        // Skip for empty parentheses
        if (value === ')') {
            return;
        }

        errors.assert.whitespaceBetween({
            token: token,
            nextToken: nextToken,
            message: 'Missing space after opening round bracket'
        });
    });

    file.iterateTokensByTypeAndValue('Punctuator', ')', function(token) {
        var prevToken = file.getPrevToken(token, {includeComments: true});
        var value = prevToken.getSourceCode();

        if (
            ignoreParenthesizedExpression &amp;&amp;
            TokenCategorizer.categorizeCloseParen(token) === 'ParenthesizedExpression'
        ) {
            return;
        }

        if (value in exceptions) {

            // Special case - foo( object[i] )
            if (!(
                value === ']' &amp;&amp;
                prevToken.parentElement.type === 'MemberExpression'
            )) {
                return;
            }
        }

        if (doubleQuote &amp;&amp; prevToken.type === 'String' &amp;&amp; value[value.length - 1] === '"') {
            return;
        }

        if (singleQuote &amp;&amp; prevToken.type === 'String' &amp;&amp; value[value.length - 1] === '\'') {
            return;
        }

        // Skip for empty parentheses
        if (value === '(') {
            return;
        }

        errors.assert.whitespaceBetween({
            token: prevToken,
            nextToken: token,
            message: 'Missing space before closing round bracket'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parentheses.prototype.configure" id="apidoc.element.jscs.require_spaces_inside_parentheses.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parentheses.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var mode;
    var modes = {
        'all': true,
        'allButNested': true
    };
    var isObject = typeof value === 'object';

    var error = this.getOptionName() + ' rule' +
    ' requires string value \'all\' or \'allButNested\' or object';

    if (typeof value === 'string') {
        assert(modes[value], error);

    } else if (isObject) {
        assert(
            'all' in value || 'allButNested' in value,
            error
        );
    } else {
        assert(false, error);
    }

    this._exceptions = {};
    this._exceptSingleQuote = false;
    this._exceptDoubleQuote = false;
    this._ignoreParenthesizedExpression = false;

    if (isObject) {
        mode = 'all' in value ? 'all' : 'allButNested';

        (value.except || []).forEach(function(value) {
            if (value === '\'') {
                this._exceptSingleQuote = true;
            }

            if (value === '"') {
                this._exceptDoubleQuote = true;
            }

            this._exceptions[value] = true;
        }, this);

        if (value.ignoreParenthesizedExpression === true) {
            this._ignoreParenthesizedExpression = true;
        }

    } else {
        mode = value;
    }

    if (mode === 'allButNested') {
        this._exceptions[')'] = this._exceptions['('] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parentheses.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_inside_parentheses.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parentheses.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpacesInsideParentheses';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_parenthesized_expression" id="apidoc.module.jscs.require_spaces_inside_parenthesized_expression">module jscs.require_spaces_inside_parenthesized_expression</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression.require_spaces_inside_parenthesized_expression" id="apidoc.element.jscs.require_spaces_inside_parenthesized_expression.require_spaces_inside_parenthesized_expression">
        function <span class="apidocSignatureSpan">jscs.</span>require_spaces_inside_parenthesized_expression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spaces_inside_parenthesized_expression = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spaces_inside_parenthesized_expression.prototype" id="apidoc.module.jscs.require_spaces_inside_parenthesized_expression.prototype">module jscs.require_spaces_inside_parenthesized_expression.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.check" id="apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parenthesized_expression.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var exceptions = this._exceptions;

    file.iterateTokensByTypeAndValue('Punctuator', '(', function(token) {
        var nextToken = file.getNextToken(token, {includeComments: true});
        var value = nextToken.isComment ?
            nextToken.type === 'CommentBlock' ? '/*' : '//' :
            nextToken.value;

        // Skip empty parentheses and explicit exceptions
        if (value === ')' || value in exceptions) {
            return;
        }

        // Skip non-expression parentheses
        var type = TokenCategorizer.categorizeOpenParen(token);
        if (type !== 'ParenthesizedExpression') {
            return;
        }

        errors.assert.whitespaceBetween({
            token: token,
            nextToken: nextToken,
            message: 'Missing space after opening grouping parenthesis'
        });
    });

    file.iterateTokensByTypeAndValue('Punctuator', ')', function(token) {
        var prevToken = file.getPrevToken(token, {includeComments: true});
        var value = prevToken.isComment ?
            prevToken.type === 'CommentBlock' ? '*/' : '' :
            prevToken.value;

        // Skip empty parentheses and explicit exceptions
        if (value === '(' || value in exceptions) {
            return;
        }

        // Skip non-expression parentheses
        var type = TokenCategorizer.categorizeCloseParen(token);
        if (type !== 'ParenthesizedExpression') {
            return;
        }

        errors.assert.whitespaceBetween({
            token: prevToken,
            nextToken: token,
            message: 'Missing space before closing grouping parenthesis'
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.configure" id="apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parenthesized_expression.prototype.</span>configure
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (value) {
    var isObject = typeof value === 'object';

    var error = this.getOptionName() + ' rule requires string value true or object';

    if (isObject) {
        assert('allExcept' in value, error);
    } else {
        assert(value === true, error);
    }

    this._exceptions = {};

    if (isObject) {
        (value.allExcept || []).forEach(function(value) {
            this._exceptions[value] = true;
        }, this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.getOptionName" id="apidoc.element.jscs.require_spaces_inside_parenthesized_expression.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spaces_inside_parenthesized_expression.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpacesInsideParenthesizedExpression';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spread" id="apidoc.module.jscs.require_spread">module jscs.require_spread</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spread.require_spread" id="apidoc.element.jscs.require_spread.require_spread">
        function <span class="apidocSignatureSpan">jscs.</span>require_spread
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_spread = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_spread.prototype" id="apidoc.module.jscs.require_spread.prototype">module jscs.require_spread.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_spread.prototype.check" id="apidoc.element.jscs.require_spread.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_spread.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType('CallExpression', function(node) {
        var callee = node.callee;
        var firstParameter = node.arguments[0];

        if (node.arguments.length === 2 &amp;&amp;
            callee.property &amp;&amp; callee.property.name === 'apply' &amp;&amp;
            callee.object &amp;&amp; callee.object.name === firstParameter.name) {
            errors.add(
                'Illegal use of apply method. Use the spread operator instead',
                node.callee.property
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spread.prototype.configure" id="apidoc.element.jscs.require_spread.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_spread.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value or should be removed'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_spread.prototype.getOptionName" id="apidoc.element.jscs.require_spread.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_spread.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireSpread';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_template_strings" id="apidoc.module.jscs.require_template_strings">module jscs.require_template_strings</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_template_strings.require_template_strings" id="apidoc.element.jscs.require_template_strings.require_template_strings">
        function <span class="apidocSignatureSpan">jscs.</span>require_template_strings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_template_strings = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_template_strings.prototype" id="apidoc.module.jscs.require_template_strings.prototype">module jscs.require_template_strings.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_template_strings.prototype.check" id="apidoc.element.jscs.require_template_strings.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_template_strings.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var allowStringConcatenation = this._allowStringConcatenation;

    function add(node) {
        errors.add(
            'Illegal use of string concatenation. Use template strings instead.',
            node.left
        );
    }

    file.iterateNodesByType('BinaryExpression', function(node) {
        if (node.operator !== '+') {
            return;
        }

        var leftIsString = node.left;
        var rightIsString = node.right;

        // Left side could also be binary expression (See gh-2050),
        // but not the right one
        while (leftIsString.type === 'BinaryExpression') {
            leftIsString = leftIsString.left;
        }

        leftIsString = typeof leftIsString.value === 'string' ||
            leftIsString.type === 'TemplateLiteral';

        rightIsString = typeof rightIsString.value === 'string' ||
            rightIsString.type === 'TemplateLiteral';

        if (allowStringConcatenation &amp;&amp; leftIsString &amp;&amp; rightIsString) {
            return;
        }

        // At least one of the operands should be a string or template string,
        // otherwise this is not a concatenation
        if (leftIsString || rightIsString) {
            add(node);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_template_strings.prototype.configure" id="apidoc.element.jscs.require_template_strings.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_template_strings.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    this._allowStringConcatenation = false;
    var optionName = this.getOptionName();

    if (typeof options === 'object') {
        assert(Array.isArray(options.allExcept), optionName + ' option requires "allExcept" ' +
            'to be an array');
        assert(options.allExcept.length &gt; 0, optionName + ' option requires "allExcept" ' +
            'to have at least one item or be set to `true`');
        options.allExcept.forEach(function(except) {
            if (except === 'stringConcatenation') {
                this._allowStringConcatenation = true;
            } else {
                assert(false, optionName + ' option requires "allExcept" to only have ' +
                    '"stringConcatenation"');
            }
        }, this);
    } else {
        assert(
            options === true,
            optionName + ' option requires true value or object'
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_template_strings.prototype.getOptionName" id="apidoc.element.jscs.require_template_strings.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_template_strings.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireTemplateStrings';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_trailing_comma" id="apidoc.module.jscs.require_trailing_comma">module jscs.require_trailing_comma</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_trailing_comma.require_trailing_comma" id="apidoc.element.jscs.require_trailing_comma.require_trailing_comma">
        function <span class="apidocSignatureSpan">jscs.</span>require_trailing_comma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_trailing_comma = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_trailing_comma.prototype" id="apidoc.module.jscs.require_trailing_comma.prototype">module jscs.require_trailing_comma.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_trailing_comma.prototype._fix" id="apidoc.element.jscs.require_trailing_comma.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.require_trailing_comma.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var parent = error.additional;
    var afterProp;

    // ArrayPattern/ArrayExpression
    if (parent.type.indexOf('Array') === 0) {
        afterProp = parent.elements[parent.elements.length - 1].lastChild.getNextToken();

    // ObjectExpression/ObjectPattern
    } else {
        afterProp = parent.properties[parent.properties.length - 1].lastChild.getNextToken();
    }

    parent.insertChildBefore(new Token('Punctuator', ','), afterProp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &amp;&amp; instance._fix) {
        // "error.fixed = true" should go first, so rule can
        // decide for itself (with "error.fixed = false")
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_trailing_comma.prototype.check" id="apidoc.element.jscs.require_trailing_comma.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_trailing_comma.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var _this = this;

    file.iterateNodesByType([
        'ObjectExpression', 'ArrayExpression',
        'ObjectPattern', 'ArrayPattern'
    ], function(node) {
        var isLikeObject = node.type === 'ObjectExpression' || node.type === 'ObjectPattern';
        var entities = isLikeObject ? node.properties : node.elements;

        if (entities.length === 0) {
            return;
        }

        if (_this._ignoreSingleValue &amp;&amp; entities.length === 1) {
            return;
        }

        if (_this._ignoreSingleLine &amp;&amp; node.getNewlineCount() === 0) {
            return;
        }

        var possibleComma = file.getLastNodeToken(node).getPreviousCodeToken();

        if (possibleComma.value !== ',') {
            errors.cast({
                message: 'Missing comma before closing ' + (isLikeObject ? 'curly brace' : 'bracket'),
                element: possibleComma,
                additional: node
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_trailing_comma.prototype.configure" id="apidoc.element.jscs.require_trailing_comma.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_trailing_comma.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {

    if (typeof options === 'object') {
        if ('ignoreSingleValue' in options) {
            assert(
                options.ignoreSingleValue === true,
                this.getOptionName() + ' option ignoreSingleValue requires true value or should be removed'
            );
            this._ignoreSingleValue = true;
        }
        if ('ignoreSingleLine' in options) {
            assert(
                options.ignoreSingleLine === true,
                this.getOptionName() + ' option ignoreSingleLine requires true value or should be removed'
            );
            this._ignoreSingleLine = true;
        }
    } else {
        assert(
            options === true,
            this.getOptionName() + ' option requires a true value or should be removed'
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_trailing_comma.prototype.getOptionName" id="apidoc.element.jscs.require_trailing_comma.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_trailing_comma.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireTrailingComma';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_use_strict" id="apidoc.module.jscs.require_use_strict">module jscs.require_use_strict</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_use_strict.require_use_strict" id="apidoc.element.jscs.require_use_strict.require_use_strict">
        function <span class="apidocSignatureSpan">jscs.</span>require_use_strict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_use_strict = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_use_strict.prototype" id="apidoc.module.jscs.require_use_strict.prototype">module jscs.require_use_strict.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_use_strict.prototype.check" id="apidoc.element.jscs.require_use_strict.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_use_strict.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var program = file.getProgram();
    var directive = program.directives[0];

    if (directive) {
        return;
    }

    errors.add(
        '`"use strict";` is required at the top of each file',
        program
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_use_strict.prototype.configure" id="apidoc.element.jscs.require_use_strict.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_use_strict.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    if (typeof options !== 'object') {
        assert(
            options === true,
            this.getOptionName() + ' option requires either a true value or an object'
        );

        var _options = {files: true};
        return this.configure(_options);
    }

    this._checkFiles = (options.files === true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_use_strict.prototype.getOptionName" id="apidoc.element.jscs.require_use_strict.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_use_strict.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireUseStrict';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_var_decl_first" id="apidoc.module.jscs.require_var_decl_first">module jscs.require_var_decl_first</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_var_decl_first.require_var_decl_first" id="apidoc.element.jscs.require_var_decl_first.require_var_decl_first">
        function <span class="apidocSignatureSpan">jscs.</span>require_var_decl_first
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_var_decl_first = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_var_decl_first.prototype" id="apidoc.module.jscs.require_var_decl_first.prototype">module jscs.require_var_decl_first.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_var_decl_first.prototype.check" id="apidoc.element.jscs.require_var_decl_first.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_var_decl_first.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    file.iterateNodesByType(['VariableDeclaration'], function(varDecl) {
        // Ignore let and const for now #1783
        if (varDecl.kind !== 'var') {
            return;
        }

        // Checking scope to not allow vars inside block statements.
        if (isScopeElement(varDecl.parentElement) &amp;&amp; isVarDeclFirst(varDecl)) {
            return;
        }

        errors.add('Variable declarations must be the first statements of a function scope.',
            varDecl);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_var_decl_first.prototype.configure" id="apidoc.element.jscs.require_var_decl_first.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_var_decl_first.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true,
        this.getOptionName() + ' option requires a true value'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_var_decl_first.prototype.getOptionName" id="apidoc.element.jscs.require_var_decl_first.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_var_decl_first.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireVarDeclFirst';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_yoda_conditions" id="apidoc.module.jscs.require_yoda_conditions">module jscs.require_yoda_conditions</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_yoda_conditions.require_yoda_conditions" id="apidoc.element.jscs.require_yoda_conditions.require_yoda_conditions">
        function <span class="apidocSignatureSpan">jscs.</span>require_yoda_conditions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">require_yoda_conditions = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.require_yoda_conditions.prototype" id="apidoc.module.jscs.require_yoda_conditions.prototype">module jscs.require_yoda_conditions.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.require_yoda_conditions.prototype.check" id="apidoc.element.jscs.require_yoda_conditions.prototype.check">
        function <span class="apidocSignatureSpan">jscs.require_yoda_conditions.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var operators = this._operatorIndex;
    file.iterateNodesByType('BinaryExpression', function(node) {
        if (operators[node.operator]) {
            if (
                node.right.type.indexOf('Literal') &gt; -1 ||
                (node.right.type === 'Identifier' &amp;&amp; node.right.name === 'undefined')
            ) {
                errors.add('Not yoda condition', node.left);
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_yoda_conditions.prototype.configure" id="apidoc.element.jscs.require_yoda_conditions.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.require_yoda_conditions.prototype.</span>configure
        <span class="apidocSignatureSpan">(operators)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (operators) {
    var isTrue = operators === true;

    assert(
        Array.isArray(operators) || isTrue,
        this.getOptionName() + ' option requires array or true value'
    );

    if (isTrue) {
        operators = ['==', '===', '!=', '!=='];
    }

    this._operatorIndex = {};
    for (var i = 0, l = operators.length; i &lt; l; i++) {
        this._operatorIndex[operators[i]] = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.require_yoda_conditions.prototype.getOptionName" id="apidoc.element.jscs.require_yoda_conditions.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.require_yoda_conditions.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'requireYodaConditions';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.safe_context_keyword" id="apidoc.module.jscs.safe_context_keyword">module jscs.safe_context_keyword</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.safe_context_keyword.safe_context_keyword" id="apidoc.element.jscs.safe_context_keyword.safe_context_keyword">
        function <span class="apidocSignatureSpan">jscs.</span>safe_context_keyword
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">safe_context_keyword = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.safe_context_keyword.prototype" id="apidoc.module.jscs.safe_context_keyword.prototype">module jscs.safe_context_keyword.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.safe_context_keyword.prototype.check" id="apidoc.element.jscs.safe_context_keyword.prototype.check">
        function <span class="apidocSignatureSpan">jscs.safe_context_keyword.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var keywords = typeof this._keywords === 'string' ? [this._keywords] : this._keywords;

    // var that = this
    file.iterateNodesByType('VariableDeclaration', function(node) {

        for (var i = 0; i &lt; node.declarations.length; i++) {
            var decl = node.declarations[i];

            // Miss destructing assignment (#1699, #2119)
            if (decl.firstChild.type === 'ObjectPattern') {
                continue;
            }

            // decl.init === null in case of "var foo;"
            if (decl.init &amp;&amp;
                (decl.init.type === 'ThisExpression' &amp;&amp; checkKeywords(decl.id.name, keywords))
            ) {
                errors.add(
                    'You should use "' + keywords.join('" or "') + '" to save a reference to "this"',
                    node
                );
            }
        }
    });

    // that = this
    file.iterateNodesByType('AssignmentExpression', function(node) {

        if (
            // filter property assignments "foo.bar = this"
            node.left.type === 'Identifier' &amp;&amp;
            (node.right.type === 'ThisExpression' &amp;&amp; checkKeywords(node.left.name, keywords))
        ) {
            errors.add(
                'You should use "' + keywords.join('" or "') + '" to save a reference to "this"',
                node
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.safe_context_keyword.prototype.configure" id="apidoc.element.jscs.safe_context_keyword.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.safe_context_keyword.prototype.</span>configure
        <span class="apidocSignatureSpan">(keywords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (keywords) {
    assert(
        Array.isArray(keywords) || typeof keywords === 'string',
        this.getOptionName() + ' option requires string or array value'
    );

    this._keywords = keywords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.safe_context_keyword.prototype.getOptionName" id="apidoc.element.jscs.safe_context_keyword.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.safe_context_keyword.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'safeContextKeyword';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.super_" id="apidoc.module.jscs.super_">module jscs.super_</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.super_.super_" id="apidoc.element.jscs.super_.super_">
        function <span class="apidocSignatureSpan">jscs.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {
    this._configuredRules = [];

    this._errorsFound = 0;
    this._maxErrorsExceeded = false;

    this._configuration = this._createConfiguration();
    this._configuration.registerDefaultPresets();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.super_.prototype" id="apidoc.module.jscs.super_.prototype">module jscs.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.super_.prototype._addParseError" id="apidoc.element.jscs.super_.prototype._addParseError">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_addParseError
        <span class="apidocSignatureSpan">(errors, parseError, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addParseError = function (errors, parseError, file) {
    if (this._maxErrorsExceeded) {
        return;
    }

    errors.add(parseError, file.getProgram());

    if (this.maxErrorsEnabled()) {
        this._errorsFound += 1;
        this._maxErrorsExceeded = this._errorsFound &gt;= this._maxErrors;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     *
     * @param {String | Error} message
     * @param {cst.types.Element} element
     * @param {Number} [offset] relative offset
     */
    add: function(message, element, offset) {
if (message instanceof Error) {
    this.<span class="apidocCodeKeywordSpan">_addParseError</span>(message);
    return;
}

this._addError({
    message: message,
    element: element,
    offset: offset
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype._checkJsFile" id="apidoc.element.jscs.super_.prototype._checkJsFile">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_checkJsFile
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkJsFile = function (file, errors) {
    if (this._maxErrorsExceeded) {
        return;
    }

    var errorFilter = this._configuration.getErrorFilter();

    this._configuredRules.forEach(function(rule) {
        errors.setCurrentRule(rule.getOptionName());

        try {
            rule.check(file, errors);
        } catch (e) {
            errors.setCurrentRule('internalError');
            errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
        }
    }, this);

    this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
        errors.add('Unsupported rule: ' + rulename, file.getProgram());
    });

    var program = file.getProgram();
    var tokenIndex = new TokenIndex(program.getFirstToken());
    errors.calculateErrorLocations(tokenIndex);
    errors.filter(function(error) {
        if (error.element) {
            return tokenIndex.isRuleEnabled(error.rule, error.element);
        } else {
            return true;
        }
    });

    // sort errors list to show errors as they appear in source
    errors.getErrorList().sort(function(a, b) {
        return (a.line - b.line) || (a.column - b.column);
    });

    if (errorFilter) {
        errors.filter(errorFilter);
    }

    if (this.maxErrorsEnabled()) {
        if (this._maxErrors === -1 || this._maxErrors === null) {
            this._maxErrorsExceeded = false;

        } else {
            this._maxErrorsExceeded = this._errorsFound + errors.getErrorCount() &gt; this._maxErrors;
            errors.stripErrorList(Math.max(0, this._maxErrors - this._errorsFound));
        }
    }

    this._errorsFound += errors.getErrorCount();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }, this);

    if (!file._program || file._program.firstChild.type === 'EOF') {
        return errors;
    }

    this.<span class="apidocCodeKeywordSpan">_checkJsFile</span>(file, errors);

    return errors;
},

/**
 * Apply fix for common errors.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype._createConfiguration" id="apidoc.element.jscs.super_.prototype._createConfiguration">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_createConfiguration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createConfiguration = function () {
    return new Configuration();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
var StringChecker = function() {
this._configuredRules = [];

this._errorsFound = 0;
this._maxErrorsExceeded = false;

this._configuration = this.<span class="apidocCodeKeywordSpan">_createConfiguration</span>();
this._configuration.registerDefaultPresets();
};

StringChecker.prototype = {
/**
 * Registers single Code Style checking rule.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype._createJsFileInstance" id="apidoc.element.jscs.super_.prototype._createJsFileInstance">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_createJsFileInstance
        <span class="apidocSignatureSpan">(filename, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createJsFileInstance = function (filename, source) {
    return new JsFile({
        filename: filename,
        source: source,
        es3: this._configuration.isES3Enabled()
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @param {String} source
     * @param {String} [filename='input']
     * @returns {Errors}
     */
    checkString: function(source, filename) {
filename = filename || 'input';

var file = this.<span class="apidocCodeKeywordSpan">_createJsFileInstance</span>(filename, source);

var errors = new Errors(file);

file.getParseErrors().forEach(function(parseError) {
    if (!this._maxErrorsExceeded) {
        this._addParseError(errors, parseError, file);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype._fixCommonError" id="apidoc.element.jscs.super_.prototype._fixCommonError">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_fixCommonError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fixCommonError = function (error) {
    if (error.fix) {
        // "error.fixed = true" should go first, so rule can
        // decide for itself (with "error.fixed = false")
        // if it can fix this particular error
        error.fixed = true;
        error.fix();
    }

    return !!error.fixed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        errors.getErrorList().forEach(function(error) {
if (error.fixed) {
    return;
}

try {
    // Try to apply fixes for common errors
    var isFixed = this.<span class="apidocCodeKeywordSpan">_fixCommonError</span>(error);

    // Apply specific fix
    if (!isFixed) {
        this._fixSpecificError(file, error);
    }
} catch (e) {
    error.fixed = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype._fixJsFile" id="apidoc.element.jscs.super_.prototype._fixJsFile">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_fixJsFile
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fixJsFile = function (file, errors) {
    errors.getErrorList().forEach(function(error) {
        if (error.fixed) {
            return;
        }

        try {
            // Try to apply fixes for common errors
            var isFixed = this._fixCommonError(error);

            // Apply specific fix
            if (!isFixed) {
                this._fixSpecificError(file, error);
            }
        } catch (e) {
            error.fixed = false;
            errors.add(
                getInternalErrorMessage(error.rule, e),
                file.getProgram()
            );
        }
    }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            var attempt = 0;
            do {

// Fill in errors list
this._checkJsFile(file, errors);

// Apply fixes
this.<span class="apidocCodeKeywordSpan">_fixJsFile</span>(file, errors);

var hasFixes = errors.getErrorList().some(function(err) {
    return err.fixed;
});

if (!hasFixes) {
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype._fixSpecificError" id="apidoc.element.jscs.super_.prototype._fixSpecificError">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>_fixSpecificError
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fixSpecificError = function (file, error) {
    var configuration = this.getConfiguration();
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &amp;&amp; instance._fix) {
        // "error.fixed = true" should go first, so rule can
        // decide for itself (with "error.fixed = false")
        // if it can fix this particular error
        error.fixed = true;
        instance._fix(file, error);
    }

    return !!error.fixed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

try {
    // Try to apply fixes for common errors
    var isFixed = this._fixCommonError(error);

    // Apply specific fix
    if (!isFixed) {
        this.<span class="apidocCodeKeywordSpan">_fixSpecificError</span>(file, error);
    }
} catch (e) {
    error.fixed = false;
    errors.add(
        getInternalErrorMessage(error.rule, e),
        file.getProgram()
    );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.checkString" id="apidoc.element.jscs.super_.prototype.checkString">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>checkString
        <span class="apidocSignatureSpan">(source, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkString = function (source, filename) {
    filename = filename || 'input';

    var file = this._createJsFileInstance(filename, source);

    var errors = new Errors(file);

    file.getParseErrors().forEach(function(parseError) {
        if (!this._maxErrorsExceeded) {
            this._addParseError(errors, parseError, file);
        }
    }, this);

    if (!file._program || file._program.firstChild.type === 'EOF') {
        return errors;
    }

    this._checkJsFile(file, errors);

    return errors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
Checker.prototype.checkFile = function(path) {
   if (this._configuration.isFileExcluded(path)) {
       return Vow.resolve(null);
   }

   return vowFs.read(path, 'utf8').then(function(data) {
       return this.<span class="apidocCodeKeywordSpan">checkString</span>(data, path);
   }, this);
};

/**
* Fixes single file.
*
* @param {String} path
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.configure" id="apidoc.element.jscs.super_.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>configure
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (config) {
    this._configuration.load(config);

    this._configuredRules = this._configuration.getConfiguredRules();
    this._maxErrors = this._configuration.getMaxErrors();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.fixString" id="apidoc.element.jscs.super_.prototype.fixString">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>fixString
        <span class="apidocSignatureSpan">(source, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fixString = function (source, filename) {
    filename = filename || 'input';

    var file = this._createJsFileInstance(filename, source);
    var errors = new Errors(file);

    var parseErrors = file.getParseErrors();
    if (parseErrors.length &gt; 0) {
        parseErrors.forEach(function(parseError) {
            this._addParseError(errors, parseError, file);
        }, this);

        return {output: source, errors: errors};
    } else {
        var attempt = 0;
        do {

            // Fill in errors list
            this._checkJsFile(file, errors);

            // Apply fixes
            this._fixJsFile(file, errors);

            var hasFixes = errors.getErrorList().some(function(err) {
                return err.fixed;
            });

            if (!hasFixes) {
                break;
            }

            file = this._createJsFileInstance(filename, file.render());
            errors = new Errors(file);
            attempt++;
        } while (attempt &lt; MAX_FIX_ATTEMPTS);

        return {output: file.getSource(), errors: errors};
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Checker.prototype.fixFile = function(path) {
    if (this._configuration.isFileExcluded(path)) {
        return Vow.resolve(null);
    }

    return vowFs.read(path, 'utf8').then(function(data) {
        var result = this.<span class="apidocCodeKeywordSpan">fixString</span>(data, path);
        return vowFs.write(path, result.output).then(function() {
            return result.errors;
        });
    }, this);
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.getConfiguration" id="apidoc.element.jscs.super_.prototype.getConfiguration">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>getConfiguration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConfiguration = function () {
    return this._configuration;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// To run autoconfigure over all errors in the path
if (program.autoConfigure) {
    program.maxErrors = Infinity;
}

checker.<span class="apidocCodeKeywordSpan">getConfiguration</span>().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.configure(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.getProcessedConfig" id="apidoc.element.jscs.super_.prototype.getProcessedConfig">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>getProcessedConfig
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getProcessedConfig = function () {
    return this._configuration.getProcessedConfig();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Get processed config.
 *
 * @return {Object}
 */
getProcessedConfig: function() {
    return this._configuration.<span class="apidocCodeKeywordSpan">getProcessedConfig</span>();
},

/**
 * Loads configuration from JS Object. Activates and configures required rules.
 *
 * @param {Object} config
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.maxErrorsEnabled" id="apidoc.element.jscs.super_.prototype.maxErrorsEnabled">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>maxErrorsEnabled
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxErrorsEnabled = function () {
    return this._maxErrors !== null &amp;&amp; this._maxErrors !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return (a.line - b.line) || (a.column - b.column);
        });

        if (errorFilter) {
errors.filter(errorFilter);
        }

        if (this.<span class="apidocCodeKeywordSpan">maxErrorsEnabled</span>()) {
if (this._maxErrors === -1 || this._maxErrors === null) {
    this._maxErrorsExceeded = false;

} else {
    this._maxErrorsExceeded = this._errorsFound + errors.getErrorCount() &gt; this._maxErrors;
    errors.stripErrorList(Math.max(0, this._maxErrors - this._errorsFound));
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.maxErrorsExceeded" id="apidoc.element.jscs.super_.prototype.maxErrorsExceeded">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>maxErrorsExceeded
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxErrorsExceeded = function () {
    return this._maxErrorsExceeded;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var returnArgs = {
    checker: checker,
    reporter: program.reporter,
    promise: promise
};

function handleMaxErrors() {
    if (checker.<span class="apidocCodeKeywordSpan">maxErrorsExceeded</span>()) {
        console.error('Too many errors... Increase `maxErrors` configuration option value to see more.');
    }
}

promise.always(function(status) {
    exit(status.valueOf());
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.registerDefaultRules" id="apidoc.element.jscs.super_.prototype.registerDefaultRules">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>registerDefaultRules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerDefaultRules = function () {
    this._configuration.registerDefaultRules();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// To run autoconfigure over all errors in the path
if (program.autoConfigure) {
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().<span class="apidocCodeKeywordSpan">registerDefaultRules</span>();

try {
    checker.configure(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.super_.prototype.registerRule" id="apidoc.element.jscs.super_.prototype.registerRule">
        function <span class="apidocSignatureSpan">jscs.super_.prototype.</span>registerRule
        <span class="apidocSignatureSpan">(rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerRule = function (rule) {
    this._configuration.registerRule(rule);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
StringChecker.prototype = {
/**
 * Registers single Code Style checking rule.
 *
 * @param {Rule} rule
 */
registerRule: function(rule) {
    this._configuration.<span class="apidocCodeKeywordSpan">registerRule</span>(rule);
},

/**
 * Registers built-in Code Style checking rules.
 */
registerDefaultRules: function() {
    this._configuration.registerDefaultRules();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.token_assert" id="apidoc.module.jscs.token_assert">module jscs.token_assert</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.token_assert.token_assert" id="apidoc.element.jscs.token_assert.token_assert">
        function <span class="apidocSignatureSpan">jscs.</span>token_assert
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenAssert(file) {
    EventEmitter.call(this);

    this._file = file;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.super_" id="apidoc.element.jscs.token_assert.super_">
        function <span class="apidocSignatureSpan">jscs.token_assert.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.token_assert.prototype" id="apidoc.module.jscs.token_assert.prototype">module jscs.token_assert.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype._augmentLineCount" id="apidoc.element.jscs.token_assert.prototype._augmentLineCount">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>_augmentLineCount
        <span class="apidocSignatureSpan">(options, lineCount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_augmentLineCount = function (options, lineCount) {
    var token = options.nextToken;
    if (lineCount === 0) {
        if (options.stickToPreviousToken) {
            var nextToken = this._file.getNextToken(token, {
                includeComments: true
            });
            this._file.setWhitespaceBefore(nextToken, this._file.getWhitespaceBefore(token));
        }

        this._file.setWhitespaceBefore(token, ' ');
        return;
    }

    this._updateWhitespaceByLine(token, function(lines) {
        var currentLineCount = lines.length;
        var lastLine = lines[lines.length - 1];

        if (currentLineCount &lt;= lineCount) {
            // add additional lines that maintain the same indentation as the former last line
            for (; currentLineCount &lt;= lineCount; currentLineCount++) {
                lines[lines.length - 1] = '';
                lines.push(lastLine);
            }
        } else {
            // remove lines and then ensure that the new last line maintains the previous indentation
            lines = lines.slice(0, lineCount + 1);
            lines[lines.length - 1] = lastLine;
        }

        return lines;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    var linesBetween = this._file.getLineCountBetween(token, nextToken);

    var emitError = function(countPrefix, lineCount) {
var msgPrefix = token.value + ' and ' + nextToken.value;

var fix = function() {
    this.<span class="apidocCodeKeywordSpan">_augmentLineCount</span>(options, lineCount);
}.bind(this);

if (!options.message) {
    if (exactly === 0) {
        // support sameLine
        options.message = msgPrefix + ' should be on the same line';
    } else if (atLeast === 1 &amp;&amp; atMost === undefined) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype._updateCommentWhitespace" id="apidoc.element.jscs.token_assert.prototype._updateCommentWhitespace">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>_updateCommentWhitespace
        <span class="apidocSignatureSpan">(token, indentChar, actual, expected)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateCommentWhitespace = function (token, indentChar, actual, expected) {
    var difference = expected - actual;
    var tokenLines = token.value.split(/\r\n|\r|\n/);
    var i = 1;
    if (difference &gt;= 0) {
        var lineWhitespace = (new Array(difference + 1)).join(indentChar);
        for (; i &lt; tokenLines.length; i++) {
            tokenLines[i] = tokenLines[i] === '' ? '' : lineWhitespace + tokenLines[i];
        }
    } else {
        for (; i &lt; tokenLines.length; i++) {
            tokenLines[i] = tokenLines[i].substring(-difference);
        }
    }

    var newComment = new Token('CommentBlock', tokenLines.join(this._file.getLineBreakStyle()));
    token.parentElement.replaceChild(newComment, token);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

            this._updateWhitespaceByLine(token, function(lines) {
                lines[lines.length - 1] = newWhitespace;
                return lines;
            });

            if (token.isComment) {
                this.<span class="apidocCodeKeywordSpan">_updateCommentWhitespace</span>(token, indentChar, actual, expected);
            }
        }.bind(this)
    });

    return true;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype._updateWhitespaceByLine" id="apidoc.element.jscs.token_assert.prototype._updateWhitespaceByLine">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>_updateWhitespaceByLine
        <span class="apidocSignatureSpan">(token, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateWhitespaceByLine = function (token, callback) {
    var lineBreak = this._file.getLineBreakStyle();
    var lines = this._file.getWhitespaceBefore(token).split(/\r\n|\r|\n/);

    lines = callback(lines);
    this._file.setWhitespaceBefore(token, lines.join(lineBreak));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.emit('error', {
        message: 'Expected indentation of ' + expected + ' characters',
        line: lineNumber,
        column: expected,
        fix: function() {
var newWhitespace = (new Array(expected + 1)).join(indentChar);

this.<span class="apidocCodeKeywordSpan">_updateWhitespaceByLine</span>(token, function(lines) {
    lines[lines.length - 1] = newWhitespace;
    return lines;
});

if (token.isComment) {
    this._updateCommentWhitespace(token, indentChar, actual, expected);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype._validateOptions" id="apidoc.element.jscs.token_assert.prototype._validateOptions">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>_validateOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_validateOptions = function (options) {
    var token = options.token;
    var nextToken = options.nextToken;
    var atLeast = options.atLeast;
    var atMost = options.atMost;
    var exactly = options.exactly;

    if (token === nextToken) {
        throw new Error('You cannot specify the same token as both token and nextToken');
    }

    if (atLeast === undefined &amp;&amp;
        atMost === undefined &amp;&amp;
        exactly === undefined) {
        throw new Error('You must specify at least one option');
    }

    if (exactly !== undefined &amp;&amp; (atLeast !== undefined || atMost !== undefined)) {
        throw new Error('You cannot specify atLeast or atMost with exactly');
    }

    if (atLeast !== undefined &amp;&amp; atMost !== undefined &amp;&amp; atMost &lt; atLeast) {
        throw new Error('atLeast and atMost are in conflict');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var atMost = options.atMost;
var exactly = options.exactly;

if (!token || !nextToken) {
    return false;
}

this.<span class="apidocCodeKeywordSpan">_validateOptions</span>(options);

if (!options.disallowNewLine &amp;&amp; !this._file.isOnTheSameLine(token, nextToken)) {
    return false;
}

// Only attempt to remove or add lines if there are no comments between the two nodes
// as this prevents accidentally moving a valid token onto a line comment ed line
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype.differentLine" id="apidoc.element.jscs.token_assert.prototype.differentLine">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>differentLine
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">differentLine = function (options) {
    options.atLeast = 1;

    return this.linesBetween(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        errors.assert.sameLine({
            token: token,
            nextToken: nextToken,
            message: 'Commas should be placed on the same line as value'
        });

        errors.assert.<span class="apidocCodeKeywordSpan">differentLine</span>({
            token: token.getPreviousCodeToken(),
            nextToken: token,
            message: 'Commas should be placed on new line'
        });
    });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype.indentation" id="apidoc.element.jscs.token_assert.prototype.indentation">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>indentation
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indentation = function (options) {
    var token = options.token;
    var lineNumber = options.lineNumber;
    var actual = options.actual;
    var expected = options.expected;
    var indentChar = options.indentChar;

    if (actual === expected) {
        return false;
    }

    this.emit('error', {
        message: 'Expected indentation of ' + expected + ' characters',
        line: lineNumber,
        column: expected,
        fix: function() {
            var newWhitespace = (new Array(expected + 1)).join(indentChar);

            this._updateWhitespaceByLine(token, function(lines) {
                lines[lines.length - 1] = newWhitespace;
                return lines;
            });

            if (token.isComment) {
                this._updateCommentWhitespace(token, indentChar, actual, expected);
            }
        }.bind(this)
    });

    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var previousParam = firstParam;
params.slice(1).forEach(function(param) {
    if (!file.isOnTheSameLine(previousParam, param)) {
        var paramColumn = getNodeColumn(param);
        if (paramColumn !== referenceColumn) {
            errors.assert.<span class="apidocCodeKeywordSpan">indentation</span>({
                token: param.getFirstToken(),
                actual: paramColumn,
                expected: referenceColumn,
                indentChar: ' '
            });
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype.linesBetween" id="apidoc.element.jscs.token_assert.prototype.linesBetween">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>linesBetween
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">linesBetween = function (options) {
    var token = options.token;
    var nextToken = options.nextToken;
    var atLeast = options.atLeast;
    var atMost = options.atMost;
    var exactly = options.exactly;

    if (!token || !nextToken) {
        return false;
    }

    this._validateOptions(options);

    // Only attempt to remove or add lines if there are no comments between the two nodes
    // as this prevents accidentally moving a valid token onto a line comment ed line
    var fixed = !options.token.getNextNonWhitespaceToken().isComment;

    var linesBetween = this._file.getLineCountBetween(token, nextToken);

    var emitError = function(countPrefix, lineCount) {
        var msgPrefix = token.value + ' and ' + nextToken.value;

        var fix = function() {
            this._augmentLineCount(options, lineCount);
        }.bind(this);

        if (!options.message) {
            if (exactly === 0) {
                // support sameLine
                options.message = msgPrefix + ' should be on the same line';
            } else if (atLeast === 1 &amp;&amp; atMost === undefined) {
                // support differentLine
                options.message = msgPrefix + ' should be on different lines';
            } else {
                // support linesBetween
                options.message = msgPrefix + ' should have ' + countPrefix + ' ' + lineCount + ' line(s) between them';
            }
        }

        this.emit('error', {
            message: options.message,
            element: token,
            offset: token.getSourceCodeLength(),
            fix: fixed ? fix : undefined
        });
    }.bind(this);

    if (atLeast !== undefined &amp;&amp; linesBetween &lt; atLeast) {
        emitError('at least', atLeast);
        return true;
    }

    if (atMost !== undefined &amp;&amp; linesBetween &gt; atMost) {
        emitError('at most', atMost);
        return true;
    }

    if (exactly !== undefined &amp;&amp; linesBetween !== exactly) {
        emitError('exactly', exactly);
        return true;
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Boolean} [options.stickToPreviousToken]
* @param {String} [options.message]
* @return {Boolean} whether an error was found
*/
TokenAssert.prototype.sameLine = function(options) {
   options.exactly = 0;

   return this.<span class="apidocCodeKeywordSpan">linesBetween</span>(options);
};

/**
* Requires tokens to be on different lines.
*
* @param {Object} options
* @param {Object} options.token
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype.noWhitespaceBetween" id="apidoc.element.jscs.token_assert.prototype.noWhitespaceBetween">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>noWhitespaceBetween
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noWhitespaceBetween = function (options) {
    options.exactly = 0;
    return this.spacesBetween(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Comma
if (operators[',']) {
    file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
        if (file.getNextToken(token).value === ',') {
            return;
        }
        errors.assert.<span class="apidocCodeKeywordSpan">noWhitespaceBetween</span>({
            token: token,
            nextToken: file.getNextToken(token),
            message: 'Operator , should stick to following expression'
        });
    });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype.sameLine" id="apidoc.element.jscs.token_assert.prototype.sameLine">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>sameLine
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sameLine = function (options) {
    options.exactly = 0;

    return this.linesBetween(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
var nextToken = token.getNextCodeToken();

if (canSkip(token) || nextToken.value === ',') {
    return;
}

errors.assert.<span class="apidocCodeKeywordSpan">sameLine</span>({
    token: token,
    nextToken: nextToken,
    message: 'Commas should be placed on the same line as value'
});

errors.assert.differentLine({
    token: token.getPreviousCodeToken(),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype.spacesBetween" id="apidoc.element.jscs.token_assert.prototype.spacesBetween">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>spacesBetween
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spacesBetween = function (options) {
    var token = options.token;
    var nextToken = options.nextToken;
    var atLeast = options.atLeast;
    var atMost = options.atMost;
    var exactly = options.exactly;

    if (!token || !nextToken) {
        return false;
    }

    this._validateOptions(options);

    if (!options.disallowNewLine &amp;&amp; !this._file.isOnTheSameLine(token, nextToken)) {
        return false;
    }

    // Only attempt to remove or add lines if there are no comments between the two nodes
    // as this prevents accidentally moving a valid token onto a line comment ed line
    var fixed = !options.token.getNextNonWhitespaceToken().isComment;

    var emitError = function(countPrefix, spaceCount) {
        var fix = function() {
            this._file.setWhitespaceBefore(nextToken, new Array(spaceCount + 1).join(' '));
        }.bind(this);

        var msgPostfix = token.value + ' and ' + nextToken.value;

        if (!options.message) {
            if (exactly === 0) {
                // support noWhitespaceBetween
                options.message = 'Unexpected whitespace between ' + msgPostfix;
            } else if (exactly !== undefined) {
                // support whitespaceBetween (spaces option)
                options.message = spaceCount + ' spaces required between ' + msgPostfix;
            } else if (atLeast === 1 &amp;&amp; atMost === undefined) {
                // support whitespaceBetween (no spaces option)
                options.message = 'Missing space between ' + msgPostfix;
            } else {
                options.message = countPrefix + ' ' + spaceCount + ' spaces required between ' + msgPostfix;
            }
        }

        this.emit('error', {
            message: options.message,
            element: token,
            offset: token.getSourceCodeLength(),
            fix: fixed ? fix : undefined
        });
    }.bind(this);

    var spacesBetween = this._file.getDistanceBetween(token, nextToken);

    if (atLeast !== undefined &amp;&amp; spacesBetween &lt; atLeast) {
        emitError('at least', atLeast);
        return true;
    }

    if (atMost !== undefined &amp;&amp; spacesBetween &gt; atMost) {
        emitError('at most', atMost);
        return true;
    }

    if (exactly !== undefined &amp;&amp; spacesBetween !== exactly) {
        emitError('exactly', exactly);
        return true;
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Object} options.nextToken
* @param {String} [options.message]
* @param {Number} [options.spaces] Amount of spaces between tokens.
* @return {Boolean} whether an error was found
*/
TokenAssert.prototype.whitespaceBetween = function(options) {
   options.atLeast = 1;
   return this.<span class="apidocCodeKeywordSpan">spacesBetween</span>(options);
};

/**
* Requires to have no whitespace between specified tokens.
*
* @param {Object} options
* @param {Object} options.token
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_assert.prototype.whitespaceBetween" id="apidoc.element.jscs.token_assert.prototype.whitespaceBetween">
        function <span class="apidocSignatureSpan">jscs.token_assert.prototype.</span>whitespaceBetween
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whitespaceBetween = function (options) {
    options.atLeast = 1;
    return this.spacesBetween(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    check: function(file, errors) {
var operators = this._operatorIndex;

// Comma
if (operators[',']) {
    file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
        errors.assert.<span class="apidocCodeKeywordSpan">whitespaceBetween</span>({
            token: token,
            nextToken: file.getNextToken(token),
            message: 'Operator , should not stick to following expression'
        });
    });
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.token_categorizer" id="apidoc.module.jscs.token_categorizer">module jscs.token_categorizer</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.token_categorizer.categorizeCloseParen" id="apidoc.element.jscs.token_categorizer.categorizeCloseParen">
        function <span class="apidocSignatureSpan">jscs.token_categorizer.</span>categorizeCloseParen
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">categorizeCloseParen = function (token) {
    assert(token.value === ')', 'Input token must be a parenthesis');
    var node = token.parentElement;
    var nodeType = node.type;
    var nextToken = token.getNextCodeToken();

    // Terminal statement
    if (nextToken.type === 'EOF') {
        switch (nodeType) {
            case 'DoWhileStatement':
                return 'Statement';
            case 'CallExpression':
            case 'NewExpression':
                return 'CallExpression';
            default:
                return 'ParenthesizedExpression';
        }
    }

    // Part of a parentheses-bearing statement (if, with, while, switch, etc.)
    if (PAREN_KEYWORD_TYPE_RE.test(nodeType) &amp;&amp; !NO_PAREN_KEYWORD_TYPE_RE.test(nodeType)) {
        // Closing parentheses for `switch` and `catch` must be followed by "{"
        // Closing parentheses for `do..while` may be the last punctuation inside a block
        if (nextToken.value === '{' || nextToken.value === '}') {
            return 'Statement';
        }

        // Closing parentheses for other statements must be followed by a statement or declaration
        var nextNode = nextToken.parentElement;
        while (!nodeContains(nextNode, token)) {
            if (QUASI_STATEMENT_TYPE_RE.test(nextNode.type)) {
                return 'Statement';
            }
            nextNode = nextNode.parentElement;
        }
    }

    // Part of a function definition (declaration, expression, method, etc.)
    if (nextToken.value === '{' &amp;&amp; FUNCTION_TYPE_RE.test(nodeType)) {
        return 'Function';
    }

    // Part of a call expression
    if ((nodeType === 'CallExpression' || nodeType === 'NewExpression')) {
        var openParen = node.callee.getNextToken();
        if (openParen.parentElement === node &amp;&amp; node.lastChild === token) {
            return 'CallExpression';
        }
    }

    // All remaining cases are grouping parentheses
    return 'ParenthesizedExpression';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Skip empty parentheses and explicit exceptions
if (value === '(' || value in exceptions) {
    return;
}

// Skip non-expression parentheses
var type = TokenCategorizer.<span class="apidocCodeKeywordSpan">categorizeCloseParen</span>(token);
if (type !== 'ParenthesizedExpression') {
    return;
}

errors.assert.noWhitespaceBetween({
    token: prevToken,
    nextToken: token,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_categorizer.categorizeOpenParen" id="apidoc.element.jscs.token_categorizer.categorizeOpenParen">
        function <span class="apidocSignatureSpan">jscs.token_categorizer.</span>categorizeOpenParen
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">categorizeOpenParen = function (token) {
    assert(token.value === '(', 'Input token must be a parenthesis');
    var node = token.parentElement;
    var nodeType = node.type;
    var prevToken = token.getPreviousCodeToken();

    // Outermost grouping parenthesis
    if (!prevToken) {
        return 'ParenthesizedExpression';
    }

    // Part of a parentheses-bearing statement (if, with, while, switch, etc.)
    if (prevToken.type === 'Keyword' &amp;&amp; PAREN_KEYWORD_TYPE_RE.test(nodeType) &amp;&amp;
        !NO_PAREN_KEYWORD_TYPE_RE.test(nodeType)) {

        return 'Statement';
    }

    // Part of a function definition (declaration, expression, method, etc.)
    if (FUNCTION_TYPE_RE.test(nodeType) &amp;&amp;

        // Name is optional for function expressions
        (prevToken.type === 'Identifier' || prevToken.value === 'function')) {

        return 'Function';
    }

    // Part of a call expression
    var prevNode = prevToken.parentElement;
    if ((nodeType === 'CallExpression' || nodeType === 'NewExpression') &amp;&amp;

        // Must not be inside an arguments list or other grouping parentheses
        prevToken.value !== ',' &amp;&amp; prevToken.value !== '(' &amp;&amp;

        // If the callee is parenthesized (e.g., `(foo.bar)()`), prevNode will match node
        // Otherwise (e.g., `foo.bar()`), prevToken must be the last token of the callee node
        (prevNode === node || prevToken === node.callee.getLastToken())) {

        return 'CallExpression';
    }

    // All remaining cases are grouping parentheses
    return 'ParenthesizedExpression';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Skip empty parentheses and explicit exceptions
if (value === ')' || value in exceptions) {
    return;
}

// Skip non-expression parentheses
var type = TokenCategorizer.<span class="apidocCodeKeywordSpan">categorizeOpenParen</span>(token);
if (type !== 'ParenthesizedExpression') {
    return;
}

errors.assert.noWhitespaceBetween({
    token: token,
    nextToken: nextToken,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.token_index" id="apidoc.module.jscs.token_index">module jscs.token_index</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.token_index.token_index" id="apidoc.element.jscs.token_index.token_index">
        function <span class="apidocSignatureSpan">jscs.</span>token_index
        <span class="apidocSignatureSpan">(firstToken)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenIndex(firstToken) {
    this._buildIndex(firstToken);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.token_index.prototype" id="apidoc.module.jscs.token_index.prototype">module jscs.token_index.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.token_index.prototype._buildIndex" id="apidoc.element.jscs.token_index.prototype._buildIndex">
        function <span class="apidocSignatureSpan">jscs.token_index.prototype.</span>_buildIndex
        <span class="apidocSignatureSpan">(firstToken)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_buildIndex = function (firstToken) {
    this._hasPragmas = false;

    var tokens = [];
    var index = [];
    var positions = [];
    var currentPosition = 0;
    var currentToken = firstToken;
    var lastBlockState = {'*': true};
    var tokenState;
    var previousLoc = {line: 1, column: 0};

    while (currentToken) {
        tokens.push(currentToken);
        currentToken.__loc = previousLoc;

        var newlineCount = currentToken.getNewlineCount();
        if (newlineCount &gt; 0) {
            var lines = currentToken.getSourceCodeLines();
            previousLoc = {
                line: previousLoc.line + newlineCount,
                column: lines[lines.length - 1].length
            };
        } else {
            previousLoc = {
                line: previousLoc.line,
                column: previousLoc.column + currentToken.getSourceCodeLength()
            };
        }

        if (currentToken.isComment) {
            var value = currentToken.value;
            var blockMatch = BLOCK_REGEXP.exec(value);
            if (blockMatch) {
                this._hasPragmas = true;
                lastBlockState = assign({}, lastBlockState, parseRuleNames(blockMatch[2], blockMatch[1] === 'en'));
                tokenState = lastBlockState;
            } else {
                var lineMatch = LINE_REGEXP.exec(value);
                if (lineMatch) {
                    this._hasPragmas = true;
                    var ignoreState = parseRuleNames(lineMatch[1], false);
                    index.push(null);
                    var ignoreToken = currentToken.getPreviousToken();
                    var i = index.length - 1;
                    while (ignoreToken) {
                        i--;
                        index[i] = assign({}, index[i], ignoreState);
                        if (ignoreToken.getNewlineCount() &gt; 0) {
                            break;
                        }
                        ignoreToken = ignoreToken.getPreviousToken();
                    }
                    ignoreToken = currentToken.getNextToken();
                    while (ignoreToken) {
                        index.push(ignoreState);
                        if (ignoreToken.getNewlineCount() &gt; 0) {
                            break;
                        }
                        ignoreToken = ignoreToken.getNextToken();
                    }
                    tokenState = assign({}, lastBlockState, ignoreState);
                } else {
                    tokenState = lastBlockState;
                }
            }
        } else {
            tokenState = lastBlockState;
        }

        if (index[currentPosition]) {
            tokenState = assign({}, tokenState, index[currentPosition]);
        }

        index[currentPosition] = tokenState;
        currentPosition++;

        currentToken = currentToken.getNextToken();
    }
    this._tokens = tokens;
    this._index = index;
    this._positions = positions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Pragma index implementation.
* Checks if rule is enabled or disabled for the specified element.
*
* @param {Element} firstToken
* @constructor
*/
function TokenIndex(firstToken) {
   this.<span class="apidocCodeKeywordSpan">_buildIndex</span>(firstToken);
}

/**
* Builds pragma index.
*
* @param {Element} firstToken
* @private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_index.prototype.getElementLoc" id="apidoc.element.jscs.token_index.prototype.getElementLoc">
        function <span class="apidocSignatureSpan">jscs.token_index.prototype.</span>getElementLoc
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getElementLoc = function (element) {
    return element.getFirstToken().__loc ||  {
        line: 1,
        column: 0
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else if (element.getSourceCodeLength() === 1) {
        offset = 0;
    } else {
        offset = (element.getNewlineCount() === 0 &amp;&amp; Math.ceil(element.getSourceCodeLength() / 2)) || 0;
    }
}

var pos = tokenIndex ? tokenIndex.<span class="apidocCodeKeywordSpan">getElementLoc</span>(element) : element.getLoc().start;
if (!pos) {
    return EMPTY_POS;
}

if (offset === 0) {
    return pos;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.token_index.prototype.isRuleEnabled" id="apidoc.element.jscs.token_index.prototype.isRuleEnabled">
        function <span class="apidocSignatureSpan">jscs.token_index.prototype.</span>isRuleEnabled
        <span class="apidocSignatureSpan">(ruleName, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRuleEnabled = function (ruleName, element) {
    if (!this._hasPragmas) {
        return true;
    }
    var pos = this._tokens.indexOf(element.getFirstToken());
    if (pos !== -1) {
        var state = this._index[pos];
        if (ruleName in state) {
            return state[ruleName];
        }

        return state['*'];
    }

    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

var program = file.getProgram();
var tokenIndex = new TokenIndex(program.getFirstToken());
errors.calculateErrorLocations(tokenIndex);
errors.filter(function(error) {
    if (error.element) {
        return tokenIndex.<span class="apidocCodeKeywordSpan">isRuleEnabled</span>(error.rule, error.element);
    } else {
        return true;
    }
});

// sort errors list to show errors as they appear in source
errors.getErrorList().sort(function(a, b) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.tree_iterator" id="apidoc.module.jscs.tree_iterator">module jscs.tree_iterator</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.tree_iterator.iterate" id="apidoc.element.jscs.tree_iterator.iterate">
        function <span class="apidocSignatureSpan">jscs.tree_iterator.</span>iterate
        <span class="apidocSignatureSpan">(node, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function iterate(node, cb) {
    if ('type' in node) {
        estraverse.traverse(node, {
            enter: function(node, parent) {
                var parentCollection = [];

                // parentCollection support
                var path = this.path();
                if (path) {
                    var collectionKey;
                    while (path.length &gt; 0) {
                        var pathElement = path.pop();
                        if (typeof pathElement === 'string') {
                            collectionKey = pathElement;
                            break;
                        }
                    }

                    parentCollection = parent[collectionKey];
                    if (!Array.isArray(parentCollection)) {
                        parentCollection = [parentCollection];
                    }
                }

                if (cb(node, parent, parentCollection) === false) {
                    return estraverse.VisitorOption.Skip;
                }
            },
            keys: VISITOR_KEYS
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Iterates through the token tree using tree iterator.
 * Calls passed function for every token.
 *
 * @param {Function} cb
 * @param {Object} [tree]
 */
iterate: function(cb, tree) {
    return treeIterator.<span class="apidocCodeKeywordSpan">iterate</span>(tree || this._program, cb);
},

/**
 * Returns nodes by type(s) from earlier built index.
 *
 * @param {String|String[]} type
 * @returns {Object[]}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.utils" id="apidoc.module.jscs.utils">module jscs.utils</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.utils.getFunctionNodeFromIIFE" id="apidoc.element.jscs.utils.getFunctionNodeFromIIFE">
        function <span class="apidocSignatureSpan">jscs.utils.</span>getFunctionNodeFromIIFE
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFunctionNodeFromIIFE = function (node) {
    if (node.type !== 'CallExpression') {
        return null;
    }

    var callee = node.callee;

    if (callee.type === 'FunctionExpression') {
        return callee;
    }

    if (callee.type === 'MemberExpression' &amp;&amp;
        callee.object.type === 'FunctionExpression' &amp;&amp;
        callee.property.type === 'Identifier' &amp;&amp;
        (callee.property.name === 'call' || callee.property.name === 'apply')
    ) {
        return callee.object;
    }

    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var closingParensToken = file.getNextToken(file.getLastNodeToken(node));
var closingTokenValue = closingParensToken ? closingParensToken.value : '';

return openParensToken.value + closingTokenValue === '()';
        }

        file.iterateNodesByType('CallExpression', function(node) {
var inner = utils.<span class="apidocCodeKeywordSpan">getFunctionNodeFromIIFE</span>(node);

if (inner &amp;&amp; !isWrapped(inner) &amp;&amp; !isWrapped(node)) {
    errors.add(
        'Wrap immediately invoked function expressions in parentheses',
        node
    );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.utils.isPragma" id="apidoc.element.jscs.utils.isPragma">
        function <span class="apidocSignatureSpan">jscs.utils.</span>isPragma
        <span class="apidocSignatureSpan">(additionalExceptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPragma = function (additionalExceptions) {
    var pragmaKeywords = [
        'eslint',
        'eslint-env',
        'eslint-enable',
        'eslint-disable',
        'eslint-disable-line',
        'eslint-disable-next-line',
        'global',
        'jshint',
        'jslint',
        'globals',
        'falls through',
        'exported',
        'jscs:',
        'jscs:enable',
        'jscs:disable',
        'jscs:ignore',
        'istanbul'
    ];
    if (additionalExceptions &amp;&amp; Array.isArray(additionalExceptions)) {
        pragmaKeywords = pragmaKeywords.concat(additionalExceptions);
    }

    return function(comment) {
        // pragmaKeywords precede a space or the end of the comment
        var trimmedComment = comment.trim() + ' ';
        for (var i = 0; i &lt; pragmaKeywords.length; i++) {
            if (trimmedComment.indexOf(pragmaKeywords[i] + ' ') === 0) {
                return true;
            }
        }
        return false;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.utils.isRelativePath" id="apidoc.element.jscs.utils.isRelativePath">
        function <span class="apidocSignatureSpan">jscs.utils.</span>isRelativePath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRelativePath = function (path) {
    // Logic from: https://github.com/joyent/node/blob/4f1ae11a62b97052bc83756f8cb8700cc1f61661/lib/module.js#L237
    var start = path.substring(0, 2);
    return start === './' || start === '..';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * or just returns the filepath if not relative
 *
 * @param  {String} filepath
 * @param  {String} basePath
 * @return {String}
 */
exports.normalizePath = function(filepath, basePath) {
    if (this.<span class="apidocCodeKeywordSpan">isRelativePath</span>(filepath)) {
        return path.resolve(basePath, filepath);
    }

    return filepath;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.utils.isSnakeCased" id="apidoc.element.jscs.utils.isSnakeCased">
        function <span class="apidocSignatureSpan">jscs.utils.</span>isSnakeCased
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSnakeCased = function (name) {
    return SNAKE_CASE_RE.test(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var value = node.property.value;
if (// allow numbers, nulls, and anything else
    typeof value !== 'string' ||
    // allow invalid identifiers
    !utils.isValidIdentifierName(value, file.getDialect()) ||
    // allow quoted snake cased identifiers if allExcept: ['snake_case']
    (exceptSnakeCase &amp;&amp; utils.<span class="apidocCodeKeywordSpan">isSnakeCased</span>(utils.trimUnderscores(value))) ||
    // allow quoted reserved words if allExcept: ['keywords']
    ((dialect === 'es3' || exceptKeywords) &amp;&amp; reservedWords.check(value, dialect, true))
) {
    return;
}

errors.add('Use dot notation instead of brackets for member expressions', node.property);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.utils.isValidIdentifierName" id="apidoc.element.jscs.utils.isValidIdentifierName">
        function <span class="apidocSignatureSpan">jscs.utils.</span>isValidIdentifierName
        <span class="apidocSignatureSpan">(name, dialect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidIdentifierName = function (name, dialect) {
    dialect = dialect || 'es5';
    var identifierRegex = dialect === 'es5' ? IDENTIFIER_NAME_ES5_RE : IDENTIFIER_NAME_ES6_RE;
    return !reservedWords.check(name, dialect, true) &amp;&amp; identifierRegex.test(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
}

var value = node.property.value;
if (// allow numbers, nulls, and anything else
    typeof value !== 'string' ||
    // allow invalid identifiers
    !utils.<span class="apidocCodeKeywordSpan">isValidIdentifierName</span>(value, file.getDialect()) ||
    // allow quoted snake cased identifiers if allExcept: ['snake_case']
    (exceptSnakeCase &amp;&amp; utils.isSnakeCased(utils.trimUnderscores(value))) ||
    // allow quoted reserved words if allExcept: ['keywords']
    ((dialect === 'es3' || exceptKeywords) &amp;&amp; reservedWords.check(value, dialect, true))
) {
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.utils.normalizePath" id="apidoc.element.jscs.utils.normalizePath">
        function <span class="apidocSignatureSpan">jscs.utils.</span>normalizePath
        <span class="apidocSignatureSpan">(filepath, basePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizePath = function (filepath, basePath) {
    if (this.isRelativePath(filepath)) {
        return path.resolve(basePath, filepath);
    }

    return filepath;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param  {String} path - The path containing file(s) used to guide the configuration
 *
 * @return {Promise} Resolved with the generated, JSCS configuration
 */
Generator.prototype.generate = function(path) {
var checker = getChecker();
var _path = utils.<span class="apidocCodeKeywordSpan">normalizePath</span>(path, checker.getConfiguration().getBasePath());
var presetNames = Object.keys(checker.getConfiguration().getRegisteredPresets());
var statsForPresets;

console.log('Checking', _path, 'against the presets');

return Vow
.all(presetNames.map(this._checkAgainstPreset.bind(this, _path)))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.utils.promisify" id="apidoc.element.jscs.utils.promisify">
        function <span class="apidocSignatureSpan">jscs.utils.</span>promisify
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">promisify = function (fn) {
    return function() {
        var deferred = Vow.defer();
        var args = [].slice.call(arguments);

        args.push(function(err, result) {
            if (err) {
                deferred.reject(err);
            } else {
                deferred.resolve(result);
            }
        });

        fn.apply(null, args);

        return deferred.promise();
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Promise}
 */
Generator.prototype._getUserViolationChoices = function(errorPrompts) {
    return this._showPrompt(errorPrompts);
};

/** @private */
Generator.prototype._showPrompt = utils.<span class="apidocCodeKeywordSpan">promisify</span>(prompt.get.bind(prompt));

/**
 * @private
 * @param  {Object[]} errorPrompts
 * @param  {Object} choices
 */
Generator.prototype._handleViolatedRules = function(errorPrompts, choices) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.utils.trimUnderscores" id="apidoc.element.jscs.utils.trimUnderscores">
        function <span class="apidocSignatureSpan">jscs.utils.</span>trimUnderscores
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trimUnderscores = function (name) {
    var res = name.replace(TRAILING_UNDERSCORES_RE, '');
    return res ? res : name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var value = node.property.value;
if (// allow numbers, nulls, and anything else
    typeof value !== 'string' ||
    // allow invalid identifiers
    !utils.isValidIdentifierName(value, file.getDialect()) ||
    // allow quoted snake cased identifiers if allExcept: ['snake_case']
    (exceptSnakeCase &amp;&amp; utils.isSnakeCased(utils.<span class="apidocCodeKeywordSpan">trimUnderscores</span>(value))) ||
    // allow quoted reserved words if allExcept: ['keywords']
    ((dialect === 'es3' || exceptKeywords) &amp;&amp; reservedWords.check(value, dialect, true))
) {
    return;
}

errors.add('Use dot notation instead of brackets for member expressions', node.property);
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_aligned_function_parameters" id="apidoc.module.jscs.validate_aligned_function_parameters">module jscs.validate_aligned_function_parameters</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_aligned_function_parameters.validate_aligned_function_parameters" id="apidoc.element.jscs.validate_aligned_function_parameters.validate_aligned_function_parameters">
        function <span class="apidocSignatureSpan">jscs.</span>validate_aligned_function_parameters
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_aligned_function_parameters = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_aligned_function_parameters.prototype" id="apidoc.module.jscs.validate_aligned_function_parameters.prototype">module jscs.validate_aligned_function_parameters.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_aligned_function_parameters.prototype.check" id="apidoc.element.jscs.validate_aligned_function_parameters.prototype.check">
        function <span class="apidocSignatureSpan">jscs.validate_aligned_function_parameters.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var lineBreakAfterOpeningBrace = this._lineBreakAfterOpeningBrace;
    var lineBreakBeforeClosingBrace = this._lineBreakBeforeClosingBrace;

    file.iterateNodesByType([
        'FunctionDeclaration',
        'FunctionExpression',
        'ArrowFunctionExpression'
    ], function(node) {

        // ignore this rule if there are no parameters
        if (node.params.length === 0) {
            return;
        }

        // ignore this rule if the parameters are not multi-line
        var firstParameter = file.getFirstNodeToken(node.params[0]);
        var lastParameter = node.params[node.params.length - 1];
        if (file.isOnTheSameLine(firstParameter, lastParameter)) {
            return;
        }

        // look for the furthest parameter start position
        var maxParamStartPos = 0;
        node.params.forEach(function(parameter) {
            maxParamStartPos = Math.max(maxParamStartPos, parameter.getLoc().start.column);
        });

        // make sure all parameters are lined up
        node.params.forEach(function(parameter) {
            if (parameter.getLoc().start.column !== maxParamStartPos) {
                errors.add('Multi-line parameters are not aligned.', parameter);
            }
        });

        // make sure the first parameter is on a new line
        if (lineBreakAfterOpeningBrace) {
            var openingBrace = file.getPrevToken(firstParameter);
            errors.assert.differentLine({
                token: openingBrace,
                nextToken: firstParameter,
                message: 'There is no line break after the opening brace'
            });
        }

        // make sure the closing brace is on a new line
        if (lineBreakBeforeClosingBrace) {
            var bodyToken = file.getFirstNodeToken(node.body);
            var closingBrace = file.getPrevToken(bodyToken);
            errors.assert.differentLine({
                token: lastParameter,
                nextToken: closingBrace,
                message: 'There is no line break before the closing brace'
            });
        }

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_aligned_function_parameters.prototype.configure" id="apidoc.element.jscs.validate_aligned_function_parameters.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.validate_aligned_function_parameters.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var validProperties = [
        'lineBreakAfterOpeningBrace',
        'lineBreakBeforeClosingBrace'
    ];
    var optionName = this.getOptionName();

    assert(
        typeof options === 'object' || options === true,
        optionName + ' option must be an object or boolean true'
    );

    if (typeof options === 'object') {
        validProperties.forEach(function(key) {
            var isPresent = key in options;

            if (isPresent) {
                assert(
                    options[key] === true,
                    optionName + '.' + key + ' property requires true value or should be removed'
                );
            }
        });

        validProperties.forEach(function(property) {
            this['_' + property] = Boolean(options[property]);
        }.bind(this));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_aligned_function_parameters.prototype.getOptionName" id="apidoc.element.jscs.validate_aligned_function_parameters.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.validate_aligned_function_parameters.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'validateAlignedFunctionParameters';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_comment_position" id="apidoc.module.jscs.validate_comment_position">module jscs.validate_comment_position</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_comment_position.validate_comment_position" id="apidoc.element.jscs.validate_comment_position.validate_comment_position">
        function <span class="apidocSignatureSpan">jscs.</span>validate_comment_position
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_comment_position = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_comment_position.prototype" id="apidoc.module.jscs.validate_comment_position.prototype">module jscs.validate_comment_position.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_comment_position.prototype.check" id="apidoc.element.jscs.validate_comment_position.prototype.check">
        function <span class="apidocSignatureSpan">jscs.validate_comment_position.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var position = this._position;
    var isExcepted = this._isExcepted;
    file.iterateTokensByType('CommentLine', function(comment) {
        if (isExcepted(comment.value)) {
            return;
        }

        var isFirstToken = true;
        var currentToken = comment.getPreviousToken();
        while (currentToken) {
            if (currentToken.isWhitespace) {
                if (currentToken.getNewlineCount() &gt; 0) {
                    break;
                }
            } else {
                isFirstToken = false;
            }

            currentToken = currentToken.getPreviousToken();
        }

        if (position === 'above' &amp;&amp; !isFirstToken) {
            errors.add('Expected comments to be above the code not beside', comment);
        }
        if (position === 'beside' &amp;&amp; isFirstToken) {
            errors.add('Expected comments to be beside the code not above', comment);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_comment_position.prototype.configure" id="apidoc.element.jscs.validate_comment_position.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.validate_comment_position.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    var validPositions = {
        'above': 'above',
        'beside': 'beside'
    };
    var allExcept = options.allExcept;
    assert(
        typeof options === 'object' &amp;&amp; validPositions[options.position],
        this.getOptionName() + ' requires one of the following values: ' + Object.keys(validPositions).join(', ')
    );
    if (Array.isArray(allExcept)) {
        assert(
            allExcept.every(function(el) { return typeof el === 'string'; }),
            'Property `allExcept` in ' + allExcept + ' should be an array of strings'
        );
        this._isExcepted = isPragma(allExcept);
    } else {
        this._isExcepted  = isPragma();
    }
    this._position = options.position;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_comment_position.prototype.getOptionName" id="apidoc.element.jscs.validate_comment_position.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.validate_comment_position.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'validateCommentPosition';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_indentation" id="apidoc.module.jscs.validate_indentation">module jscs.validate_indentation</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.validate_indentation" id="apidoc.element.jscs.validate_indentation.validate_indentation">
        function <span class="apidocSignatureSpan">jscs.</span>validate_indentation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_indentation = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_indentation.prototype" id="apidoc.module.jscs.validate_indentation.prototype">module jscs.validate_indentation.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.prototype._checkNode" id="apidoc.element.jscs.validate_indentation.prototype._checkNode">
        function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_checkNode
        <span class="apidocSignatureSpan">(parentElement, errors, initialIndent, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkNode = function (parentElement, errors, initialIndent, options) {
    var moduleBody = options.moduleBody;
    var firstWhitespace = options.firstWhitespace;
    var isBlock = false;
    var isModuleBody = false;
    var checkBlockIndentation = false;
    var indent = initialIndent;
    var isSwitchStatement = parentElement.type === 'SwitchStatement';
    var calculateFunctionExpressionIndent = null;
    var indentCases = null;

    if (isSwitchStatement) {
        indent++;
        isBlock = true;
        checkBlockIndentation = true;
    }
    if (parentElement.type === 'Program') {
        checkBlockIndentation = true;
    }
    if (parentElement.type === 'BlockStatement') {
        indent++;
        isBlock = true;
        checkBlockIndentation = true;
        isModuleBody = parentElement === moduleBody;
        if (isModuleBody &amp;&amp; this._indentModuleBodies === false) {
            indent--;
        } else if (parentElement.parentElement.type === 'SwitchCase') {
            // Avoiding additional indentation if `{` is on the same line with case block start
            if (isBlockOnTheSameLineWithCase(parentElement)) {
                indent--;
            }
        } else {
            // Calculating indentation for function expressions.
            calculateFunctionExpressionIndent = isFunctionExpression(parentElement.parentElement);
            if (calculateFunctionExpressionIndent) {
                indent = this._getFunctionIndent(parentElement.parentElement, indent);
            }
        }
    }
    if (parentElement.type === 'ClassBody') {
        indent++;
        isBlock = true;
        checkBlockIndentation = true;
    }
    if (parentElement.type === 'SwitchCase') {
        indent++;
        checkBlockIndentation = true;
    }
    if (parentElement.type === 'ObjectExpression') {
        indent++;
        indent = this._getObjectExpressionIndent(parentElement, indent);
        isBlock = true;
        checkBlockIndentation = true;
    }
    var nonBlockChecks = nonBlockIndentChecks[parentElement.type];
    var statementsToCheck;
    if (nonBlockChecks) {
        statementsToCheck = nonBlockChecks.filter(function(propName) {
            return parentElement[propName] &amp;&amp; parentElement[propName].type !== 'BlockStatement';
        });
    }

    var element = parentElement.firstChild;
    while (element) {
        if (element.isToken) {
            var isFirstWhitespace = element === firstWhitespace;
            if (element.isWhitespace &amp;&amp; (element.getNewlineCount() &gt; 0 || isFirstWhitespace)) {
                var lines = getLineData(element.getSourceCode());
                var lineOffset = this._includeEmptyLines ?
                    (isFirstWhitespace ? 0 : 1) :
                    lines.length - 1;
                lines = lines.slice(lineOffset);

                for (var i = 0; i &lt; lines.length; i++) {
                    var line = lines[i].line;
                    if (line.indexOf(this._nonIndentChar) !== -1) {
                        errors.add(
                            'Invalid indentation character: ' + this._nonIndentChar,
                            element,
                            lines[i].offset
                        );
                    }
                    var nextSibling = element.nextSibling;
                    var checkForStatement = false;
                    var checkForKeyword = false;
                    if (!checkBlockIndentation) {
                        if (statementsToCheck &amp;&amp; statementsToCheck.length &gt; 0) {
                            if (statementsToCheck.indexOf(nextSibling) !== -1) {
                                checkForStatement = true;
                            }
                        }
                        var nextToken = element.getNextToken();
                        if (nextToken &amp;&amp;
                            nextToken.isToken &amp;&amp;
                            nextToken.type === 'Keyword' &amp;&amp;
                            keywordsToCheck[nextToken.value]
                        ) {
                            checkForKeyword = true;
                        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                                }
                            });
                        }
                    }
                }
            }
        } else {
            this.<span class="apidocCodeKeywordSpan">_checkNode</span>(element, errors, indent, options);
        }
        element = element.nextSibling;
    }
},

check: function(file, errors) {
    var program = file.getProgram();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.prototype._fix" id="apidoc.element.jscs.validate_indentation.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var indentChar = this._indentChar;
    var whitespaceToken = error.element;

    var fixData = error.additional;
    var indentDiff = fixData.indentDiff;

    var lineItemsData = getLineData(whitespaceToken.value);
    var lineItemToFix = lineItemsData[fixData.line];
    if (lineItemToFix) {
        var originalIndentLength = lineItemToFix.line.length;
        var finalIndentLength = originalIndentLength + indentDiff;
        lineItemToFix.line = new Array(finalIndentLength + 1).join(indentChar);
        var newWhitespaceToken = new cst.Token(
            'Whitespace',
            convertLinesToString(lineItemsData)
        );
        whitespaceToken.parentElement.replaceChild(newWhitespaceToken, whitespaceToken);

        var adjustElement = fixData.adjustElement;
        if (adjustElement &amp;&amp; adjustElement.getNewlineCount() &gt; 0) {
            var currentToken = adjustElement.getFirstToken();
            var lastToken = adjustElement.getLastToken();
            while (true) {
                var nextToken = currentToken.getNextToken();
                if (currentToken.isWhitespace &amp;&amp; currentToken.getNewlineCount() &gt; 0) {
                    var newSubWhitespaceToken = new cst.Token(
                        currentToken.type,
                        applyIndentationDiff(currentToken.value, indentDiff, indentChar, this._includeEmptyLines)
                    );
                    currentToken.parentElement.replaceChild(newSubWhitespaceToken, currentToken);
                }
                if (currentToken.isComment &amp;&amp; currentToken.getNewlineCount() &gt; 0) {
                    var prev = currentToken.getPreviousToken();
                    var commentIndent = 0;
                    if (prev.isWhitespace &amp;&amp; prev.getNewlineCount() &gt; 0) {
                        commentIndent = prev.getSourceCodeLines().concat().pop().length;
                    }
                    var commentDiff = indentDiff &lt; 0 &amp;&amp; commentIndent &lt; -indentDiff ?
                        -commentIndent :
                        indentDiff;
                    var newCommentToken = new cst.Token(
                        currentToken.type,
                        applyIndentationDiff(
                            currentToken.value,
                            commentDiff,
                            indentChar,
                            this._includeEmptyLines
                        )
                    );
                    currentToken.parentElement.replaceChild(newCommentToken, currentToken);
                }
                if (currentToken === lastToken) {
                    break;
                }
                currentToken = nextToken;
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &amp;&amp; instance._fix) {
        // "error.fixed = true" should go first, so rule can
        // decide for itself (with "error.fixed = false")
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.prototype._getElementDirectIndent" id="apidoc.element.jscs.validate_indentation.prototype._getElementDirectIndent">
        function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_getElementDirectIndent
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getElementDirectIndent = function (node) {
    var whitespaceToken = node.getPreviousToken();
    if (whitespaceToken.isWhitespace &amp;&amp; whitespaceToken.getNewlineCount() &gt; 0) {
        var endTokenLines = whitespaceToken.getSourceCodeLines();
        return Math.floor(endTokenLines[endTokenLines.length - 1].length / this._indentSize);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {FunctionExpression|ArrowFunctionExpression} functionExpression
 * @param {Number} indent
 * @returns {Number}
 * @private
 */
_getFunctionIndent: function(functionExpression, indent) {
    var functionIndent = 0;
    var indentBeforeClosingBrace = this.<span class="apidocCodeKeywordSpan">_getElementDirectIndent</span>(functionExpression.body
.lastChild);
    if (indentBeforeClosingBrace !== null) {
        functionIndent = indentBeforeClosingBrace + 1;
    }
    var indentBeforeFunction = this._getElementDirectIndent(functionExpression);
    if (indentBeforeFunction !== null) {
        functionIndent = Math.min(functionIndent, indentBeforeFunction  + 1);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.prototype._getFunctionIndent" id="apidoc.element.jscs.validate_indentation.prototype._getFunctionIndent">
        function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_getFunctionIndent
        <span class="apidocSignatureSpan">(functionExpression, indent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getFunctionIndent = function (functionExpression, indent) {
    var functionIndent = 0;
    var indentBeforeClosingBrace = this._getElementDirectIndent(functionExpression.body.lastChild);
    if (indentBeforeClosingBrace !== null) {
        functionIndent = indentBeforeClosingBrace + 1;
    }
    var indentBeforeFunction = this._getElementDirectIndent(functionExpression);
    if (indentBeforeFunction !== null) {
        functionIndent = Math.min(functionIndent, indentBeforeFunction  + 1);
    }
    return Math.max(indent, functionIndent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (isBlockOnTheSameLineWithCase(parentElement)) {
            indent--;
        }
    } else {
        // Calculating indentation for function expressions.
        calculateFunctionExpressionIndent = isFunctionExpression(parentElement.parentElement);
        if (calculateFunctionExpressionIndent) {
            indent = this.<span class="apidocCodeKeywordSpan">_getFunctionIndent</span>(parentElement.parentElement, indent);
        }
    }
}
if (parentElement.type === 'ClassBody') {
    indent++;
    isBlock = true;
    checkBlockIndentation = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.prototype._getObjectExpressionIndent" id="apidoc.element.jscs.validate_indentation.prototype._getObjectExpressionIndent">
        function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>_getObjectExpressionIndent
        <span class="apidocSignatureSpan">(objectExpression, indent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getObjectExpressionIndent = function (objectExpression, indent) {
    var objectIndent = 0;
    var properties = objectExpression.properties;

    // Handling nested one-line objects, i.e. `{prop: {\n`
    if (objectExpression.parentElement.type === 'ObjectProperty') {
        var parentObjectExpressionBrace = objectExpression.parentElement.parentElement.firstChild;
        var currentToken = objectExpression.getPreviousToken();
        while (currentToken) {
            if (currentToken === parentObjectExpressionBrace) {
                indent--;
                break;
            }
            if (currentToken.getNewlineCount() &gt; 0) {
                break;
            }
            currentToken = currentToken.getPreviousToken();
        }
    }
    for (var i = 0; i &lt; properties.length; i++) {
        var property = properties[i];
        objectIndent = this._getElementDirectIndent(property);
        if (objectIndent !== null) {
            break;
        }

    }
    return Math.max(indent, objectIndent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (parentElement.type === 'SwitchCase') {
    indent++;
    checkBlockIndentation = true;
}
if (parentElement.type === 'ObjectExpression') {
    indent++;
    indent = this.<span class="apidocCodeKeywordSpan">_getObjectExpressionIndent</span>(parentElement, indent);
    isBlock = true;
    checkBlockIndentation = true;
}
var nonBlockChecks = nonBlockIndentChecks[parentElement.type];
var statementsToCheck;
if (nonBlockChecks) {
    statementsToCheck = nonBlockChecks.filter(function(propName) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.prototype.check" id="apidoc.element.jscs.validate_indentation.prototype.check">
        function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var program = file.getProgram();
    var firstWhitespace;
    if (program.getFirstToken().isWhitespace) {
        firstWhitespace = program.getFirstToken();
    }
    this._checkNode(program, errors, 0, {
        moduleBody: getModuleBody(program),
        firstWhitespace: firstWhitespace
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.prototype.configure" id="apidoc.element.jscs.validate_indentation.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    this._includeEmptyLines = false;
    this._exceptComments = false;

    if (typeof options === 'object') {
        this._includeEmptyLines = (options.includeEmptyLines === true);
        if (Array.isArray(options.allExcept)) {
            this._exceptComments = options.allExcept.indexOf('comments') &gt; -1;
            this._includeEmptyLines = options.allExcept.indexOf('emptyLines') === -1;
        }

        options = options.value;
    }

    assert(
        options === '\t' ||
            (typeof options === 'number' &amp;&amp; options &gt; 0),
        this.getOptionName() + ' option requires a positive number of spaces or "\\t"' +
        ' or options object with "value" property'
    );

    if (typeof options === 'number') {
        this._indentChar = ' ';
        this._nonIndentChar = '\t';
        this._indentSize = options;
    } else {
        this._nonIndentChar = ' ';
        this._indentChar = '\t';
        this._indentSize = 1;
    }

    this._indentBreaks = null;
    this._indentModuleBodies = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_indentation.prototype.getOptionName" id="apidoc.element.jscs.validate_indentation.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.validate_indentation.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'validateIndentation';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_line_breaks" id="apidoc.module.jscs.validate_line_breaks">module jscs.validate_line_breaks</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_line_breaks.validate_line_breaks" id="apidoc.element.jscs.validate_line_breaks.validate_line_breaks">
        function <span class="apidocSignatureSpan">jscs.</span>validate_line_breaks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_line_breaks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_line_breaks.prototype" id="apidoc.module.jscs.validate_line_breaks.prototype">module jscs.validate_line_breaks.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_line_breaks.prototype.check" id="apidoc.element.jscs.validate_line_breaks.prototype.check">
        function <span class="apidocSignatureSpan">jscs.validate_line_breaks.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var lines = file.getLines();
    if (lines.length &lt; 2) {
        return;
    }

    file.getProgram().selectTokensByType('Whitespace').some(function(whitespace) {
        LINE_BREAKS.lastIndex = 0;
        var match;
        while ((match = LINE_BREAKS.exec(whitespace.value)) !== null) {
            if (match[0] !== this._allowedLineBreak) {
                errors.add('Invalid line break', whitespace, match.index);
                return this._reportOncePerFile;
            }
        }
    }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_line_breaks.prototype.configure" id="apidoc.element.jscs.validate_line_breaks.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.validate_line_breaks.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === 'string' || typeof options === 'object',
        this.getOptionName() + ' option requires string or object value'
    );

    if (typeof options === 'string') {
        options = { character: options };
    }

    var lineBreaks = {
        CR: '\r',
        LF: '\n',
        CRLF: '\r\n'
    };
    this._allowedLineBreak = lineBreaks[options.character];

    this._reportOncePerFile = options.reportOncePerFile !== false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_line_breaks.prototype.getOptionName" id="apidoc.element.jscs.validate_line_breaks.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.validate_line_breaks.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'validateLineBreaks';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_newline_after_array_elements" id="apidoc.module.jscs.validate_newline_after_array_elements">module jscs.validate_newline_after_array_elements</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_newline_after_array_elements.validate_newline_after_array_elements" id="apidoc.element.jscs.validate_newline_after_array_elements.validate_newline_after_array_elements">
        function <span class="apidocSignatureSpan">jscs.</span>validate_newline_after_array_elements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_newline_after_array_elements = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_newline_after_array_elements.prototype" id="apidoc.module.jscs.validate_newline_after_array_elements.prototype">module jscs.validate_newline_after_array_elements.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_newline_after_array_elements.prototype.check" id="apidoc.element.jscs.validate_newline_after_array_elements.prototype.check">
        function <span class="apidocSignatureSpan">jscs.validate_newline_after_array_elements.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var maximum = this._options.maximum;
    var ignoreBrackets = this._options.ignoreBrackets;

    file.iterateNodesByType(['ArrayExpression'], function(node) {
        var els = node.elements;
        var firstEl = els[0];
        var lastEl = els[els.length - 1];
        var bracket;
        var elToken;

        if (els.length &lt;= maximum &amp;&amp; node.getLoc().start.line === node.getLoc().end.line) {
            return;
        }

        if (!ignoreBrackets) {
            if (firstEl &amp;&amp; firstEl.getLoc().start.line === node.getLoc().start.line) {
                bracket = file.getFirstNodeToken(node);
                elToken = file.getNextToken(bracket);

                errors.assert.differentLine({
                    token: bracket,
                    nextToken: elToken,
                    message: 'First element should be placed on new line'
                });
            }
            if (lastEl &amp;&amp; lastEl.getLoc().end.line === node.getLoc().end.line) {
                bracket = file.getLastNodeToken(node);
                elToken = file.getPrevToken(bracket);

                errors.assert.differentLine({
                    token: elToken,
                    nextToken: bracket,
                    message: 'Closing bracket should be placed on new line'
                });
            }
        }

        els.forEach(function(elem) {
            var elToken;
            var comma;

            if (!elem) {
                // skip holes
                return;
            }

            if (firstEl !== elem) {
                elToken = file.getFirstNodeToken(elem);
                comma = file.getPrevToken(elToken);

                errors.assert.differentLine({
                    token: comma,
                    nextToken: elToken,
                    message: 'Multiple elements at a single line in multiline array'
                });
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_newline_after_array_elements.prototype.configure" id="apidoc.element.jscs.validate_newline_after_array_elements.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.validate_newline_after_array_elements.prototype.</span>configure
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (opts) {
    assert(
        opts === true ||
        typeof opts === 'number' &amp;&amp; opts &gt;= 1 ||
        typeof opts === 'object',
        this.getOptionName() + ' option requires maximal number of items ' +
            'or true value either should be removed'
    );
    if (typeof opts === 'object') {
        this._options = {
            maximum: Infinity,
            ignoreBrackets: false
        };

        if ('maximum' in opts) {
            assert(typeof opts.maximum === 'number' &amp;&amp; opts.maximum &gt;= 1,
                'maximum property requires a positive number or should be removed');
            this._options.maximum = opts.maximum;
        }

        if ('ignoreBrackets' in opts) {
            assert(opts.ignoreBrackets === true,
                'ignoreBrackets property requires true value or should be removed');
            this._options.ignoreBrackets = true;
        }
    } else {
        this._options = {
            maximum: opts === true ? Infinity : opts,
            ignoreBrackets: false
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_newline_after_array_elements.prototype.getOptionName" id="apidoc.element.jscs.validate_newline_after_array_elements.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.validate_newline_after_array_elements.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'validateNewlineAfterArrayElements';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_order_in_object_keys" id="apidoc.module.jscs.validate_order_in_object_keys">module jscs.validate_order_in_object_keys</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_order_in_object_keys.validate_order_in_object_keys" id="apidoc.element.jscs.validate_order_in_object_keys.validate_order_in_object_keys">
        function <span class="apidocSignatureSpan">jscs.</span>validate_order_in_object_keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_order_in_object_keys = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_order_in_object_keys.prototype" id="apidoc.module.jscs.validate_order_in_object_keys.prototype">module jscs.validate_order_in_object_keys.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_order_in_object_keys.prototype.check" id="apidoc.element.jscs.validate_order_in_object_keys.prototype.check">
        function <span class="apidocSignatureSpan">jscs.validate_order_in_object_keys.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var sort = this._sort;

    file.iterateNodesByType('ObjectExpression', function(node) {
        var keys = node.properties.map(function(property) {
            return (property.key.name || property.key.value);
        });

        var sorted = keys.slice(0).sort(sort);
        var unsorted;

        for (var i = 0; i &lt; keys.length; i++) {
            if (keys[i] !== sorted[i]) {
                unsorted = i;

                break;
            }
        }

        if (undefined !== unsorted) {
            errors.add(
                'Object keys must be in ' + (/asc/.test(sort.name) ? 'ascending' : 'descending') + ' order',
                node.properties[unsorted]
            );
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_order_in_object_keys.prototype.configure" id="apidoc.element.jscs.validate_order_in_object_keys.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.validate_order_in_object_keys.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        options === true || Object.keys(methods).indexOf(options) !== -1,
        this.getOptionName() + ' option requires a true value or should be removed'
    );

    this._sort = methods[options] || methods.asc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_order_in_object_keys.prototype.getOptionName" id="apidoc.element.jscs.validate_order_in_object_keys.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.validate_order_in_object_keys.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'validateOrderInObjectKeys';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_parameter_separator" id="apidoc.module.jscs.validate_parameter_separator">module jscs.validate_parameter_separator</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_parameter_separator.validate_parameter_separator" id="apidoc.element.jscs.validate_parameter_separator.validate_parameter_separator">
        function <span class="apidocSignatureSpan">jscs.</span>validate_parameter_separator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_parameter_separator = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_parameter_separator.prototype" id="apidoc.module.jscs.validate_parameter_separator.prototype">module jscs.validate_parameter_separator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_parameter_separator.prototype.check" id="apidoc.element.jscs.validate_parameter_separator.prototype.check">
        function <span class="apidocSignatureSpan">jscs.validate_parameter_separator.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {

    var separators = this._separator.split(',');
    var whitespaceBeforeComma = Boolean(separators.shift());
    var whitespaceAfterComma = Boolean(separators.pop());

    file.iterateNodesByType([
        'FunctionDeclaration',
        'FunctionExpression',
        'ClassMethod'
    ], function(node) {

        node.params.forEach(function(paramNode) {

            var prevParamToken = file.getFirstNodeToken(paramNode);
            var punctuatorToken = file.getNextToken(prevParamToken);

            if (punctuatorToken.value === ',') {

                if (whitespaceBeforeComma) {
                    errors.assert.spacesBetween({
                        token: prevParamToken,
                        nextToken: punctuatorToken,
                        exactly: 1,
                        message: 'One space required after function parameter \'' + prevParamToken.value + '\''
                    });
                } else {
                    errors.assert.noWhitespaceBetween({
                        token: prevParamToken,
                        nextToken: punctuatorToken,
                        message: 'Unexpected space after function parameter \'' + prevParamToken.value + '\''
                    });
                }

                var nextParamToken = file.getNextToken(punctuatorToken);

                if (whitespaceAfterComma) {
                    errors.assert.spacesBetween({
                        token: punctuatorToken,
                        nextToken: nextParamToken,
                        exactly: 1,
                        message: 'One space required before function parameter \'' + nextParamToken.value + '\''
                    });
                } else {
                    errors.assert.noWhitespaceBetween({
                        token: punctuatorToken,
                        nextToken: nextParamToken,
                        message: 'Unexpected space before function parameter \'' + nextParamToken.value + '\''
                    });
                }
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_parameter_separator.prototype.configure" id="apidoc.element.jscs.validate_parameter_separator.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.validate_parameter_separator.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
    assert(
        typeof options === 'string' &amp;&amp; /^[ ]?,[ ]?$/.test(options),
        this.getOptionName() + ' option requires string value containing only a comma and optional spaces'
    );

    this._separator = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_parameter_separator.prototype.getOptionName" id="apidoc.element.jscs.validate_parameter_separator.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.validate_parameter_separator.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'validateParameterSeparator';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_quote_marks" id="apidoc.module.jscs.validate_quote_marks">module jscs.validate_quote_marks</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_quote_marks.validate_quote_marks" id="apidoc.element.jscs.validate_quote_marks.validate_quote_marks">
        function <span class="apidocSignatureSpan">jscs.</span>validate_quote_marks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_quote_marks = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jscs.validate_quote_marks.prototype" id="apidoc.module.jscs.validate_quote_marks.prototype">module jscs.validate_quote_marks.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jscs.validate_quote_marks.prototype._fix" id="apidoc.element.jscs.validate_quote_marks.prototype._fix">
        function <span class="apidocSignatureSpan">jscs.validate_quote_marks.prototype.</span>_fix
        <span class="apidocSignatureSpan">(file, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_fix = function (file, error) {
    var token = error.additional;

    var fixer = require(this._quoteMark === '"' ? 'to-double-quotes' : 'to-single-quotes');
    var newToken = cst.Token.createFromToken({
        type: 'String',
        value: token.value,
        sourceCode: fixer(token.getSourceCode())
    });

    token.parentElement.replaceChild(newToken, token);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var instance = configuration.getConfiguredRule(error.rule);

    if (instance &amp;&amp; instance._fix) {
        // "error.fixed = true" should go first, so rule can
        // decide for itself (with "error.fixed = false")
        // if it can fix this particular error
        error.fixed = true;
        instance.<span class="apidocCodeKeywordSpan">_fix</span>(file, error);
    }

    return !!error.fixed;
},

/**
 * Apply specific and common fixes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_quote_marks.prototype.check" id="apidoc.element.jscs.validate_quote_marks.prototype.check">
        function <span class="apidocSignatureSpan">jscs.validate_quote_marks.prototype.</span>check
        <span class="apidocSignatureSpan">(file, errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">check = function (file, errors) {
    var quoteMark = this._quoteMark;
    var allowEscape = this._allowEscape;
    var ignoreJSX = this._ignoreJSX;

    var opposite = {
        '"': '\'',
        '\'': '"'
    };
    file.iterateTokensByType('String', function(token) {
        if (
            ignoreJSX &amp;&amp;
            token.parentElement.type === 'StringLiteral' &amp;&amp;
            token.parentElement.parentElement.type === 'JSXAttribute'
        ) {
            return;
        }

        var str = token.getSourceCode();
        var mark = str[0];
        var stripped = str.substring(1, str.length - 1);

        if (quoteMark === true) {
            quoteMark = mark;
        }

        if (mark !== quoteMark) {
            if (allowEscape &amp;&amp; stripped.indexOf(opposite[mark]) &gt; -1) {
                return;
            }

            errors.cast({
                message: 'Invalid quote mark found',
                element: token,
                additional: token
            });
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var errorFilter = this._configuration.getErrorFilter();

this._configuredRules.forEach(function(rule) {
    errors.setCurrentRule(rule.getOptionName());

    try {
        rule.<span class="apidocCodeKeywordSpan">check</span>(file, errors);
    } catch (e) {
        errors.setCurrentRule('internalError');
        errors.add(getInternalErrorMessage(rule.getOptionName(), e), file.getProgram());
    }
}, this);

this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_quote_marks.prototype.configure" id="apidoc.element.jscs.validate_quote_marks.prototype.configure">
        function <span class="apidocSignatureSpan">jscs.validate_quote_marks.prototype.</span>configure
        <span class="apidocSignatureSpan">(quoteMark)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (quoteMark) {
    this._allowEscape = false;
    this._ignoreJSX = false;

    if (typeof quoteMark === 'object') {
        assert(
            typeof quoteMark.escape === 'boolean' &amp;&amp; quoteMark.mark !== undefined,
            this.getOptionName() + ' option requires the "escape" and "mark" property to be defined'
        );
        this._allowEscape = quoteMark.escape;

        if (quoteMark.ignoreJSX) {
            this._ignoreJSX = quoteMark.ignoreJSX;
        }

        quoteMark = quoteMark.mark;
    }

    assert(
        quoteMark === '"' || quoteMark === '\'' || quoteMark === true,
        this.getOptionName() + ' option requires \'"\', "\'", or boolean true'
    );

    assert(
        quoteMark === '"' || quoteMark === '\'' || quoteMark === true,
        this.getOptionName() + ' option requires \'"\', "\'", or boolean true'
    );

    this._quoteMark = quoteMark;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    program.maxErrors = Infinity;
}

checker.getConfiguration().overrideFromCLI(program);
checker.getConfiguration().registerDefaultRules();

try {
    checker.<span class="apidocCodeKeywordSpan">configure</span>(config);
} catch (e) {
    console.error(e.message);
    defer.reject(1);

    return returnArgs;
}
if (program.autoConfigure) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jscs.validate_quote_marks.prototype.getOptionName" id="apidoc.element.jscs.validate_quote_marks.prototype.getOptionName">
        function <span class="apidocSignatureSpan">jscs.validate_quote_marks.prototype.</span>getOptionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getOptionName = function () {
    return 'validateQuoteMarks';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Assertions: add tests for linesBetween (Mike Sherov)
* Assertions: Make sure newlines get fixed (gero3)
* TokenAssert: remove newline fixing logic duplication to prepare for further fixes (Mike Sherov)
* TokenAssert: simplify and strengthen linesBetween rules (Mike Sherov)
* Token Assert: normalize whiteSpace assertions to match line assertions (Mike Sherov)
* requireLineFeedAtFileEnd: make use of assert (gero3)
* Don't trim whitespace in markdown-files (Simen Bekkhus)
* Cleanup: use this.<span class="apidocCodeKeywordSpan">getOptionName</span>() for consistency, options variable (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue where appropriate (Mike Sherov)
* Cleanup: remove archaic functions from JsFile (Mike Sherov)
* Cleanup: remove usage of getComment(After|Before)Token (Mike Sherov)
* Cleanup: remove redundant boolean check, use consistent error messages (Henry Zhu)
* Cleanup: use iterateTokensByTypeAndValue and this.getOptionName() (Henry Zhu)
* requireSpaceAfterKeywords: use token assert (Henry Zhu)
* JsFile::getFirstTokenOnLine implementation (for indentation rules) (mdevils)
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>